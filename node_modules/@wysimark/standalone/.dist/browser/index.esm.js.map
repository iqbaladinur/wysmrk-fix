{"version":3,"sources":["../../react-shim.js","../../../../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js","../../../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js","../../src/index.ts","../../src/entry/index.tsx","../../../react/src/entry/index.tsx","../../../react/src/convert/index.ts","../../../react/src/convert/parse/index.ts","../../../../node_modules/.pnpm/remark-gfm@3.0.1/node_modules/remark-gfm/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm@2.0.3/node_modules/micromark-extension-gfm/index.js","../../../../node_modules/.pnpm/micromark-util-combine-extensions@1.1.0/node_modules/micromark-util-combine-extensions/index.js","../../../../node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js","../../../../node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/index.js","../../../../node_modules/.pnpm/micromark-util-character@1.2.0/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","../../../../node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/lib/syntax.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/attention.js","../../../../node_modules/.pnpm/micromark-util-classify-character@1.1.0/node_modules/micromark-util-classify-character/index.js","../../../../node_modules/.pnpm/micromark-util-resolve-all@1.1.0/node_modules/micromark-util-resolve-all/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/autolink.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/blank-line.js","../../../../node_modules/.pnpm/micromark-factory-space@1.1.0/node_modules/micromark-factory-space/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/block-quote.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-escape.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-reference.js","../../../../node_modules/.pnpm/decode-named-character-reference@1.0.2/node_modules/decode-named-character-reference/index.dom.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-fenced.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-indented.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-text.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/content.js","../../../../node_modules/.pnpm/micromark-util-subtokenize@1.1.0/node_modules/micromark-util-subtokenize/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/definition.js","../../../../node_modules/.pnpm/micromark-factory-destination@1.1.0/node_modules/micromark-factory-destination/index.js","../../../../node_modules/.pnpm/micromark-factory-label@1.1.0/node_modules/micromark-factory-label/index.js","../../../../node_modules/.pnpm/micromark-factory-title@1.1.0/node_modules/micromark-factory-title/index.js","../../../../node_modules/.pnpm/micromark-factory-whitespace@1.1.0/node_modules/micromark-factory-whitespace/index.js","../../../../node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/hard-break-escape.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/heading-atx.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-flow.js","../../../../node_modules/.pnpm/micromark-util-html-tag-name@1.2.0/node_modules/micromark-util-html-tag-name/index.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-text.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-end.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-image.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-link.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/line-ending.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/list.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/thematic-break.js","../../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/setext-underline.js","../../../../node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js","../../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/syntax.js","../../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/edit-map.js","../../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/infer.js","../../../../node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/index.js","../../../../node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js","../../../../node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/index.js","../../../../node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/lib/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js","../../../../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js","../../../../node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/index.js","../../../../node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/lib/index.js","../../../../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js","../../../../node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/index.js","../../../../node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js","../../../../node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/index.js","../../../../node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js","../../../../node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js","../../../../node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js","../../../../node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/index.js","../../../../node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/index.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js","../../../../node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../../../node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/lib/index.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","../../../../node_modules/.pnpm/markdown-table@3.0.3/node_modules/markdown-table/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/index.js","../../../../node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","../../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","../../../../node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/index.js","../../../../node_modules/.pnpm/remark-parse@10.0.1/node_modules/remark-parse/lib/index.js","../../../../node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/index.js","../../../../node_modules/.pnpm/mdast-util-from-markdown@1.3.1/node_modules/mdast-util-from-markdown/lib/index.js","../../../../node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/index.js","../../../../node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/lib/index.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/parse.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/content.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/document.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/flow.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/text.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/create-tokenizer.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/constructs.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/preprocess.js","../../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/postprocess.js","../../../../node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/index.js","../../../../node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js","../../../../node_modules/.pnpm/unified@10.1.2/node_modules/unified/index.js","../../../../node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js","../../../../node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js","../../../../node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js","../../../../node_modules/.pnpm/trough@2.1.0/node_modules/trough/index.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/index.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js","../../../../node_modules/.pnpm/vfile-message@3.1.4/node_modules/vfile-message/index.js","../../../../node_modules/.pnpm/vfile-message@3.1.4/node_modules/vfile-message/lib/index.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minpath.browser.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minproc.browser.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.browser.js","../../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.shared.js","../../../react/src/convert/parse/parse-content.ts","../../../react/src/convert/utils.ts","../../../react/src/convert/parse/parse-blockquote.ts","../../../react/src/convert/parse/parse-code-block.ts","../../../react/src/convert/parse/parse-footnote-definition.ts","../../../react/src/convert/parse/parse-heading.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-phrasing-content.ts","../../../react/src/convert/parse/parse-phrasing-content/normalize-segments.ts","../../../react/src/convert/parse/parse-phrasing-content/normalize-segment.ts","../../../react/src/convert/serialize/serialize-line/utils/index.ts","../../../react/src/convert/serialize/serialize-line/utils/is-utils.ts","../../../react/src/convert/serialize/serialize-line/utils/mark-utils/index.ts","../../../react/src/convert/serialize/serialize-line/utils/mark-utils/mark-convert-utils.ts","../../../react/src/convert/serialize/serialize-line/utils/mark-utils/mark-get-utils.ts","../../../react/src/convert/serialize/serialize-line/utils/mark-utils/mark-order-utils.ts","../../../react/src/convert/serialize/serialize-line/utils/text-utils.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/index.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/image-parsers.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/parse-generic-image.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/parse-portive-image.ts","../../../react/src/convert/parseUrl.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/parse-utils.ts","../../../react/src/convert/parse/parse-phrasing-content/parse-inline-image/parse-uncommon-mark-image.ts","../../../react/src/convert/parse/parse-html.ts","../../../react/src/convert/parse/parse-list/index.ts","../../../react/src/convert/parse/parse-list/parse-list.ts","../../../react/src/convert/parse/parse-list/parse-list-item.ts","../../../react/src/convert/parse/parse-list/parse-list-item-child.ts","../../../react/src/convert/parse/parse-paragraph.ts","../../../react/src/convert/parse/parse-table.ts","../../../react/src/convert/parse/parse-thematic-break.ts","../../../react/src/convert/parse/transform-inline-links.ts","../../../../node_modules/.pnpm/mdast-util-definitions@5.1.1/node_modules/mdast-util-definitions/index.js","../../../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/index.js","../../../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js","../../../react/src/convert/serialize/index.ts","../../../react/src/convert/serialize/normalize/normalizeElementListDepths.ts","../../../react/src/convert/serialize/serialize-elements.ts","../../../react/src/convert/serialize/serialize-element.ts","../../../react/src/convert/serialize/serialize-code-block/index.ts","../../../react/src/convert/serialize/serialize-code-block/serialize-code-line.ts","../../../react/src/convert/serialize/serialize-image-block/index.ts","../../../react/src/convert/serialize/serialize-image-shared/index.ts","../../../react/src/convert/serialize/serialize-image-shared/serialize-generic-image-url.ts","../../../react/src/convert/serialize/serialize-image-shared/serialize-portive-image-url.ts","../../../react/src/convert/serialize/serialize-image-shared/serialize-uncommonmark-image-url.ts","../../../react/src/convert/serialize/serialize-line/index.ts","../../../react/src/convert/serialize/serialize-line/serialize-line.ts","../../../react/src/convert/serialize/serialize-line/diff-marks/index.ts","../../../react/src/convert/serialize/serialize-line/diff-marks/find-marks-to-add.ts","../../../react/src/convert/serialize/serialize-line/diff-marks/find-marks-to-remove.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/index.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalize-nodes.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/run-normalizers-on-node.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/index.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/merge-adjacent-spaces.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/move-spaces-out-of-anchors.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/must-have-one-text-child.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/slice-spaces-at-node-boundaries.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/trim-spaces-at-end-of-line.ts","../../../react/src/convert/serialize/serialize-line/normalize-line/normalizers/trim-spaces-at-start-of-line.ts","../../../react/src/convert/serialize/serialize-line/segment/serialize-segment.ts","../../../react/src/convert/serialize/serialize-line/segment/serialize-code-text.ts","../../../react/src/convert/serialize/serialize-line/segment/serialize-anchor.ts","../../../react/src/convert/serialize/serialize-line/segment/serialize-non-code-text.ts","../../../react/src/convert/serialize/serialize-table/index.ts","../../../react/src/entry/SinkEditable.tsx","../../../react/src/sink/index.ts","../../../react/src/sink/create-plugin/index.ts","../../../react/src/sink/create-sink/index.tsx","../../../react/src/sink/editable/index.tsx","../../../react/src/sink/editable/create-decorate.ts","../../../react/src/sink/editable/utils.ts","../../../react/src/sink/editable/create-editable.tsx","../../../react/src/sink/editable/create-handler.ts","../../../react/src/sink/editable/create-render-element.ts","../../../react/src/sink/editable/create-render-leaf.ts","../../../react/src/sink/editable/create-render-placeholder.tsx","../../../react/src/sink/editable/styles.tsx","../../../react/src/sink/editor/index.ts","../../../react/src/sink/editor/create-boolean-action.ts","../../../react/src/sink/editor/create-void-action.ts","../../../react/src/sink/is-debug.ts","../../../react/src/sink/types/index.ts","../../../react/src/sink/types/constrained/constrained-render-element-props.ts","../../../react/src/sink/types/constrained/constrained-render-leaf-props.ts","../../../react/src/sink/types/plugin/index.ts","../../../react/src/sink/types/plugin/ExtractCustomTypes.ts","../../../react/src/sink/types/plugin/merge-plugin-custom-types.ts","../../../react/src/sink/types/plugin/plugin.ts","../../../react/src/sink/types/plugin/plugin-custom-types.ts","../../../react/src/sink/types/plugin/plugin-custom-types-for-create.ts","../../../react/src/sink/types/plugin/plugin-function.ts","../../../react/src/sink/types/plugin/plugin-policy.ts","../../../react/src/sink/types/plugin/schema-types.ts","../../../react/src/sink/types/plugin/VoidActionReturn.ts","../../../react/src/sink/types/sink/sink-editor.ts","../../../react/src/sink/utils/index.ts","../../../react/src/sink/utils/core-utils/index.ts","../../../react/src/sink/utils/core-utils/better-at.ts","../../../react/src/sink/utils/core-utils/curry.ts","../../../react/src/sink/utils/core-utils/is-mac.ts","../../../react/src/sink/utils/core-utils/stop-event.ts","../../../react/src/sink/utils/find-utils/find-element-up.ts","../../../react/src/sink/utils/standardize-utils/standardize-node-matcher.ts","../../../react/src/sink/utils/icon-utils/tabler-icon.tsx","../../../react/src/sink/utils/is-utils/index.ts","../../../react/src/sink/utils/is-utils/is-collapsed.ts","../../../react/src/sink/utils/is-utils/is-element-type.ts","../../../react/src/sink/utils/is-utils/is-end-of-element.ts","../../../react/src/sink/utils/is-utils/is-in-empty-element.ts","../../../react/src/sink/utils/is-utils/is-start-of-element.ts","../../../react/src/sink/utils/key-utils/index.ts","../../../react/src/sink/utils/key-utils/create-autocomplete-space-handler.tsx","../../../react/src/sink/utils/key-utils/create-hotkey-handler.ts","../../../react/src/sink/utils/key-utils/is-better-hotkey.ts","../../../react/src/sink/utils/normalize-utils/force-normalize-path.ts","../../../react/src/sink/utils/normalize-utils/normalize-siblings.ts","../../../react/src/sink/utils/select-utils/index.ts","../../../react/src/sink/utils/standardize-utils/index.ts","../../../react/src/sink/utils/standardize-utils/target-element.ts","../../../react/src/sink/utils/transform-utils/index.ts","../../../react/src/sink/utils/transform-utils/insert-root-element.ts","../../../react/src/sink/utils/transform-utils/rewrap-element.ts","../../../react/src/sink/utils/transform-utils/set-nodes-dynamic.ts","../../../react/src/entry/plugins.ts","../../../react/src/anchor-plugin/index.tsx","../../../react/src/anchor-plugin/editable/on-paste.tsx","../../../react/src/anchor-plugin/methods/index.ts","../../../react/src/anchor-plugin/methods/editLink.ts","../../../react/src/anchor-plugin/methods/insertLink.ts","../../../react/src/anchor-plugin/methods/removeLink.ts","../../../react/src/anchor-plugin/normalize-node/index.ts","../../../react/src/anchor-plugin/render-element/anchor.tsx","../../../react/src/upload-plugin/store/index.ts","../../../react/src/upload-plugin/store/create-upload-store.ts","../../../react/src/upload-plugin/store/use-upload.ts","../../../react/src/use-layer/index.tsx","../../../react/src/use-layer/layers.tsx","../../../react/src/use-layer/portal.tsx","../../../react/src/use-layer/use-layer.tsx","../../../react/src/anchor-plugin/styles.tsx","../../../react/src/anchor-plugin/render-element/AnchorDialog.tsx","../../../react/src/shared-overlays/index.ts","../../../react/src/shared-overlays/components/index.ts","../../../react/src/shared-overlays/components/CloseMask/index.tsx","../../../react/src/shared-overlays/styles/$CloseMask.tsx","../../../react/src/shared-overlays/components/Menu/index.tsx","../../../react/src/shared-overlays/components/Menu/formatHotkey.ts","../../../react/src/shared-overlays/components/Menu/Menu.tsx","../../../react/src/use-reposition/index.tsx","../../../react/src/use-reposition/hooks/use-absolute-reposition.tsx","../../../react/src/use-reposition/get-methods/get-absolute-rect.ts","../../../react/src/use-reposition/get-methods/get-fixed-rect.ts","../../../react/src/use-reposition/get-methods/get-absolute-viewport.ts","../../../react/src/use-reposition/get-methods/get-fixed-viewport.ts","../../../react/src/use-reposition/utils.ts","../../../react/src/use-reposition/hooks/use-reposition.tsx","../../../react/src/use-reposition/hooks/use-throttled-refresh.ts","../../../react/src/use-reposition/hooks/use-fixed-reposition.tsx","../../../react/src/use-reposition/position-methods/index.ts","../../../react/src/toolbar-plugin/styles/index.ts","../../../react/src/toolbar-plugin/styles/anchor-dialog-styles.ts","../../../react/src/shared-overlays/styles/$Panel.ts","../../../react/src/toolbar-plugin/styles/layout-styles.ts","../../../react/src/shared-layout/index.ts","../../../react/src/toolbar-plugin/styles/menu-styles.ts","../../../react/src/toolbar-plugin/styles/toolbar-styles.ts","../../../react/src/shared-overlays/components/Menu/MenuItem.tsx","../../../react/src/shared-overlays/styles/index.ts","../../../react/src/shared-overlays/types.ts","../../../react/src/use-tooltip/index.tsx","../../../react/src/use-tooltip/tooltip.tsx","../../../react/src/use-tooltip/triangle.tsx","../../../react/src/anchor-plugin/render-element/AnchorEditDialog.tsx","../../../react/src/shared-styles/index.ts","../../../react/src/anchor-plugin/render-element/icons.tsx","../../../react/src/anchor-plugin/render-element/ProgressBar.tsx","../../../react/src/atomic-delete-plugin/index.ts","../../../react/src/atomic-delete-plugin/is-safe-delete.ts","../../../react/src/block-quote-plugin/index.tsx","../../../react/src/block-quote-plugin/styles.tsx","../../../react/src/code-block-plugin/index.tsx","../../../react/src/code-block-plugin/decorate.tsx","../../../react/src/code-block-plugin/methods/index.ts","../../../react/src/code-block-plugin/methods/createCodeBlock.ts","../../../react/src/code-block-plugin/methods/setCodeBlockLanguage.ts","../../../react/src/code-block-plugin/prism-theme.ts","../../../react/src/code-block-plugin/types.tsx","../../../react/src/code-block-plugin/normalizeNode.tsx","../../../react/src/code-block-plugin/render-element/index.tsx","../../../react/src/code-block-plugin/render-element/CodeBlock.tsx","../../../react/src/code-block-plugin/icons/ChevronDownIcon.tsx","../../../react/src/code-block-plugin/styles.ts","../../../react/src/code-block-plugin/render-element/CodeBlockLine.tsx","../../../react/src/collapsible-paragraph-plugin/index.tsx","../../../react/src/collapsible-paragraph-plugin/normalize-node/index.ts","../../../react/src/collapsible-paragraph-plugin/normalize-node/normalize-sibling-paragraphs.ts","../../../react/src/collapsible-paragraph-plugin/normalize-node/normalize-sibling-walls.ts","../../../react/src/collapsible-paragraph-plugin/render-element/paragraph.tsx","../../../react/src/collapsible-paragraph-plugin/render-element/styles.ts","../../../react/src/collapsible-paragraph-plugin/render-element/utils.ts","../../../react/src/convert-element-plugin/index.tsx","../../../react/src/convert-element-plugin/methods/index.ts","../../../react/src/convert-element-plugin/methods/add-convert-element-type.ts","../../../react/src/convert-element-plugin/methods/convert-elements.ts","../../../react/src/convert-element-plugin/methods/is-convert-element.ts","../../../react/src/heading-plugin/index.tsx","../../../react/src/heading-plugin/types.ts","../../../react/src/heading-plugin/insert-break.ts","../../../react/src/heading-plugin/methods/index.ts","../../../react/src/heading-plugin/styles.ts","../../../react/src/horizontal-rule-plugin/index.tsx","../../../react/src/horizontal-rule-plugin/horizontal-rule.tsx","../../../react/src/horizontal-rule-plugin/styles.tsx","../../../react/src/horizontal-rule-plugin/methods/index.ts","../../../react/src/horizontal-rule-plugin/types.ts","../../../react/src/image-plugin/index.tsx","../../../react/src/image-plugin/methods/index.ts","../../../react/src/image-plugin/normalize-node/index.ts","../../../react/src/image-plugin/render-element/index.tsx","../../../react/src/image-plugin/render-element/image-block.tsx","../../../react/src/image-plugin/styles/image-block-styles.tsx","../../../react/src/image-plugin/render-element/image-with-controls/index.tsx","../../../react/src/image-plugin/styles/image-with-controls-styles/image-with-controls-styles.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-resize-controls/image-resize-control.tsx","../../../react/src/use-reposition/hooks/index.ts","../../../react/src/use-reposition/hooks/use-resize-browser.tsx","../../../react/src/image-plugin/styles/image-with-controls-styles/image-resize-handle-styles.tsx","../../../react/src/image-plugin/utils/index.ts","../../../react/src/image-plugin/utils/min-max.ts","../../../react/src/image-plugin/utils/resize-utils.ts","../../../react/src/image-plugin/render-element/image-with-controls/image-size-status/image-size-status.tsx","../../../react/src/image-plugin/styles/image-with-controls-styles/image-size-status-styles.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-toolbar.tsx","../../../react/src/image-plugin/styles/image-with-controls-styles/image-toolbar-styles.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-preset-buttons/image-preset-button-group.tsx","../../../react/src/image-plugin/styles/image-with-controls-styles/image-buttons-styles.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-preset-buttons/image-preset-button.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-type-buttons/image-type-button-group.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-type-buttons/block-image-type-button.tsx","../../../react/src/image-plugin/render-element/icons.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-type-buttons/convert-to-inline-image.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-type-buttons/inline-image-type-button.tsx","../../../react/src/image-plugin/render-element/image-with-controls/image-toolbar/image-type-buttons/convert-to-block-image.tsx","../../../react/src/image-plugin/render-element/image-inline.tsx","../../../react/src/image-plugin/styles/image-inline-styles.tsx","../../../react/src/inline-code-plugin/index.tsx","../../../react/src/inline-code-plugin/styles.ts","../../../react/src/inline-code-plugin/types.ts","../../../react/src/list-plugin/index.tsx","../../../react/src/list-plugin/methods/index.ts","../../../react/src/list-plugin/methods/convert-list-item.ts","../../../react/src/list-plugin/methods/indent.ts","../../../react/src/list-plugin/methods/insert-break.ts","../../../react/src/list-plugin/methods/outdent.ts","../../../react/src/list-plugin/methods/toggleTaskListItem.ts","../../../react/src/list-plugin/normalize-node/index.ts","../../../react/src/list-plugin/normalize-node/normalize-ordered-first-at-depth.ts","../../../react/src/list-plugin/render-element/index.tsx","../../../react/src/list-plugin/render-element/ordered-list-item.tsx","../../../react/src/list-plugin/render-element/styles.ts","../../../react/src/list-plugin/render-element/task-list-item.tsx","../../../react/src/list-plugin/render-element/list-icons.tsx","../../../react/src/list-plugin/render-element/unordered-list-item.tsx","../../../react/src/list-plugin/types.ts","../../../react/src/marks-plugin/index.tsx","../../../react/src/marks-plugin/editor/insert-text/index.ts","../../../react/src/marks-plugin/editor/insert-text/autocomplete-mark.ts","../../../react/src/marks-plugin/editor/insert-text/get-range-backwards.ts","../../../react/src/marks-plugin/editor/insert-text/get-text-before-point-in-block.ts","../../../react/src/marks-plugin/methods/index.ts","../../../react/src/marks-plugin/methods/removeMarks.ts","../../../react/src/marks-plugin/methods/toggle-mark.ts","../../../react/src/marks-plugin/styles.tsx","../../../react/src/normalize-after-delete-plugin/index.tsx","../../../react/src/table-plugin/index.tsx","../../../react/src/table-plugin/delete-fragment/index.ts","../../../react/src/table-plugin/delete-fragment/get-reversed-delete-safe-ranges.ts","../../../react/src/table-plugin/methods/index.ts","../../../react/src/table-plugin/methods/get-table-info.ts","../../../react/src/table-plugin/methods/insert-column.ts","../../../react/src/table-plugin/methods/utils.ts","../../../react/src/table-plugin/methods/insert-row.ts","../../../react/src/table-plugin/methods/insert-table.ts","../../../react/src/table-plugin/methods/navigation/index.ts","../../../react/src/table-plugin/methods/navigation/select-element.ts","../../../react/src/table-plugin/methods/navigation/utils.ts","../../../react/src/table-plugin/methods/remove-column.ts","../../../react/src/table-plugin/methods/remove-table.ts","../../../react/src/table-plugin/methods/remove-row.ts","../../../react/src/table-plugin/methods/setTableColumnAlign.ts","../../../react/src/table-plugin/methods/tab.ts","../../../react/src/table-plugin/normalize/normalize-table.ts","../../../react/src/table-plugin/normalize/normalize-table-cell.ts","../../../react/src/table-plugin/render-element/index.tsx","../../../react/src/table-plugin/render-element/table.tsx","../../../react/src/table-plugin/render-element/styles/index.ts","../../../react/src/table-plugin/render-element/styles/table-menu-styles.ts","../../../react/src/table-plugin/render-element/table-context.tsx","../../../react/src/table-plugin/render-element/table-cell/index.tsx","../../../react/src/table-plugin/render-element/table-cell/column-menu/index.tsx","../../../react/src/table-plugin/icons.tsx","../../../react/src/table-plugin/render-element/table-cell/row-menu/index.tsx","../../../react/src/table-plugin/render-element/table-cell/table-menu/index.tsx","../../../react/src/table-plugin/render-element/table-cell/table-menu/$table-menu.tsx","../../../react/src/table-plugin/render-element/table-content.tsx","../../../react/src/table-plugin/render-element/table-row.tsx","../../../react/src/table-plugin/types.ts","../../../react/src/theme-plugin/index.tsx","../../../react/src/theme-plugin/global-styles.ts","../../../react/src/toolbar-plugin/index.tsx","../../../react/src/toolbar-plugin/render-editable/index.tsx","../../../react/src/toolbar-plugin/components/index.tsx","../../../react/src/toolbar-plugin/components/dialog/table-dialog.tsx","../../../react/src/toolbar-plugin/styles/table-styles.ts","../../../react/src/toolbar-plugin/components/toolbar/toolbar.tsx","../../../react/src/toolbar-plugin/items/index.tsx","../../../react/src/toolbar-plugin/items/block-items.tsx","../../../react/src/toolbar-plugin/icons.tsx","../../../react/src/toolbar-plugin/items/dialogItems.tsx","../../../react/src/toolbar-plugin/components/dialog/emoji-dialog.tsx","../../../react/src/toolbar-plugin/components/dialog/file-dialog.tsx","../../../react/src/toolbar-plugin/styles/dialog-shared-styles.ts","../../../react/src/toolbar-plugin/styles/file-dialog-styles.ts","../../../react/src/toolbar-plugin/items/dropdownItems.tsx","../../../react/src/toolbar-plugin/items/codeBlockItems.tsx","../../../react/src/toolbar-plugin/items/list-items.tsx","../../../react/src/toolbar-plugin/items/quote-items.tsx","../../../react/src/toolbar-plugin/items/linkItem.tsx","../../../react/src/toolbar-plugin/components/dialog/anchor-dialog.tsx","../../../react/src/toolbar-plugin/items/mark-items.tsx","../../../react/src/toolbar-plugin/components/toolbar/toolbar-button.tsx","../../../react/src/trailing-block-plugin/index.tsx","../../../react/src/upload-plugin/index.tsx","../../../react/src/upload-plugin/methods/index.ts","../../../react/src/upload-plugin/methods/setElementTimeTraveling.ts","../../../react/src/upload-plugin/methods/upload.ts","../../../react/src/attachment-plugin/index.tsx","../../../react/src/paste-markdown-plugin/index.tsx","../../../react/src/paste-markdown-plugin/methods/index.ts","../../../react/src/placeholder-plugin/index.tsx","../../../react/src/entry/useEditor.tsx"],"sourcesContent":["/**\n * This is required by tsup\n */\nimport React from \"react\"\nexport { React }\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","export * from \"./entry/index\"\n","import {\n  createRef,\n  RefObject,\n  useCallback,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from \"react\"\nimport { createRoot } from \"react-dom/client\"\n\nimport { Editable, useEditor } from \"../../../react/src/entry\"\n\n/**\n * The options passed into the standalone version of Wysimark.\n */\ntype StandaloneOptions = Parameters<typeof useEditor>[0] & {\n  onChange?: (markdown: string) => void\n  placeholder?: string\n  initialMarkdown?: string\n}\n\ntype StandaloneMethods = {\n  getMarkdown: () => string\n  setMarkdown: (markdown: string) => void\n}\n\n/**\n * The object returned by `createWysimark`\n */\nexport type Wysimark = {\n  unmount: () => void\n  getMarkdown: () => string\n  setMarkdown: (markdown: string) => void\n}\n\nfunction StandaloneEditor({\n  standaloneOptions: { onChange, placeholder, ...options },\n  standaloneMethodsRef,\n}: {\n  standaloneOptions: StandaloneOptions\n  standaloneMethodsRef: RefObject<StandaloneMethods>\n}) {\n  const [markdown, setMarkdown] = useState(options.initialMarkdown || \"\")\n  const markdownRef = useRef(markdown)\n  const editor = useEditor(options)\n\n  markdownRef.current = markdown\n\n  useImperativeHandle(\n    standaloneMethodsRef,\n    () => {\n      return {\n        getMarkdown() {\n          return markdownRef.current\n        },\n        setMarkdown(markdown: string) {\n          markdownRef.current = markdown\n          setMarkdown(markdown)\n        },\n      }\n    },\n    [markdownRef, setMarkdown]\n  )\n\n  const onChangeEditable = useCallback(\n    (markdown: string) => {\n      /**\n       * Setting the ref is important in the case where there is an attempt to\n       * call the `getMarkdown` method from `onChange`. Otherwise the `ref`\n       * doesn't get updated until the next render which happens sometime after\n       * the `onChange` callback is called.\n       */\n      markdownRef.current = markdown\n      setMarkdown(markdown)\n      onChange?.(markdown)\n    },\n    [editor]\n  )\n\n  return (\n    <Editable\n      editor={editor}\n      value={markdown}\n      onChange={onChangeEditable}\n      placeholder={placeholder}\n    />\n  )\n}\n\n/**\n * The primary entry point for the standalone version of Wysimark.\n */\nexport function createWysimark(\n  containerElement: HTMLElement,\n  options: StandaloneOptions\n): Wysimark {\n  const standaloneMethodsRef = createRef<StandaloneMethods>()\n\n  const root = createRoot(containerElement)\n\n  root.render(\n    <StandaloneEditor\n      standaloneMethodsRef={standaloneMethodsRef}\n      standaloneOptions={options}\n    />\n  )\n\n  return {\n    unmount() {\n      try {\n        root.unmount()\n      } catch (e) {\n        /* ignore */\n      }\n    },\n    getMarkdown() {\n      return standaloneMethodsRef.current?.getMarkdown() || \"\"\n      // const markdown = editorRef.current?.getMarkdown()\n      // return typeof markdown === \"string\"\n      //   ? markdown\n      //   : options.initialMarkdown || \"\"\n    },\n    setMarkdown(markdown: string) {\n      standaloneMethodsRef.current?.setMarkdown(markdown)\n    },\n  }\n}\n","import throttle from \"lodash.throttle\"\nimport { useCallback, useRef } from \"react\"\nimport { Descendant, Editor, Element, Transforms } from \"slate\"\nimport { ReactEditor, RenderLeafProps, Slate } from \"slate-react\"\n\nimport { parse, serialize } from \"../convert\"\nimport { SinkEditable } from \"./SinkEditable\"\n\nexport type { Element, Text } from \"./plugins\"\nexport { useEditor } from \"./useEditor\"\n\nfunction renderLeaf({ children, attributes }: RenderLeafProps) {\n  return <span {...attributes}>{children}</span>\n}\n\nexport type EditableProps = {\n  // editor: BaseEditor & ReactEditor & HistoryEditor & SinkEditor & WysimarkEditor\n  editor: Editor\n  value: string\n  onChange: (markdown: string) => void\n  throttleInMs?: number\n  placeholder?: string\n  className?: string\n  style?: React.CSSProperties\n} // & Omit<React.TextareaHTMLAttributes<HTMLDivElement>, \"onChange\">\n\nexport function Editable({\n  editor,\n  value,\n  onChange,\n  throttleInMs = 1000,\n  placeholder,\n  className,\n  style,\n}: EditableProps) {\n  const ignoreNextChangeRef = useRef(false)\n\n  /**\n   * This is a temporary ref that is only used once to store the initial value\n   * derived from the initial Markdown value.\n   */\n  const initialValueRef = useRef<Descendant[]>()\n\n  /**\n   * Track the previous value of the editor. This is used to determine if the\n   * change from the editor resulted in a change in the contents of the editor\n   * as opposed to just a cursor movement for example.\n   */\n  const prevValueRef = useRef<Descendant[]>()\n\n  /**\n   * Throttled version of `onChange` for the `Slate` component. This method gets\n   * called on every change to the editor except for:\n   *\n   * - The first call to `onChange` when the component is mounted which would\n   *   be in response to the initial normalization pass that is always run to\n   *   make sure the content is in a good state.\n   * - When the incoming value (markdown) to the editor is changed and we force\n   *   the editor to update its value after doing a `parse` on the markdown.\n   *   We don't want the `onChange` callback to be called for this because if\n   *   the change came from an edit to a textarea, for example, it would\n   *   serialize the editor and the value of the textarea would be updated with\n   *   a slightly different value. This would cause the selection to jump. This\n   *   is especially bad if the cursor is at the end of a line and the user\n   *   presses the spacebar. This is because Markdown does not support spaces\n   *   at the end of a line and the space would be removed and the cursor would\n   *   have nowhere to be.\n   */\n  const onThrottledSlateChange = useCallback(\n    throttle(\n      () => {\n        const markdown = serialize(editor.children as Element[])\n        editor.wysimark.prevValue = {\n          markdown,\n          children: editor.children,\n        }\n        onChange(markdown)\n      },\n      throttleInMs,\n      { leading: false, trailing: true }\n    ),\n    [editor, onChange, throttleInMs]\n  )\n\n  /**\n   * This handles the initial `onChange` event from the `Slate` component and\n   * makes sure to ignore any change events that don't change the content of\n   * the editor. For example, if the user just moves the cursor around, we\n   * don't want to call the `onChange` callback.\n   *\n   * If it's neither, then it passes the call to the throttled `onChange` method.\n   */\n  const onSlateChange = useCallback(() => {\n    if (prevValueRef.current === editor.children) {\n      return\n    }\n    prevValueRef.current = editor.children\n    onThrottledSlateChange()\n  }, [onThrottledSlateChange])\n\n  /**\n   * Handle the initial mounting of the component. This is where we set the\n   * initial value of the editor. We also set the `prevValue` on the editor\n   * which is used to determine if a change in the editor resulted in a change\n   * in the contents of the editor vs just changing the cursor position for\n   * example.\n   *\n   * We add a check for `initialValueRef.current` not being null because the\n   * ref can be lost on a hot reload. This then reinitializes the editor with\n   * the initial value.\n   *\n   * NOTE: This value hasn't been normalized yet.\n   */\n  if (editor.wysimark.prevValue == null || initialValueRef.current == null) {\n    ignoreNextChangeRef.current = true\n    const children = parse(value)\n    prevValueRef.current = initialValueRef.current = children\n    editor.wysimark.prevValue = {\n      markdown: value,\n      children,\n    }\n  } else {\n    /**\n     * Handle the case where the `value` differs from the last `markdown` value\n     * set in the Wysimark editor. If it differs, that means the change came\n     * from somewhere else and we need to set the editor value.\n     *\n     * Apart from setting `editor.children` we also need to set the selection\n     * to the start of the document. This is because the selection may be set\n     * to an invalid value based on the new document value.\n     */\n    if (value !== editor.wysimark.prevValue.markdown) {\n      ignoreNextChangeRef.current = true\n      const documentValue = parse(value)\n      editor.children = documentValue\n      editor.selection = null\n      Transforms.select(editor, Editor.start(editor, [0]))\n    }\n  }\n\n  const onSinkeEditableMouseDown = useCallback(() => {\n    /**\n     * For some reason, Firefox doesn't focus the editor when clicking on\n     * it until the second try. This is a workaround for that.\n     * Handled narrowly to avoid potentially breaking other browsers.\n     */\n    if (navigator.userAgent.toLowerCase().includes(\"firefox\")) {\n      ReactEditor.focus(editor)\n    }\n  }, [editor])\n\n  /**\n   * When the user exits the editor, we want to call the `onChange` callback\n   * immediately.\n   */\n  const onBlur = useCallback(() => {\n    onThrottledSlateChange.flush()\n  }, [onThrottledSlateChange])\n\n  /**\n   * NOTE:\n   *\n   * The following code is used to see if we are getting unnecessary re-renders.\n   *\n   * Comment it out when we are happy.\n   *\n   * - We SHOULD see `Editable mount` on the initial render.\n   * - We SHOULD NOT see `Editable mount` or unmount at each markdown update.\n   */\n  // useEffect(() => {\n  //   console.log(\"Editable mount\")\n  //   return () => {\n  //     console.log(\"Editable unmount\")\n  //   }\n  // }, [\n  //   Slate,\n  //   SinkEditable,\n  //   initialValueRef.current,\n  //   editor,\n  //   onSlateChange,\n  //   renderLeaf,\n  //   onSinkeEditableMouseDown,\n  //   onBlur,\n  //   placeholder,\n  //   className,\n  //   style,\n  // ])\n\n  return (\n    <Slate\n      editor={editor}\n      /* NOTE: This is the initial value even though it is named value */\n      value={initialValueRef.current}\n      onChange={onSlateChange}\n    >\n      <SinkEditable\n        renderLeaf={renderLeaf}\n        onMouseDown={onSinkeEditableMouseDown}\n        onBlur={onBlur}\n        placeholder={placeholder}\n        className={className}\n        style={style}\n      />\n    </Slate>\n  )\n}\n","// import remarkParse from \"remark-parse\"\n// import { unified } from \"unified\"\n\nexport { parse } from \"./parse\"\nexport { serialize } from \"./serialize\"\n\n/**\n * Takes a Markdown string as input and returns a remarkParse AST\n */\n// export function parse(markdown: string) {\n//   const value = unified().use(remarkParse).parse(markdown)\n//   return value\n// }\n","import type { Root, TopLevelContent } from \"mdast\"\nimport remarkGfm from \"remark-gfm\"\nimport remarkParse from \"remark-parse\"\nimport { unified } from \"unified\"\n\nimport { Element } from \"../types\"\nimport { parseContents } from \"./parse-content\"\nimport { transformInlineLinks } from \"./transform-inline-links\"\n\nconst parser = unified().use(remarkParse).use(remarkGfm)\n\nexport function parseToAst(markdown: string) {\n  const ast = parser.parse(markdown) as Root\n  /**\n   * Takes linkReference and imageReference and turns them into link and image.\n   */\n  transformInlineLinks(ast)\n  return ast\n}\n\n/**\n * Takes a Markdown string as input and returns a remarkParse AST\n */\nexport function parse(markdown: string): Element[] {\n  const ast = parseToAst(markdown)\n  /**\n   * If there is no content, remark returns a root ast with no children (i.e.\n   * no paragraphs) but for Slate, we need it to return an empty paragraph.\n   *\n   * So when this happens, we just generate an empty paragraph and return that\n   * s he result.\n   */\n  if (ast.children.length === 0) {\n    return [{ type: \"paragraph\", children: [{ text: \"\" }] }] as Element[]\n  }\n\n  return parseContents(ast.children as TopLevelContent[])\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options\n */\n\nimport {gfm} from 'micromark-extension-gfm'\nimport {gfmFromMarkdown, gfmToMarkdown} from 'mdast-util-gfm'\n\n/**\n * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).\n *\n * @type {import('unified').Plugin<[Options?]|void[], Root>}\n */\nexport default function remarkGfm(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', gfm(options))\n  add('fromMarkdownExtensions', gfmFromMarkdown())\n  add('toMarkdownExtensions', gfmToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\nimport {\n  combineExtensions,\n  combineHtmlExtensions\n} from 'micromark-util-combine-extensions'\nimport {\n  gfmAutolinkLiteral,\n  gfmAutolinkLiteralHtml\n} from 'micromark-extension-gfm-autolink-literal'\nimport {gfmFootnote, gfmFootnoteHtml} from 'micromark-extension-gfm-footnote'\nimport {\n  gfmStrikethrough,\n  gfmStrikethroughHtml\n} from 'micromark-extension-gfm-strikethrough'\nimport {gfmTable, gfmTableHtml} from 'micromark-extension-gfm-table'\nimport {gfmTagfilterHtml} from 'micromark-extension-gfm-tagfilter'\nimport {\n  gfmTaskListItem,\n  gfmTaskListItemHtml\n} from 'micromark-extension-gfm-task-list-item'\n\n/**\n * Create an extension for `micromark` to enable GFM syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n *\n *   Passed to `micromark-extens-gfm-strikethrough`.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   syntax.\n */\nexport function gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral,\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable,\n    gfmTaskListItem\n  ])\n}\n\n/**\n * Create an extension for `micromark` to support GFM when serializing to HTML.\n *\n * @param {HtmlOptions | null | undefined} [options]\n *   Configuration.\n *\n *   Passed to `micromark-extens-gfm-footnote`.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM when serializing to HTML.\n */\nexport function gfmHtml(options) {\n  return combineHtmlExtensions([\n    gfmAutolinkLiteralHtml,\n    gfmFootnoteHtml(options),\n    gfmStrikethroughHtml,\n    gfmTableHtml,\n    gfmTagfilterHtml,\n    gfmTaskListItemHtml\n  ])\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Handles} Handles\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension\n */\n\nimport {splice} from 'micromark-util-chunked'\n\nconst hasOwnProperty = {}.hasOwnProperty\n\n/**\n * Combine multiple syntax extensions into one.\n *\n * @param {Array<Extension>} extensions\n *   List of syntax extensions.\n * @returns {NormalizedExtension}\n *   A single combined extension.\n */\nexport function combineExtensions(extensions) {\n  /** @type {NormalizedExtension} */\n  const all = {}\n  let index = -1\n\n  while (++index < extensions.length) {\n    syntaxExtension(all, extensions[index])\n  }\n\n  return all\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {NormalizedExtension} all\n *   Extension to merge into.\n * @param {Extension} extension\n *   Extension to merge.\n * @returns {void}\n */\nfunction syntaxExtension(all, extension) {\n  /** @type {keyof Extension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    /** @type {Record<string, unknown>} */\n    const left = maybe || (all[hook] = {})\n    /** @type {Record<string, unknown> | undefined} */\n    const right = extension[hook]\n    /** @type {string} */\n    let code\n\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = []\n        const value = right[code]\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        )\n      }\n    }\n  }\n}\n\n/**\n * Merge `list` into `existing` (both lists of constructs).\n * Mutates `existing`.\n *\n * @param {Array<unknown>} existing\n * @param {Array<unknown>} list\n * @returns {void}\n */\nfunction constructs(existing, list) {\n  let index = -1\n  /** @type {Array<unknown>} */\n  const before = []\n\n  while (++index < list.length) {\n    // @ts-expect-error Looks like an object.\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  splice(existing, 0, 0, before)\n}\n\n/**\n * Combine multiple HTML extensions into one.\n *\n * @param {Array<HtmlExtension>} htmlExtensions\n *   List of HTML extensions.\n * @returns {HtmlExtension}\n *   A single combined HTML extension.\n */\nexport function combineHtmlExtensions(htmlExtensions) {\n  /** @type {HtmlExtension} */\n  const handlers = {}\n  let index = -1\n\n  while (++index < htmlExtensions.length) {\n    htmlExtension(handlers, htmlExtensions[index])\n  }\n\n  return handlers\n}\n\n/**\n * Merge `extension` into `all`.\n *\n * @param {HtmlExtension} all\n *   Extension to merge into.\n * @param {HtmlExtension} extension\n *   Extension to merge.\n * @returns {void}\n */\nfunction htmlExtension(all, extension) {\n  /** @type {keyof HtmlExtension} */\n  let hook\n\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined\n    const left = maybe || (all[hook] = {})\n    const right = extension[hook]\n    /** @type {keyof Handles} */\n    let type\n\n    if (right) {\n      for (type in right) {\n        // @ts-expect-error assume document vs regular handler are managed correctly.\n        left[type] = right[type]\n      }\n    }\n  }\n}\n","/**\n * Like `Array#splice`, but smarter for giant arrays.\n *\n * `Array#splice` takes all items to be inserted as individual argument which\n * causes a stack overflow in V8 when trying to insert 100k items for instance.\n *\n * Otherwise, this does not return the removed items, and takes `items` as an\n * array instead of rest parameters.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {number} start\n *   Index to remove/insert at (can be negative).\n * @param {number} remove\n *   Number of items to remove.\n * @param {Array<T>} items\n *   Items to inject into `list`.\n * @returns {void}\n *   Nothing.\n */\nexport function splice(list, start, remove, items) {\n  const end = list.length\n  let chunkStart = 0\n  /** @type {Array<unknown>} */\n  let parameters\n\n  // Make start between zero and `end` (included).\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n  remove = remove > 0 ? remove : 0\n\n  // No need to chunk the items if there’s only a couple (10k) items.\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    // @ts-expect-error Hush, it’s fine.\n    list.splice(...parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) list.splice(start, remove)\n\n    // Insert the items in chunks to not cause stack overflows.\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      // @ts-expect-error Hush, it’s fine.\n      list.splice(...parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\n/**\n * Append `items` (an array) at the end of `list` (another array).\n * When `list` was empty, returns `items` instead.\n *\n * This prevents a potentially expensive operation when `list` is empty,\n * and adds items in batches to prevent V8 from hanging.\n *\n * @template {unknown} T\n *   Item type.\n * @param {Array<T>} list\n *   List to operate on.\n * @param {Array<T>} items\n *   Items to add to `list`.\n * @returns {Array<T>}\n *   Either `list` or `items`.\n */\nexport function push(list, items) {\n  if (list.length > 0) {\n    splice(list, list.length, 0, items)\n    return list\n  }\n  return items\n}\n","export {gfmAutolinkLiteral} from './lib/syntax.js'\nexport {gfmAutolinkLiteralHtml} from './lib/html.js'\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\nconst wwwPrefix = {\n  tokenize: tokenizeWwwPrefix,\n  partial: true\n}\nconst domain = {\n  tokenize: tokenizeDomain,\n  partial: true\n}\nconst path = {\n  tokenize: tokenizePath,\n  partial: true\n}\nconst trail = {\n  tokenize: tokenizeTrail,\n  partial: true\n}\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n}\nconst wwwAutolink = {\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\nconst protocolAutolink = {\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n}\nconst emailAutolink = {\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n\n/** @type {ConstructRecord} */\nconst text = {}\n\n// To do: next major: expose functions that yields extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * autolink literal syntax.\n *\n * @type {Extension}\n */\nexport const gfmAutolinkLiteral = {\n  text\n}\n\n/** @type {Code} */\nlet code = 48\n\n// Add alphanumerics.\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  if (code === 58) code = 65\n  else if (code === 91) code = 97\n}\ntext[43] = emailAutolink\ntext[45] = emailAutolink\ntext[46] = emailAutolink\ntext[95] = emailAutolink\ntext[72] = [emailAutolink, protocolAutolink]\ntext[104] = [emailAutolink, protocolAutolink]\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n\n// To do: perform email autolink literals on events, afterwards.\n// That’s where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean | undefined} */\n  let dot\n  /** @type {boolean} */\n  let data\n  return start\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n    if (code === 64) {\n      effects.consume(code)\n      return emailDomain\n    }\n    return nok(code)\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === 46) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code)\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {\n      data = true\n      effects.consume(code)\n      return emailDomain\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally we’d truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isn’t trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code)\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code)\n    dot = true\n    return emailDomain\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n  return wwwStart\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (\n      (code !== 87 && code !== 119) ||\n      !previousWww.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code)\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this\n  let buffer = ''\n  let seen = false\n  return protocolStart\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if (\n      (code === 72 || code === 104) &&\n      previousProtocol.call(self, self.previous) &&\n      !previousUnbalanced(self.events)\n    ) {\n      effects.enter('literalAutolink')\n      effects.enter('literalAutolinkHttp')\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if (asciiAlpha(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n    if (code === 58) {\n      const protocol = buffer.toLowerCase()\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code)\n        return protocolSlashesInside\n      }\n    }\n    return nok(code)\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === 47) {\n      effects.consume(code)\n      if (seen) {\n        return afterProtocol\n      }\n      seen = true\n      return protocolSlashesInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === null ||\n      asciiControl(code) ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0\n  return wwwPrefixInside\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === 87 || code === 119) && size < 3) {\n      size++\n      effects.consume(code)\n      return wwwPrefixInside\n    }\n    if (code === 46 && size === 3) {\n      effects.consume(code)\n      return wwwPrefixAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment\n  /** @type {boolean | undefined} */\n  let seen\n  return domainInside\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === 46 || code === 95) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www.點看.com`,\n    // so that’s Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 && unicodePunctuation(code))\n    ) {\n      return domainAfter(code)\n    }\n    seen = true\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === 95) {\n      underscoreInLastSegment = true\n    }\n    // Otherwise, it’s a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment\n      underscoreInLastSegment = undefined\n    }\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: that’s GH says a dot is needed, but it’s not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code)\n    }\n    return ok(code)\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0\n  let sizeClose = 0\n  return pathInside\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === 40) {\n      sizeOpen++\n      effects.consume(code)\n      return pathInside\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we don’t check for a trail.\n    if (code === 41 && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code)\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (\n      code === 33 ||\n      code === 34 ||\n      code === 38 ||\n      code === 39 ||\n      code === 41 ||\n      code === 42 ||\n      code === 44 ||\n      code === 46 ||\n      code === 58 ||\n      code === 59 ||\n      code === 60 ||\n      code === 63 ||\n      code === 93 ||\n      code === 95 ||\n      code === 126\n    ) {\n      return effects.check(trail, ok, pathAtPunctuation)(code)\n    }\n    if (\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    effects.consume(code)\n    return pathInside\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === 41) {\n      sizeClose++\n    }\n    effects.consume(code)\n    return pathInside\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (\n      code === 33 ||\n      code === 34 ||\n      code === 39 ||\n      code === 41 ||\n      code === 42 ||\n      code === 44 ||\n      code === 46 ||\n      code === 58 ||\n      code === 59 ||\n      code === 63 ||\n      code === 95 ||\n      code === 126\n    ) {\n      effects.consume(code)\n      return trail\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === 38) {\n      effects.consume(code)\n      return trailCharRefStart\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === 93) {\n      effects.consume(code)\n      return trailBracketAfter\n    }\n    if (\n      // `<` is an end.\n      code === 60 ||\n      // So is whitespace.\n      code === null ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (\n      code === null ||\n      code === 40 ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code) ||\n      unicodeWhitespace(code)\n    ) {\n      return ok(code)\n    }\n    return trail(code)\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefStart(code) {\n    // When non-alpha, it’s not a trail.\n    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharRefInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === 59) {\n      effects.consume(code)\n      return trail\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return trailCharRefInside\n    }\n\n    // It’s not a trail.\n    return nok(code)\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return asciiAlphanumeric(code) ? nok(code) : ok(code)\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code === 40 ||\n    code === 42 ||\n    code === 95 ||\n    code === 91 ||\n    code === 93 ||\n    code === 126 ||\n    markdownLineEndingOrSpace(code)\n  )\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !asciiAlpha(code)\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash “inside” atext.\n  // The reference code is a bit weird, but that’s what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === 47 || gfmAtext(code))\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return (\n    code === 43 ||\n    code === 45 ||\n    code === 46 ||\n    code === 95 ||\n    asciiAlphanumeric(code)\n  )\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n  while (index--) {\n    const token = events[index][1]\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    }\n\n    // If we’ve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n  if (events.length > 0 && !result) {\n    // Mark the last token as “walked into” w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n  return result\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiDigit = regexCheck(/\\d/)\n\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n *   Code.\n * @returns {boolean}\n *   Whether it matches.\n */\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n *\n * @param code\n *   Code.\n * @returns\n *   Whether it matches.\n */\nexport const unicodeWhitespace = regexCheck(/\\s/)\n\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => boolean}\n */\nfunction regexCheck(regex) {\n  return check\n\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code\n   *   Character code.\n   * @returns {boolean}\n   *   Whether the character code matches the bound regex.\n   */\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\n\n/**\n * Regular expression that matches a unicode punctuation character.\n */\nexport const unicodePunctuationRegex =\n  /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","// Note: types are exported from `dev/index.d.ts`.\nexport {gfmFootnote} from './lib/syntax.js'\nexport {gfmFootnoteHtml, defaultBackLabel} from './lib/html.js'\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [91]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [91]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [93]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n    if (token.type === 'labelImage') {\n      labelStart = token\n      break\n    }\n\n    // Exit if we’ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === 'labelLink' ||\n      token.type === 'label' ||\n      token.type === 'image' ||\n      token.type === 'link'\n    ) {\n      break\n    }\n  }\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({\n        start: labelStart.end,\n        end: self.now()\n      })\n    )\n    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === 'labelImage' &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = 'data'\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: 'chunkString',\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n  events.splice(index, events.length - index + 1, ...replacement)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We can’t do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== 94) return nok(code)\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === 94) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > 999 ||\n      // Closing brace with nothing.\n      (code === 93 && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === null ||\n      code === 91 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n    size++\n    effects.consume(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    4 + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === 4\n      ? ok(code)\n      : nok(code)\n  }\n}\n","export {attention} from './lib/attention.js'\nexport {autolink} from './lib/autolink.js'\nexport {blankLine} from './lib/blank-line.js'\nexport {blockQuote} from './lib/block-quote.js'\nexport {characterEscape} from './lib/character-escape.js'\nexport {characterReference} from './lib/character-reference.js'\nexport {codeFenced} from './lib/code-fenced.js'\nexport {codeIndented} from './lib/code-indented.js'\nexport {codeText} from './lib/code-text.js'\nexport {content} from './lib/content.js'\nexport {definition} from './lib/definition.js'\nexport {hardBreakEscape} from './lib/hard-break-escape.js'\nexport {headingAtx} from './lib/heading-atx.js'\nexport {htmlFlow} from './lib/html-flow.js'\nexport {htmlText} from './lib/html-text.js'\nexport {labelEnd} from './lib/label-end.js'\nexport {labelStartImage} from './lib/label-start-image.js'\nexport {labelStartLink} from './lib/label-start-link.js'\nexport {lineEnding} from './lib/line-ending.js'\nexport {list} from './lib/list.js'\nexport {setextUnderline} from './lib/setext-underline.js'\nexport {thematicBreak} from './lib/thematic-break.js'\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n  let open\n  /** @type {Token} */\n  let group\n  /** @type {Token} */\n  let text\n  /** @type {Token} */\n  let openingSequence\n  /** @type {Token} */\n  let closingSequence\n  /** @type {number} */\n  let use\n  /** @type {Array<Event>} */\n  let nextEvents\n  /** @type {number} */\n  let offset\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open &&\n          // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          }\n\n          // Number of markers to use from the sequence.\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = []\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ])\n\n          // Always populated by defaults.\n\n          // Between.\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          )\n\n          // Closing.\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ])\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Before a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    marker = code\n    effects.enter('attentionSequence')\n    return inside(code)\n  }\n\n  /**\n   * In a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    const token = effects.exit('attentionSequence')\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code)\n\n    // Always populated by defaults.\n\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {\n  markdownLineEndingOrSpace,\n  unicodePunctuation,\n  unicodeWhitespace\n} from 'micromark-util-character'\n/**\n * Classify whether a code represents whitespace, punctuation, or something\n * else.\n *\n * Used for attention (emphasis, strong), whose sequences can open or close\n * based on the class of surrounding characters.\n *\n * > 👉 **Note**: eof (`null`) is seen as whitespace.\n *\n * @param {Code} code\n *   Code.\n * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}\n *   Group.\n */\nexport function classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * Call all `resolveAll`s.\n *\n * @param {Array<{resolveAll?: Resolver | undefined}>} constructs\n *   List of constructs, optionally with `resolveAll`s.\n * @param {Array<Event>} events\n *   List of events.\n * @param {TokenizeContext} context\n *   Context used by `tokenize`.\n * @returns {Array<Event>}\n *   Changed events.\n */\nexport function resolveAll(constructs, events, context) {\n  /** @type {Array<Resolver>} */\n  const called = []\n  let index = -1\n\n  while (++index < constructs.length) {\n    const resolve = constructs[index].resolveAll\n\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 0\n  return start\n\n  /**\n   * Start of an autolink.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *      ^\n   * > | a<user@example.com>b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n\n  /**\n   * After `<`, at protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *       ^\n   * > | a<user@example.com>b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n    return emailAtext(code)\n  }\n\n  /**\n   * At second byte of protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeOrEmailAtext(code) {\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) {\n      // Count the previous alphabetical from `open` too.\n      size = 1\n      return schemeInsideOrEmailAtext(code)\n    }\n    return emailAtext(code)\n  }\n\n  /**\n   * In ambiguous protocol or atext.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *        ^\n   * > | a<user@example.com>b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      size = 0\n      return urlInside\n    }\n\n    // ASCII alphanumeric and `+`, `-`, and `.`.\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n    size = 0\n    return emailAtext(code)\n  }\n\n  /**\n   * After protocol, in URL.\n   *\n   * ```markdown\n   * > | a<https://example.com>b\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      effects.enter('autolinkMarker')\n      effects.consume(code)\n      effects.exit('autolinkMarker')\n      effects.exit('autolink')\n      return ok\n    }\n\n    // ASCII control, space, or `<`.\n    if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return urlInside\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      return emailAtSignOrDot\n    }\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n    return nok(code)\n  }\n\n  /**\n   * In label, after at-sign or dot.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                 ^       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are allowed.\n   *\n   * ```markdown\n   * > | a<user.name@example.com>b\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n    if (code === 62) {\n      // Exit, then change the token type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      effects.enter('autolinkMarker')\n      effects.consume(code)\n      effects.exit('autolinkMarker')\n      effects.exit('autolink')\n      return ok\n    }\n    return emailValue(code)\n  }\n\n  /**\n   * In label, where `.` and `>` are *not* allowed.\n   *\n   * Though, this is also used in `emailLabel` to parse other values.\n   *\n   * ```markdown\n   * > | a<user.name@ex-ample.com>b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailValue(code) {\n    // ASCII alphanumeric or `-`.\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      const next = code === 45 ? emailValue : emailLabel\n      effects.consume(code)\n      return next\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of blank line.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *     ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'linePrefix')(code)\n      : after(code)\n  }\n\n  /**\n   * At eof/eol, after optional whitespace.\n   *\n   * > 👉 **Note**: `␠` represents a space character.\n   *\n   * ```markdown\n   * > | ␠␠␊\n   *       ^\n   * > | ␊\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownSpace} from 'micromark-util-character'\n\n// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.\n\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   spaces in markdown are often optional, in which case this factory can be\n *     used and `ok` will be switched to whether spaces were found or not\n * *   one line ending or space can be detected with `markdownSpace(code)` right\n *     before using `factorySpace`\n *\n * ###### Examples\n *\n * Where `␉` represents a tab (plus how much it expands) and `␠` represents a\n * single space.\n *\n * ```markdown\n * ␉\n * ␠␠␠␠\n * ␉␠\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {TokenType} type\n *   Type (`' \\t'`).\n * @param {number | undefined} [max=Infinity]\n *   Max (exclusive).\n * @returns\n *   Start state.\n */\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of block quote.\n   *\n   * ```markdown\n   * > | > a\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `>`, before optional whitespace.\n   *\n   * ```markdown\n   * > | > a\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n\n/**\n * Start of block quote continuation.\n *\n * ```markdown\n *   | > a\n * > | > b\n *     ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  const self = this\n  return contStart\n\n  /**\n   * Start of block quote continuation.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      // Always populated by defaults.\n\n      return factorySpace(\n        effects,\n        contBefore,\n        'linePrefix',\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : 4\n      )(code)\n    }\n    return contBefore(code)\n  }\n\n  /**\n   * At `>`, after optional whitespace.\n   *\n   * Also used to parse the first block quote opening.\n   *\n   * ```markdown\n   *   | > a\n   * > | > b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok, nok)(code)\n  }\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {asciiPunctuation} from 'micromark-util-character'\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of character escape.\n   *\n   * ```markdown\n   * > | a\\*b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return inside\n  }\n\n  /**\n   * After `\\`, at punctuation.\n   *\n   * ```markdown\n   * > | a\\*b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // ASCII punctuation.\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n  let max\n  /** @type {(code: Code) => boolean} */\n  let test\n  return start\n\n  /**\n   * Start of character reference.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *      ^\n   * > | a&#123;b\n   *      ^\n   * > | a&#x9;b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n\n  /**\n   * After `&`, at `#` for numeric references or alphanumeric for named\n   * references.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^\n   * > | a&#123;b\n   *       ^\n   * > | a&#x9;b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  /**\n   * After `#`, at `x` for hexadecimals or digit for decimals.\n   *\n   * ```markdown\n   * > | a&#123;b\n   *        ^\n   * > | a&#x9;b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n\n  /**\n   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.\n   *\n   * The character reference kind defines what and how many characters are\n   * allowed.\n   *\n   * ```markdown\n   * > | a&amp;b\n   *       ^^^\n   * > | a&#123;b\n   *        ^^^\n   * > | a&#x9;b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function value(code) {\n    if (code === 59 && size) {\n      const token = effects.exit('characterReferenceValue')\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      // To do: `markdown-rs` uses a different name:\n      // `CharacterReferenceMarkerSemi`.\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n    return nok(code)\n  }\n}\n","/// <reference lib=\"dom\" />\n\n/* eslint-env browser */\n\nconst element = document.createElement('i')\n\n/**\n * @param {string} value\n * @returns {string|false}\n */\nexport function decodeNamedCharacterReference(value) {\n  const characterReference = '&' + value + ';'\n  element.innerHTML = characterReference\n  const char = element.textContent\n\n  // Some named character references do not require the closing semicolon\n  // (`&not`, for instance), which leads to situations where parsing the assumed\n  // named reference of `&notit;` will result in the string `¬it;`.\n  // When we encounter a trailing semicolon after parsing, and the character\n  // reference to decode was not a semicolon (`&semi;`), we can assume that the\n  // matching was not complete.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the character reference was\n  // not valid.\n  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n  // yield `null`.\n  return char === characterReference ? false : char\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closeStart = {\n    tokenize: tokenizeCloseStart,\n    partial: true\n  }\n  let initialPrefix = 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code)\n  }\n\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeSequenceOpen(code) {\n    const tail = self.events[self.events.length - 1]\n    initialPrefix =\n      tail && tail[1].type === 'linePrefix'\n        ? tail[2].sliceSerialize(tail[1], true).length\n        : 0\n    marker = code\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++\n      effects.consume(code)\n      return sequenceOpen\n    }\n    if (sizeOpen < 3) {\n      return nok(code)\n    }\n    effects.exit('codeFencedFenceSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, infoBefore, 'whitespace')(code)\n      : infoBefore(code)\n  }\n\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function infoBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFencedFence')\n      return self.interrupt\n        ? ok(code)\n        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function info(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return infoBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, metaBefore, 'whitespace')(code)\n    }\n    if (code === 96 && code === marker) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return info\n  }\n\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return infoBefore(code)\n    }\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return infoBefore(code)\n    }\n    if (code === 96 && code === marker) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function atNonLazyBreak(code) {\n    return effects.attempt(closeStart, after, contentBefore)(code)\n  }\n\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentBefore(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return contentStart\n  }\n\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code)\n      ? factorySpace(\n          effects,\n          beforeContentChunk,\n          'linePrefix',\n          initialPrefix + 1\n        )(code)\n      : beforeContentChunk(code)\n  }\n\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)\n    }\n    effects.enter('codeFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0\n    return startBefore\n\n    /**\n     *\n     *\n     * @type {State}\n     */\n    function startBefore(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // Always populated by defaults.\n\n      // To do: `enter` here or in next state?\n      effects.enter('codeFencedFence')\n      return markdownSpace(code)\n        ? factorySpace(\n            effects,\n            beforeSequenceClose,\n            'linePrefix',\n            self.parser.constructs.disable.null.includes('codeIndented')\n              ? undefined\n              : 4\n          )(code)\n        : beforeSequenceClose(code)\n    }\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter('codeFencedFenceSequence')\n        return sequenceClose(code)\n      }\n      return nok(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size >= sizeOpen) {\n        effects.exit('codeFencedFenceSequence')\n        return markdownSpace(code)\n          ? factorySpace(effects, sequenceCloseAfter, 'whitespace')(code)\n          : sequenceCloseAfter(code)\n      }\n      return nok(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceCloseAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n\n/** @type {Construct} */\nconst furtherStart = {\n  tokenize: tokenizeFurtherStart,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of code (indented).\n   *\n   * > **Parsing note**: it is not needed to check if this first line is a\n   * > filled line (that it has a non-whitespace character), because blank lines\n   * > are parsed already, so we never run into that.\n   *\n   * ```markdown\n   * > |     aaa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: manually check if interrupting like `markdown-rs`.\n\n    effects.enter('codeIndented')\n    // To do: use an improved `space_or_tab` function like `markdown-rs`,\n    // so that we can drop the next state.\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n\n  /**\n   * At start, after 1 or 4 spaces.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? atBreak(code)\n      : nok(code)\n  }\n\n  /**\n   * At a break.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(furtherStart, atBreak, after)(code)\n    }\n    effects.enter('codeFlowValue')\n    return inside(code)\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return inside\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit('codeIndented')\n    // To do: allow interrupting like `markdown-rs`.\n    // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeFurtherStart(effects, ok, nok) {\n  const self = this\n  return furtherStart\n\n  /**\n   * At eol, trying to parse another indent.\n   *\n   * ```markdown\n   * > |     aaa\n   *            ^\n   *   |     bbb\n   * ```\n   *\n   * @type {State}\n   */\n  function furtherStart(code) {\n    // To do: improve `lazy` / `pierce` handling.\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return furtherStart\n    }\n\n    // To do: the code here in `micromark-js` is a bit different from\n    // `markdown-rs` because there it can attempt spaces.\n    // We can’t yet.\n    //\n    // To do: use an improved `space_or_tab` function like `markdown-rs`,\n    // so that we can drop the next state.\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n\n  /**\n   * At start, after 1 or 4 spaces.\n   *\n   * ```markdown\n   * > |     aaa\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? furtherStart(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n\n// To do: next major: don’t resolve, like `markdown-rs`.\n/** @type {Resolver} */\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding'\n        events[tailExitIndex][1].type = 'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n      enter = undefined\n    }\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n  let size\n  /** @type {Token} */\n  let token\n  return start\n\n  /**\n   * Start of code (text).\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * > | \\`a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    effects.exit('codeTextSequence')\n    return between(code)\n  }\n\n  /**\n   * Between something and something else.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function between(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    }\n\n    // To do: next major: don’t do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs don’t work, and virtual spaces don’t make sense.\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return between\n    }\n\n    // Closing fence? Could also be data.\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return sequenceClose(code)\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return between\n    }\n\n    // Data.\n    effects.enter('codeTextData')\n    return data(code)\n  }\n\n  /**\n   * In data.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return between(code)\n    }\n    effects.consume(code)\n    return data\n  }\n\n  /**\n   * In closing sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceClose(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return sequenceClose\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    }\n\n    // More or less accents: mark as data.\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {subtokenize} from 'micromark-util-subtokenize'\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nexport const content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n}\n\n/** @type {Construct} */\nconst continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n}\n\n/**\n * Content is transparent: it’s parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token | undefined} */\n  let previous\n  return chunkStart\n\n  /**\n   * Before a content chunk.\n   *\n   * ```markdown\n   * > | abc\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function chunkStart(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return chunkInside(code)\n  }\n\n  /**\n   * In a content chunk.\n   *\n   * ```markdown\n   * > | abc\n   *     ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function chunkInside(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    // To do: in `markdown-rs`, each line is parsed on its own, and everything\n    // is stitched together resolving.\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    }\n\n    // Data.\n    effects.consume(code)\n    return chunkInside\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous\n    })\n    previous = previous.next\n    return chunkInside\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this\n  return startLookahead\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function startLookahead(code) {\n    effects.exit('chunkContent')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    // Always populated by defaults.\n\n    const tail = self.events[self.events.length - 1]\n    if (\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\n      tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n    ) {\n      return ok(code)\n    }\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n */\n\nimport {splice} from 'micromark-util-chunked'\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} events\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */\nexport function subtokenize(events) {\n  /** @type {Record<string, number>} */\n  const jumps = {}\n  let index = -1\n  /** @type {Event} */\n  let event\n  /** @type {number | undefined} */\n  let lineIndex\n  /** @type {number} */\n  let otherIndex\n  /** @type {Event} */\n  let otherEvent\n  /** @type {Array<Event>} */\n  let parameters\n  /** @type {Array<Event>} */\n  let subevents\n  /** @type {boolean | undefined} */\n  let more\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n    event = events[index]\n\n    // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    }\n\n    // Enter.\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    }\n    // Exit.\n    else if (event[1]._container) {\n      otherIndex = index\n      lineIndex = undefined\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events[lineIndex][1].start)\n\n        // Switch container exit w/ line endings.\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        splice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n  return !more\n}\n\n/**\n * Tokenize embedded tokens.\n *\n * @param {Array<Event>} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\nfunction subcontent(events, eventIndex) {\n  const token = events[eventIndex][1]\n  const context = events[eventIndex][2]\n  let startPosition = eventIndex - 1\n  /** @type {Array<number>} */\n  const startPositions = []\n  const tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  const childEvents = tokenizer.events\n  /** @type {Array<[number, number]>} */\n  const jumps = []\n  /** @type {Record<string, number>} */\n  const gaps = {}\n  /** @type {Array<Chunk>} */\n  let stream\n  /** @type {Token | undefined} */\n  let previous\n  let index = -1\n  /** @type {Token | undefined} */\n  let current = token\n  let adjust = 0\n  let start = 0\n  const breaks = [start]\n\n  // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n  while (current) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== current) {\n      // Empty.\n    }\n    startPositions.push(startPosition)\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current)\n      if (!current.next) {\n        stream.push(null)\n      }\n      if (previous) {\n        tokenizer.defineSkip(current.start)\n      }\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n      tokenizer.write(stream)\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    }\n\n    // Unravel the next token.\n    previous = current\n    current = current.next\n  }\n\n  // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n  current = token\n  while (++index < childEvents.length) {\n    if (\n      // Find a void token that includes a break.\n      childEvents[index][0] === 'exit' &&\n      childEvents[index - 1][0] === 'enter' &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      start = index + 1\n      breaks.push(start)\n      // Help GC.\n      current._tokenizer = undefined\n      current.previous = undefined\n      current = current.next\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = []\n\n  // If there’s one more token (which is the cases for lines that end in an\n  // EOF), that’s perfect: the last point we found starts it.\n  // If there isn’t then make sure any remaining content is added to it.\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined\n    current.previous = undefined\n  } else {\n    breaks.pop()\n  }\n\n  // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren’t affected.\n  index = breaks.length\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1])\n    const start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    splice(events, start, 2, slice)\n  }\n  index = -1\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n  return gaps\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n\n/** @type {Construct} */\nconst titleBefore = {\n  tokenize: tokenizeTitleBefore,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n  let identifier\n  return start\n\n  /**\n   * At start of a definition.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Do not interrupt paragraphs (but do follow definitions).\n    // To do: do `interrupt` the way `markdown-rs` does.\n    // To do: parse whitespace the way `markdown-rs` does.\n    effects.enter('definition')\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `[`.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    // To do: parse whitespace the way `markdown-rs` does.\n\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      // Note: we don’t need to reset the way `markdown-rs` does.\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n\n  /**\n   * After label.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      return markerAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After marker.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function markerAfter(code) {\n    // Note: whitespace is optional.\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, destinationBefore)(code)\n      : destinationBefore(code)\n  }\n\n  /**\n   * Before destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationBefore(code) {\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      // Note: we don’t need to reset the way `markdown-rs` does.\n      nok,\n      'definitionDestination',\n      'definitionDestinationLiteral',\n      'definitionDestinationLiteralMarker',\n      'definitionDestinationRaw',\n      'definitionDestinationString'\n    )(code)\n  }\n\n  /**\n   * After destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationAfter(code) {\n    return effects.attempt(titleBefore, after, after)(code)\n  }\n\n  /**\n   * After definition.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, afterWhitespace, 'whitespace')(code)\n      : afterWhitespace(code)\n  }\n\n  /**\n   * After definition, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterWhitespace(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      // Note: we don’t care about uniqueness.\n      // It’s likely that that doesn’t happen very frequently.\n      // It is more likely that it wastes precious time.\n      self.parser.defined.push(identifier)\n\n      // To do: `markdown-rs` interrupt.\n      // // You’d be interrupting.\n      // tokenizer.interrupt = true\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTitleBefore(effects, ok, nok) {\n  return titleBefore\n\n  /**\n   * After destination, at whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, beforeMarker)(code)\n      : nok(code)\n  }\n\n  /**\n   * At title.\n   *\n   * ```markdown\n   *   | [a]: b\n   * > | \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeMarker(code) {\n    return factoryTitle(\n      effects,\n      titleAfter,\n      nok,\n      'definitionTitle',\n      'definitionTitleMarker',\n      'definitionTitleString'\n    )(code)\n  }\n\n  /**\n   * After title.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfter(code) {\n    return markdownSpace(code)\n      ? factorySpace(effects, titleAfterOptionalWhitespace, 'whitespace')(code)\n      : titleAfterOptionalWhitespace(code)\n  }\n\n  /**\n   * After title, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfterOptionalWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n/**\n * Parse destinations.\n *\n * ###### Examples\n *\n * ```markdown\n * <a>\n * <a\\>b>\n * <a b>\n * <a)>\n * a\n * a\\)b\n * a(b)c\n * a(b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type for whole (`<a>` or `b`).\n * @param {TokenType} literalType\n *   Type when enclosed (`<a>`).\n * @param {TokenType} literalMarkerType\n *   Type for enclosing (`<` and `>`).\n * @param {TokenType} rawType\n *   Type when not enclosed (`b`).\n * @param {TokenType} stringType\n *   Type for the value (`a` or `b`).\n * @param {number | undefined} [max=Infinity]\n *   Depth of nested parens (inclusive).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n\n  /**\n   * Start of destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *     ^\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return enclosedBefore\n    }\n\n    // ASCII control, space, closing paren.\n    if (code === null || code === 32 || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return raw(code)\n  }\n\n  /**\n   * After `<`, at an enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return enclosed(code)\n  }\n\n  /**\n   * In enclosed destination.\n   *\n   * ```markdown\n   * > | <aa>\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return enclosedBefore(code)\n    }\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? enclosedEscape : enclosed\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | <a\\*a>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function enclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return enclosed\n    }\n    return enclosed(code)\n  }\n\n  /**\n   * In raw destination.\n   *\n   * ```markdown\n   * > | aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function raw(code) {\n    if (\n      !balance &&\n      (code === null || code === 41 || markdownLineEndingOrSpace(code))\n    ) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n    if (balance < limit && code === 40) {\n      effects.consume(code)\n      balance++\n      return raw\n    }\n    if (code === 41) {\n      effects.consume(code)\n      balance--\n      return raw\n    }\n\n    // ASCII control (but *not* `\\0`) and space and `(`.\n    // Note: in `markdown-rs`, `\\0` exists in codes, in `micromark-js` it\n    // doesn’t.\n    if (code === null || code === 32 || code === 40 || asciiControl(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return code === 92 ? rawEscape : raw\n  }\n\n  /**\n   * After `\\`, at special character.\n   *\n   * ```markdown\n   * > | a\\*a\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function rawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return raw\n    }\n    return raw(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse labels.\n *\n * > 👉 **Note**: labels in markdown are capped at 999 characters in the string.\n *\n * ###### Examples\n *\n * ```markdown\n * [a]\n * [a\n * b]\n * [a\\]b]\n * ```\n *\n * @this {TokenizeContext}\n *   Tokenize context.\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole label (`[a]`).\n * @param {TokenType} markerType\n *   Type for the markers (`[` and `]`).\n * @param {TokenType} stringType\n *   Type for the identifier (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryLabel(effects, ok, nok, type, markerType, stringType) {\n  const self = this\n  let size = 0\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /**\n   * Start of label.\n   *\n   * ```markdown\n   * > | [a]\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  /**\n   * In label, at something, before something else.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (\n      size > 999 ||\n      code === null ||\n      code === 91 ||\n      (code === 93 && !seen) ||\n      // To do: remove in the future once we’ve switched from\n      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n      // which doesn’t need this.\n      // Hidden footnotes hook.\n      /* c8 ignore next 3 */\n      (code === 94 &&\n        !size &&\n        '_hiddenFootnoteSupport' in self.parser.constructs)\n    ) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    // To do: indent? Link chunks and EOLs together?\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return labelInside(code)\n  }\n\n  /**\n   * In label, in text.\n   *\n   * ```markdown\n   * > | [a]\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    if (!seen) seen = !markdownSpace(code)\n    return code === 92 ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | [a\\*a]\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n    return labelInside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/**\n * Parse titles.\n *\n * ###### Examples\n *\n * ```markdown\n * \"a\"\n * 'b'\n * (c)\n * \"a\n * b\"\n * 'a\n *     b'\n * (a\\)b)\n * ```\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @param {State} nok\n *   State switched to when unsuccessful.\n * @param {TokenType} type\n *   Type of the whole title (`\"a\"`, `'b'`, `(c)`).\n * @param {TokenType} markerType\n *   Type for the markers (`\"`, `'`, `(`, and `)`).\n * @param {TokenType} stringType\n *   Type for the value (`a`).\n * @returns {State}\n *   Start state.\n */ // eslint-disable-next-line max-params\nexport function factoryTitle(effects, ok, nok, type, markerType, stringType) {\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of title.\n   *\n   * ```markdown\n   * > | \"a\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      effects.enter(type)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      marker = code === 40 ? 41 : code\n      return begin\n    }\n    return nok(code)\n  }\n\n  /**\n   * After opening marker.\n   *\n   * This is also used at the closing marker.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function begin(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n    effects.enter(stringType)\n    return atBreak(code)\n  }\n\n  /**\n   * At something, before something else.\n   *\n   * ```markdown\n   * > | \"a\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return begin(marker)\n    }\n    if (code === null) {\n      return nok(code)\n    }\n\n    // Note: blank lines can’t exist in content.\n    if (markdownLineEnding(code)) {\n      // To do: use `space_or_tab_eol_with_options`, connect.\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atBreak, 'linePrefix')\n    }\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return inside(code)\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? escape : inside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * ```markdown\n   * > | \"a\\*b\"\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function escape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return inside\n    }\n    return inside(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/**\n * Parse spaces and tabs.\n *\n * There is no `nok` parameter:\n *\n * *   line endings or spaces in markdown are often optional, in which case this\n *     factory can be used and `ok` will be switched to whether spaces were found\n *     or not\n * *   one line ending or space can be detected with\n *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`\n *\n * @param {Effects} effects\n *   Context.\n * @param {State} ok\n *   State switched to when successful.\n * @returns\n *   Start state.\n */\nexport function factoryWhitespace(effects, ok) {\n  /** @type {boolean} */\n  let seen\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n    return ok(code)\n  }\n}\n","/**\n * Normalize an identifier (as found in references, definitions).\n *\n * Collapses markdown whitespace, trim, and then lower- and uppercase.\n *\n * Some characters are considered “uppercase”, such as U+03F4 (`ϴ`), but if their\n * lowercase counterpart (U+03B8 (`θ`)) is uppercased will result in a different\n * uppercase character (U+0398 (`Θ`)).\n * So, to get a canonical form, we perform both lower- and uppercase.\n *\n * Using uppercase last makes sure keys will never interact with default\n * prototypal values (such as `constructor`): nothing in the prototype of\n * `Object` is uppercase.\n *\n * @param {string} value\n *   Identifier to normalize.\n * @returns {string}\n *   Normalized identifier.\n */\nexport function normalizeIdentifier(value) {\n  return (\n    value\n      // Collapse markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ')\n      // Trim.\n      .replace(/^ | $/g, '')\n      // Some characters are considered “uppercase”, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n\n  /**\n   * Start of a hard break (escape).\n   *\n   * ```markdown\n   * > | a\\\n   *      ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After `\\`, at eol.\n   *\n   * ```markdown\n   * > | a\\\n   *       ^\n   *   | b\n   * ```\n   *\n   *  @type {State}\n   */\n  function after(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n  let content\n  /** @type {Token} */\n  let text\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0\n  return start\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter('atxHeading')\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('atxHeadingSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return sequenceOpen\n    }\n\n    // Always at least one `#`.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return atBreak(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequenceFurther(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequenceFurther\n    }\n    effects.exit('atxHeadingSequence')\n    return atBreak(code)\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return atBreak(code)\n    }\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst blankLineBefore = {\n  tokenize: tokenizeBlankLineBefore,\n  partial: true\n}\nconst nonLazyContinuationStart = {\n  tokenize: tokenizeNonLazyContinuationStart,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let marker\n  /** @type {boolean} */\n  let closingTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let markerB\n  return start\n\n  /**\n   * Start of HTML (flow).\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * At `<`, after optional whitespace.\n   *\n   * ```markdown\n   * > | <x />\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | <x />\n   *      ^\n   * > | <!doctype>\n   *      ^\n   * > | <!--xxx-->\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      closingTag = true\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      marker = 3\n      // To do:\n      // tokenizer.concrete = true\n      // To do: use `markdown-rs` style interrupt.\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *       ^\n   * > | <!--xxx-->\n   *       ^\n   * > | <![CDATA[>&<]]>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      marker = 2\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      marker = 5\n      index = 0\n      return cdataOpenInside\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      marker = 4\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!-`, inside a comment, at another `-`.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<![`, inside CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *        ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      if (index === value.length) {\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok : continuation\n      }\n      return cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | </x>\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * In tag name.\n   *\n   * ```markdown\n   * > | <ab>\n   *      ^^\n   * > | </ab>\n   *       ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      const slash = code === 47\n      const name = buffer.toLowerCase()\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = 1\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = 6\n        if (slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        // // Do not form containers.\n        // tokenizer.concrete = true\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n      marker = 7\n      // Do not support complete HTML when interrupting.\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : closingTag\n        ? completeClosingTagAfter(code)\n        : completeAttributeNameBefore(code)\n    }\n\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a basic tag name.\n   *\n   * ```markdown\n   * > | <div/>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return self.interrupt ? ok : continuation\n    }\n    return nok(code)\n  }\n\n  /**\n   * After closing slash of a complete tag name.\n   *\n   * ```markdown\n   * > | <x/>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * At an attribute name.\n   *\n   * At first, this state is used after a complete tag name, after whitespace,\n   * where it expects optional attributes or the end of the tag.\n   * It is also reused after attributes, when expecting more optional\n   * attributes.\n   *\n   * ```markdown\n   * > | <a />\n   *        ^\n   * > | <a :b>\n   *        ^\n   * > | <a _b>\n   *        ^\n   * > | <a b>\n   *        ^\n   * > | <a >\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    // ASCII alphanumerical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n    return completeEnd(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | <a :b>\n   *         ^\n   * > | <a _b>\n   *         ^\n   * > | <a b>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeName(code) {\n    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n    return completeAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, at an optional initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b>\n   *         ^\n   * > | <a b=c>\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n    return completeAttributeNameBefore(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * > | <a b=\"c\">\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      markerB = code\n      return completeAttributeValueQuoted\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *           ^\n   * > | <a b='c'>\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code)\n      markerB = null\n      return completeAttributeValueQuotedAfter\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | <a b=c>\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 47 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the\n   * end of the tag.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a complete tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | <a b=\"c\">\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `>` in a complete tag.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function completeAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      // // Do not form containers.\n      // tokenizer.concrete = true\n      return continuation(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n    return nok(code)\n  }\n\n  /**\n   * In continuation of any HTML kind.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuation(code) {\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n    if (code === 60 && marker === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n    if (code === 62 && marker === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n    if (code === 63 && marker === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    if (code === 93 && marker === 5) {\n      effects.consume(code)\n      return continuationCdataInside\n    }\n    if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {\n      effects.exit('htmlFlowData')\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationStart(code)\n    }\n    effects.consume(code)\n    return continuation\n  }\n\n  /**\n   * In continuation, at eol.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code)\n  }\n\n  /**\n   * In continuation, at eol, before non-lazy content.\n   *\n   * ```markdown\n   * > | <x>\n   *        ^\n   *   | asd\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationStartNonLazy(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return continuationBefore\n  }\n\n  /**\n   * In continuation, before non-lazy content.\n   *\n   * ```markdown\n   *   | <x>\n   * > | asd\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return continuationStart(code)\n    }\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n\n  /**\n   * In comment continuation, after one `-`, expecting another.\n   *\n   * ```markdown\n   * > | <!--xxx-->\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `<`, at `/`.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In raw continuation, after `</`, in a raw tag name.\n   *\n   * ```markdown\n   * > | <script>console.log(1)</script>\n   *                             ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationRawEndTag(code) {\n    if (code === 62) {\n      const name = buffer.toLowerCase()\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code)\n        return continuationClose\n      }\n      return continuation(code)\n    }\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      // @ts-expect-error: not null.\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In cdata continuation, after `]`, expecting `]>`.\n   *\n   * ```markdown\n   * > | <![CDATA[>&<]]>\n   *                  ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationCdataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In declaration or instruction continuation, at `>`.\n   *\n   * ```markdown\n   * > | <!-->\n   *         ^\n   * > | <?>\n   *       ^\n   * > | <!q>\n   *        ^\n   * > | <!--ab-->\n   *             ^\n   * > | <![CDATA[>&<]]>\n   *                   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === 45 && marker === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n    return continuation(code)\n  }\n\n  /**\n   * In closed continuation: everything we get until the eol/eof is part of it.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return continuationAfter(code)\n    }\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /**\n   * Done.\n   *\n   * ```markdown\n   * > | <!doctype>\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function continuationAfter(code) {\n    effects.exit('htmlFlow')\n    // // Feel free to interrupt.\n    // tokenizer.interrupt = false\n    // // No longer concrete.\n    // tokenizer.concrete = false\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuationStart(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * At eol, before continuation.\n   *\n   * ```markdown\n   * > | * ```js\n   *            ^\n   *   | b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * A continuation.\n   *\n   * ```markdown\n   *   | * ```js\n   * > | b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeBlankLineBefore(effects, ok, nok) {\n  return start\n\n  /**\n   * Before eol, expecting blank line.\n   *\n   * ```markdown\n   * > | <div>\n   *          ^\n   *   |\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * List of lowercase HTML “block” tag names.\n *\n * The list, when parsing HTML (flow), results in more relaxed rules (condition\n * 6).\n * Because they are known blocks, the HTML-like syntax doesn’t have to be\n * strictly parsed.\n * For tag names not in this list, a more strict algorithm (condition 7) is used\n * to detect whether the HTML-like syntax is seen as HTML (flow) or not.\n *\n * This is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * > 👉 **Note**: `search` was added in `CommonMark@0.31`.\n */\nexport const htmlBlockNames = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'search',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\n/**\n * List of lowercase HTML “raw” tag names.\n *\n * The list, when parsing HTML (flow), results in HTML that can include lines\n * without exiting, until a closing tag also in this list is found (condition\n * 1).\n *\n * This module is copied from:\n * <https://spec.commonmark.org/0.30/#html-blocks>.\n *\n * > 👉 **Note**: `textarea` was added in `CommonMark@0.30`.\n */\nexport const htmlRawNames = ['pre', 'script', 'style', 'textarea']\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code> | undefined} */\n  let marker\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n  return start\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpenInside\n    }\n    if (code === 91) {\n      effects.consume(code)\n      index = 0\n      return cdataOpenInside\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n    return nok(code)\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return nok(code)\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return comment\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentEnd\n    }\n    return comment(code)\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === 62\n      ? end(code)\n      : code === 45\n      ? commentClose(code)\n      : comment(code)\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = 'CDATA['\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === value.length ? cdata : cdataOpenInside\n    }\n    return nok(code)\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return cdata\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n    return cdata(code)\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return declaration\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return instruction\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n    return tagCloseBetween(code)\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n    return end(code)\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n    return tagOpenBetween(code)\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return lineEndingBefore(code)\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      marker = undefined\n      return tagOpenAttributeValueQuotedAfter\n    }\n    if (code === null) {\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return lineEndingBefore(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n    return nok(code)\n  }\n\n  /**\n   * At eol.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineEndingAfter\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n\n    return markdownSpace(code)\n      ? factorySpace(\n          effects,\n          lineEndingAfterPrefix,\n          'linePrefix',\n          self.parser.constructs.disable.null.includes('codeIndented')\n            ? undefined\n            : 4\n        )(code)\n      : lineEndingAfterPrefix(code)\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n}\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  while (++index < events.length) {\n    const token = events[index][1]\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number | undefined} */\n  let open\n  /** @type {number | undefined} */\n  let close\n  /** @type {Array<Event>} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n  return start\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means we’d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We can’t have that, so it’s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code)\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return after\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code)\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code)\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code)\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code)\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code)\n  }\n\n  /**\n   * Done, it’s nothing.\n   *\n   * There was an okay opening, but we didn’t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return resourceBefore\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceOpen)(code)\n      : resourceOpen(code)\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code)\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceBetween)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code)\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n    return resourceEnd(code)\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, resourceEnd)(code)\n      : resourceEnd(code)\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this\n  return referenceFull\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if there’s a `[`.\n\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return referenceCollapsedOpen\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > 👉 **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (image) start.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  /**\n   * After `!`, at `[`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * After `![`.\n   *\n   * ```markdown\n   * > | a ![b] c\n   *         ^\n   * ```\n   *\n   * This is needed in because, when GFM footnotes are enabled, images never\n   * form when started with a `^`.\n   * Instead, links form:\n   *\n   * ```markdown\n   * ![^a](b)\n   *\n   * ![^a][b]\n   *\n   * [b]: c\n   * ```\n   *\n   * ```html\n   * <p>!<a href=\\\"b\\\">^a</a></p>\n   * <p>!<a href=\\\"c\\\">^a</a></p>\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // To do: use a new field to do this, this is still needed for\n    // `micromark-extension-gfm-footnote`, but the `label-start-link`\n    // behavior isn’t.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {labelEnd} from './label-end.js'\n\n/** @type {Construct} */\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n\n  /**\n   * Start of label (link) start.\n   *\n   * ```markdown\n   * > | a [b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  /** @type {State} */\n  function after(code) {\n    // To do: this isn’t needed in `micromark-extension-gfm-footnote`,\n    // remove.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine,\n      // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined\n    // Always populated by defaults.\n\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * Start of thematic break.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('thematicBreak')\n    // To do: parse indent like `markdown-rs`.\n    return before(code)\n  }\n\n  /**\n   * After optional whitespace, at marker.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    marker = code\n    return atBreak(code)\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n    if (size >= 3 && (code === null || markdownLineEnding(code))) {\n      effects.exit('thematicBreak')\n      return ok(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   * > | ***\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n    effects.exit('thematicBreakSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, atBreak, 'whitespace')(code)\n      : atBreak(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length\n  /** @type {number | undefined} */\n  let content\n  /** @type {number | undefined} */\n  let text\n  /** @type {number | undefined} */\n  let definition\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = 'setextHeadingText'\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context])\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>} */\n  let marker\n  return start\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length\n    /** @type {boolean | undefined} */\n    let paragraph\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (\n        self.events[index][1].type !== 'lineEnding' &&\n        self.events[index][1].type !== 'linePrefix' &&\n        self.events[index][1].type !== 'content'\n      ) {\n        paragraph = self.events[index][1].type === 'paragraph'\n        break\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      marker = code\n      return before(code)\n    }\n    return nok(code)\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter('setextHeadingLineSequence')\n    return inside(code)\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return inside\n    }\n    effects.exit('setextHeadingLineSequence')\n    return markdownSpace(code)\n      ? factorySpace(effects, after, 'lineSuffix')(code)\n      : after(code)\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n    return nok(code)\n  }\n}\n","// Note: more types exposed from `index.d.ts`.\nexport {gfmStrikethroughHtml} from './lib/html.js'\nexport {gfmStrikethrough} from './lib/syntax.js'\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde.\n *\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nexport function gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n  if (single === null || single === undefined) {\n    single = true\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n            const insideSpan = context.parser.constructs.insideSpan.null\n            if (insideSpan) {\n              // Between.\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n","export {gfmTableHtml} from './lib/html.js'\nexport {gfmTable} from './lib/syntax.js'\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {EditMap} from './edit-map.js'\nimport {gfmTableAlign} from './infer.js'\n\n// To do: next major: expose functions.\n\n/**\n * Extension for `micromark` that can be passed in `extensions` to enable GFM\n * table syntax.\n *\n * @type {Extension}\n */\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolveAll: resolveTable\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  let size = 0\n  let sizeB = 0\n  /** @type {boolean | undefined} */\n  let seen\n  return start\n\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length - 1\n    while (index > -1) {\n      const type = self.events[index][1].type\n      if (\n        type === 'lineEnding' ||\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n        type === 'linePrefix'\n      )\n        index--\n      else break\n    }\n    const tail = index > -1 ? self.events[index][1].type : null\n    const next =\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\n\n    // Don’t allow lazy body rows.\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    return next(code)\n  }\n\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBefore(code) {\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n    return headRowStart(code)\n  }\n\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowStart(code) {\n    if (code === 124) {\n      return headRowBreak(code)\n    }\n\n    // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n    seen = true\n    // Count the first character, that isn’t a pipe, double.\n    sizeB += 1\n    return headRowBreak(code)\n  }\n\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBreak(code) {\n    if (code === null) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownLineEnding(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.\n      if (sizeB > 1) {\n        sizeB = 0\n        // To do: check if this works.\n        // Feel free to interrupt:\n        self.interrupt = true\n        effects.exit('tableRow')\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return headDelimiterStart\n      }\n\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n      return nok(code)\n    }\n    if (markdownSpace(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return factorySpace(effects, headRowBreak, 'whitespace')(code)\n    }\n    sizeB += 1\n    if (seen) {\n      seen = false\n      // Header cell count.\n      size += 1\n    }\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      // Whether a delimiter was seen.\n      seen = true\n      return headRowBreak\n    }\n\n    // Anything else is cell data.\n    effects.enter('data')\n    return headRowData(code)\n  }\n\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return headRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? headRowEscape : headRowData\n  }\n\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return headRowData\n    }\n    return headRowData(code)\n  }\n\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false\n\n    // Note: in `markdown-rs`, we need to handle piercing here too.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n    effects.enter('tableDelimiterRow')\n    // Track if we’ve seen a `:` or `|`.\n    seen = false\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        headDelimiterBefore,\n        'linePrefix',\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : 4\n      )(code)\n    }\n    return headDelimiterBefore(code)\n  }\n\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterBefore(code) {\n    if (code === 45 || code === 58) {\n      return headDelimiterValueBefore(code)\n    }\n    if (code === 124) {\n      seen = true\n      // If we start with a pipe, we open a cell marker.\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return headDelimiterCellBefore\n    }\n\n    // More whitespace / empty row not allowed at start.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellBefore(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterValueBefore, 'whitespace')(code)\n    }\n    return headDelimiterValueBefore(code)\n  }\n\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === 58) {\n      sizeB += 1\n      seen = true\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterLeftAlignmentAfter\n    }\n\n    // Align: none.\n    if (code === 45) {\n      sizeB += 1\n      // To do: seems weird that this *isn’t* left aligned, but that state is used?\n      return headDelimiterLeftAlignmentAfter(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      return headDelimiterCellAfter(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      return headDelimiterFiller(code)\n    }\n\n    // Anything else is not ok after the left-align colon.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterFiller(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return headDelimiterFiller\n    }\n\n    // Align is `center` if it was `left`, `right` otherwise.\n    if (code === 58) {\n      seen = true\n      effects.exit('tableDelimiterFiller')\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterRightAlignmentAfter\n    }\n    effects.exit('tableDelimiterFiller')\n    return headDelimiterRightAlignmentAfter(code)\n  }\n\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterRightAlignmentAfter(code) {\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headDelimiterCellAfter, 'whitespace')(code)\n    }\n    return headDelimiterCellAfter(code)\n  }\n\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellAfter(code) {\n    if (code === 124) {\n      return headDelimiterBefore(code)\n    }\n    if (code === null || markdownLineEnding(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (it’s a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code)\n      }\n\n      // Note: in markdown-rs`, a reset is needed here.\n      effects.exit('tableDelimiterRow')\n      effects.exit('tableHead')\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n      return ok(code)\n    }\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.\n    return nok(code)\n  }\n\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if we’re here, we’re\n    // never at whitespace.\n    effects.enter('tableRow')\n    return bodyRowBreak(code)\n  }\n\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowBreak(code) {\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return bodyRowBreak\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('tableRow')\n      return ok(code)\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, bodyRowBreak, 'whitespace')(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('data')\n    return bodyRowData(code)\n  }\n\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowData(code) {\n    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {\n      effects.exit('data')\n      return bodyRowBreak(code)\n    }\n    effects.consume(code)\n    return code === 92 ? bodyRowEscape : bodyRowData\n  }\n\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowEscape(code) {\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return bodyRowData\n    }\n    return bodyRowData(code)\n  }\n}\n\n/** @type {Resolver} */\n// eslint-disable-next-line complexity\nfunction resolveTable(events, context) {\n  let index = -1\n  let inFirstCellAwaitingPipe = true\n  /** @type {RowKind} */\n  let rowKind = 0\n  /** @type {Range} */\n  let lastCell = [0, 0, 0, 0]\n  /** @type {Range} */\n  let cell = [0, 0, 0, 0]\n  let afterHeadAwaitingFirstBodyRow = false\n  let lastTableEnd = 0\n  /** @type {Token | undefined} */\n  let currentTable\n  /** @type {Token | undefined} */\n  let currentBody\n  /** @type {Token | undefined} */\n  let currentCell\n  const map = new EditMap()\n  while (++index < events.length) {\n    const event = events[index]\n    const token = event[1]\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false\n\n        // Inject previous (body end and) table end.\n        if (lastTableEnd !== 0) {\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n          currentBody = undefined\n          lastTableEnd = 0\n        }\n\n        // Inject table start.\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        }\n        map.add(index, 0, [['enter', currentTable, context]])\n      } else if (\n        token.type === 'tableRow' ||\n        token.type === 'tableDelimiterRow'\n      ) {\n        inFirstCellAwaitingPipe = true\n        currentCell = undefined\n        lastCell = [0, 0, 0, 0]\n        cell = [0, index + 1, 0, 0]\n\n        // Inject table body start.\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          }\n          map.add(index, 0, [['enter', currentBody, context]])\n        }\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\n      }\n      // Cell data.\n      else if (\n        rowKind &&\n        (token.type === 'data' ||\n          token.type === 'tableDelimiterMarker' ||\n          token.type === 'tableDelimiterFiller')\n      ) {\n        inFirstCellAwaitingPipe = false\n\n        // First value in cell.\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n            lastCell = [0, 0, 0, 0]\n          }\n          cell[2] = index\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n          }\n          lastCell = cell\n          cell = [lastCell[1], index, 0, 0]\n        }\n      }\n    }\n    // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true\n      lastTableEnd = index\n    } else if (\n      token.type === 'tableRow' ||\n      token.type === 'tableDelimiterRow'\n    ) {\n      lastTableEnd = index\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1]\n        currentCell = flushCell(\n          map,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        )\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\n      }\n      rowKind = 0\n    } else if (\n      rowKind &&\n      (token.type === 'data' ||\n        token.type === 'tableDelimiterMarker' ||\n        token.type === 'tableDelimiterFiller')\n    ) {\n      cell[3] = index\n    }\n  }\n  if (lastTableEnd !== 0) {\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n  }\n  map.consume(context.events)\n\n  // To do: move this into `html`, when events are exposed there.\n  // That’s what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n  index = -1\n  while (++index < context.events.length) {\n    const event = context.events[index]\n    if (event[0] === 'enter' && event[1].type === 'table') {\n      event[1]._align = gfmTableAlign(context.events, index)\n    }\n  }\n  return events\n}\n\n/// Generate a cell.\n/**\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {Range} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  const groupName =\n    rowKind === 1\n      ? 'tableHeader'\n      : rowKind === 2\n      ? 'tableDelimiter'\n      : 'tableData'\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n  const valueName = 'tableContent'\n\n  // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[0] !== 0) {\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\n    map.add(range[0], 0, [['exit', previousCell, context]])\n  }\n\n  // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n  const now = getPoint(context.events, range[1])\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  }\n  map.add(range[1], 0, [['enter', previousCell, context]])\n\n  // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2])\n    const relatedEnd = getPoint(context.events, range[3])\n    /** @type {Token} */\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    }\n    map.add(range[2], 0, [['enter', valueToken, context]])\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      const start = context.events[range[2]]\n      const end = context.events[range[3]]\n      start[1].end = Object.assign({}, end[1].end)\n      start[1].type = 'chunkText'\n      start[1].contentType = 'text'\n\n      // Remove if needed.\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1\n        const b = range[3] - range[2] - 1\n        map.add(a, b, [])\n      }\n    }\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\n  }\n\n  // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two “between” parts)\n  // ```\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\n    previousCell = undefined\n  }\n  return previousCell\n}\n\n/**\n * Generate table end (and table body end).\n *\n * @param {EditMap} map\n * @param {TokenizeContext} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  const exits = []\n  const related = getPoint(context.events, index)\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related)\n    exits.push(['exit', tableBody, context])\n  }\n  table.end = Object.assign({}, related)\n  exits.push(['exit', table, context])\n  map.add(index + 1, 0, exits)\n}\n\n/**\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {readonly Point}\n */\nfunction getPoint(events, index) {\n  const event = events[index]\n  const side = event[0] === 'enter' ? 'start' : 'end'\n  return event[1][side]\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport class EditMap {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = []\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {void}\n   */\n  add(index, remove, add) {\n    addImpl(this, index, remove, add)\n  }\n\n  // To do: not used here.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {void}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImpl(this, index, remove, add, true)\n  // }\n\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {void}\n   */\n  consume(events) {\n    this.map.sort((a, b) => a[0] - b[0])\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length\n    /** @type {Array<Array<Event>>} */\n    const vecs = []\n    while (index > 0) {\n      index -= 1\n      vecs.push(events.slice(this.map[index][0] + this.map[index][1]))\n      // eslint-disable-next-line unicorn/no-array-push-push\n      vecs.push(this.map[index][2])\n\n      // Truncate rest.\n      events.length = this.map[index][0]\n    }\n    vecs.push([...events])\n    events.length = 0\n    let slice = vecs.pop()\n    while (slice) {\n      events.push(...slice)\n      slice = vecs.pop()\n    }\n\n    // Truncate everything.\n    this.map.length = 0\n  }\n}\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {void}\n */\nfunction addImpl(editMap, at, remove, add) {\n  let index = 0\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove\n\n      // To do: before not used.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add)\n      // }\n\n      return\n    }\n    index += 1\n  }\n  editMap.map.push([at, remove, add])\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       console.log('to do: links?', add, rmCurr)\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef {'left' | 'center' | 'right' | 'none'} Align\n */\n\n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Array<Event>} events\n * @param {number} index\n * @returns {Array<Align>}\n */\nexport function gfmTableAlign(events, index) {\n  let inDelimiterRow = false\n  /** @type {Array<Align>} */\n  const align = []\n  while (index < events.length) {\n    const event = events[index]\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(\n            events[index + 1][1].type === 'tableDelimiterMarker'\n              ? 'left'\n              : 'none'\n          )\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true\n    }\n    index += 1\n  }\n  return align\n}\n","export {gfmTaskListItemHtml} from './lib/html.js'\nexport {gfmTaskListItem} from './lib/syntax.js'\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace')\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('./lib/index.js').Options} Options\n */\n\nexport {gfmFromMarkdown, gfmToMarkdown} from './lib/index.js'\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * @typedef {import('mdast-util-gfm-table').Options} Options\n *   Configuration.\n */\n\nimport {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from 'mdast-util-gfm-autolink-literal'\nimport {\n  gfmFootnoteFromMarkdown,\n  gfmFootnoteToMarkdown\n} from 'mdast-util-gfm-footnote'\nimport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from 'mdast-util-gfm-strikethrough'\nimport {gfmTableFromMarkdown, gfmTableToMarkdown} from 'mdast-util-gfm-table'\nimport {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from 'mdast-util-gfm-task-list-item'\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown,\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown,\n    gfmTableFromMarkdown,\n    gfmTaskListItemFromMarkdown\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nexport function gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown,\n      gfmFootnoteToMarkdown(),\n      gfmStrikethroughToMarkdown,\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown\n    ]\n  }\n}\n","export {\n  gfmAutolinkLiteralFromMarkdown,\n  gfmAutolinkLiteralToMarkdown\n} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject\n */\n\nimport {ccount} from 'ccount'\nimport {findAndReplace} from 'mdast-util-find-and-replace'\nimport {unicodePunctuation, unicodeWhitespace} from 'micromark-util-character'\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n// To do: next major: expose functions instead of extensions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmAutolinkLiteralFromMarkdown = {\n  transforms: [transformGfmAutolinkLiterals],\n  enter: {\n    literalAutolink: enterLiteralAutolink,\n    literalAutolinkEmail: enterLiteralAutolinkValue,\n    literalAutolinkHttp: enterLiteralAutolinkValue,\n    literalAutolinkWww: enterLiteralAutolinkValue\n  },\n  exit: {\n    literalAutolink: exitLiteralAutolink,\n    literalAutolinkEmail: exitLiteralAutolinkEmail,\n    literalAutolinkHttp: exitLiteralAutolinkHttp,\n    literalAutolinkWww: exitLiteralAutolinkWww\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmAutolinkLiteralToMarkdown = {\n  unsafe: [\n    {\n      character: '@',\n      before: '[+\\\\-.\\\\w]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {\n      character: '.',\n      before: '[Ww]',\n      after: '[\\\\-.\\\\w]',\n      inConstruct,\n      notInConstruct\n    },\n    {character: ':', before: '[ps]', after: '\\\\/', inConstruct, notInConstruct}\n  ]\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = /** @type {Link} */ (this.stack[this.stack.length - 1])\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/g, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Link | Array<PhrasingContent> | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = ccount(url, '(')\n  let closingParens = ccount(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('./lib/index.js').Options} Options\n * @typedef {import('./lib/index.js').RegExpMatchObject} RegExpMatchObject\n * @typedef {import('./lib/index.js').Find} Find\n * @typedef {import('./lib/index.js').Replace} Replace\n * @typedef {import('./lib/index.js').ReplaceFunction} ReplaceFunction\n * @typedef {import('./lib/index.js').FindAndReplaceTuple} FindAndReplaceTuple\n * @typedef {import('./lib/index.js').FindAndReplaceSchema} FindAndReplaceSchema\n * @typedef {import('./lib/index.js').FindAndReplaceList} FindAndReplaceList\n */\n\nexport {findAndReplace} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      // To do next major: don’t return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesn’t understand but it’s perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasn’t a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","// Note: types exported from `index.d.ts`\nexport {CONTINUE, EXIT, SKIP, visitParents} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('./lib/index.js').Test} Test\n * @typedef {import('./lib/index.js').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('./lib/index.js').AssertAnything} AssertAnything\n */\n\n/**\n * @template {import('unist').Node} Kind\n * @typedef {import('./lib/index.js').PredicateTest<Kind>} PredicateTest\n */\n\n/**\n * @template {import('unist').Node} Kind\n * @typedef {import('./lib/index.js').TestFunctionPredicate<Kind>} TestFunctionPredicate\n */\n\n/**\n * @template {import('unist').Node} Kind\n * @typedef {import('./lib/index.js').AssertPredicate<Kind>} AssertPredicate\n */\n\nexport {is, convert} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","// Note: extra types exported from `index.d.ts`.\nexport {gfmFootnoteFromMarkdown, gfmFootnoteToMarkdown} from './lib/index.js'\n","/**\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Map} Map\n */\n\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {association} from 'mdast-util-to-markdown/lib/util/association.js'\nimport {containerFlow} from 'mdast-util-to-markdown/lib/util/container-flow.js'\nimport {indentLines} from 'mdast-util-to-markdown/lib/util/indent-lines.js'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\nfootnoteReference.peek = footnoteReferencePeek\n\n// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use\n// utilities on `state`.\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteDefinition: enterFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteCallString: enterFootnoteCallString\n    },\n    exit: {\n      gfmFootnoteDefinition: exitFootnoteDefinition,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteCallString: exitFootnoteCallString\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function gfmFootnoteToMarkdown() {\n  return {\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],\n    handlers: {footnoteDefinition, footnoteReference}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = /** @type {FootnoteDefinition} */ (\n    this.stack[this.stack.length - 1]\n  )\n  node.label = label\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteReference')\n  const subexit = context.enter('reference')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteDefinition} node\n */\nfunction footnoteDefinition(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  let value = tracker.move('[^')\n  const exit = context.enter('footnoteDefinition')\n  const subexit = context.enter('label')\n  value += tracker.move(\n    safe(context, association(node), {\n      ...tracker.current(),\n      before: value,\n      after: ']'\n    })\n  )\n  subexit()\n  value += tracker.move(\n    ']:' + (node.children && node.children.length > 0 ? ' ' : '')\n  )\n  tracker.shift(4)\n  value += tracker.move(\n    indentLines(containerFlow(node, context, tracker.current()), map)\n  )\n  exit()\n\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, index, blank) {\n  if (index === 0) {\n    return line\n  }\n\n  return (blank ? '' : '    ') + line\n}\n","/**\n * @typedef {import('../types.js').AssociationId} AssociationId\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","import {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nconst characterEscapeOrReference =\n  /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n/**\n * Decode markdown strings (which occur in places such as fenced code info\n * strings, destinations, labels, and titles).\n *\n * The “string” content type allows character escapes and -references.\n * This decodes those.\n *\n * @param {string} value\n *   Value to decode.\n * @returns {string}\n *   Decoded value.\n */\nexport function decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @param {string} $2\n * @returns {string}\n */\nfunction decode($0, $1, $2) {\n  if ($1) {\n    // Escape.\n    return $1\n  }\n\n  // Reference.\n  const head = $2.charCodeAt(0)\n  if (head === 35) {\n    const head = $2.charCodeAt(1)\n    const hex = head === 120 || head === 88\n    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)\n  }\n  return decodeNamedCharacterReference($2) || $0\n}\n","/**\n * Turn the number (in string form as either hexa- or plain decimal) coming from\n * a numeric character reference into a character.\n *\n * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes\n * non-characters and control characters safe.\n *\n * @param {string} value\n *   Value to decode.\n * @param {number} base\n *   Numeric base.\n * @returns {string}\n *   Character.\n */\nexport function decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base)\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) ||\n    // Control character (DEL) of C0, and C1 controls.\n    (code > 126 && code < 160) ||\n    // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) ||\n    // Noncharacters.\n    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||\n    // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n  return String.fromCharCode(code)\n}\n","/**\n * @typedef {import('../types.js').FlowContent} FlowContent\n * @typedef {import('../types.js').Node} Node\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').TrackFields} TrackFields\n */\n\n/**\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {Node} left\n * @param {Node} right\n * @param {Parent} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @typedef {import('../types.js').IndentLines} IndentLines\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').SafeConfig} SafeConfig\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n * @typedef {import('../types.js').ConstructName} ConstructName\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').CreateTracker} CreateTracker\n * @typedef {import('../types.js').TrackCurrent} TrackCurrent\n * @typedef {import('../types.js').TrackMove} TrackMove\n * @typedef {import('../types.js').TrackShift} TrackShift\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","// Note: extra types in `index.d.ts`.\nexport {\n  gfmStrikethroughFromMarkdown,\n  gfmStrikethroughToMarkdown\n} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {strikethrough: enterStrikethrough},\n  exit: {strikethrough: exitStrikethrough}\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [\n    {\n      character: '~',\n      inConstruct: 'phrasing',\n      notInConstruct: constructsWithoutStrikethrough\n    }\n  ],\n  handlers: {delete: handleDelete}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions)\n  const exit = context.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n","/**\n * @typedef {import('../types.js').Handle} Handle\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').PhrasingContent} PhrasingContent\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          ...tracker.current(),\n          before,\n          after\n        })\n      )\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","// Note: types exposed from `index.d.ts`.\nexport {gfmTableFromMarkdown, gfmTableToMarkdown} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').InlineCode} InlineCode\n *\n * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext\n * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells.\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters.\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells\n */\n\nimport {containerPhrasing} from 'mdast-util-to-markdown/lib/util/container-phrasing.js'\nimport {inlineCode} from 'mdast-util-to-markdown/lib/handle/inline-code.js'\nimport {markdownTable} from 'markdown-table'\n\n// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.\n// To do: next major: use `defaultHandlers.inlineCode`.\n// To do: next major: expose functions.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM tables.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTableFromMarkdown = {\n  enter: {\n    table: enterTable,\n    tableData: enterCell,\n    tableHeader: enterCell,\n    tableRow: enterRow\n  },\n  exit: {\n    codeText: exitCodeText,\n    table: exitTable,\n    tableData: exit,\n    tableHeader: exit,\n    tableRow: exit\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */\n  // @ts-expect-error: `align` is custom.\n  const align = token._align\n  this.enter(\n    {\n      type: 'table',\n      align: align.map((d) => (d === 'none' ? null : d)),\n      children: []\n    },\n    token\n  )\n  this.setData('inTable', true)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1])\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes don’t (but can’t escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nexport function gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, context, safeOptions) {\n    return serializeData(\n      handleTableAsData(node, context, safeOptions),\n      node.align\n    )\n  }\n\n  /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, context, safeOptions) {\n    const row = handleTableRowAsData(node, context, safeOptions)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, context, safeOptions) {\n    const exit = context.enter('tableCell')\n    const subexit = context.enter('phrasing')\n    const value = containerPhrasing(node, context, {\n      ...safeOptions,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = context.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(\n        children[index],\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {ToMarkdownContext} context\n   * @param {SafeOptions} safeOptions\n   */\n  function handleTableRowAsData(node, context, safeOptions) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = context.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(\n        children[index],\n        node,\n        context,\n        safeOptions\n      )\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, context) {\n    let value = inlineCode(node, parent, context)\n\n    if (context.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {patternCompile} from '../util/pattern-compile.js'\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nexport function inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n","/**\n * @typedef Options\n *   Configuration (optional).\n * @property {string|null|ReadonlyArray<string|null|undefined>} [align]\n *   One style for all columns, or styles for their respective columns.\n *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).\n *   Other values are treated as `''`, which doesn’t place the colon in the\n *   alignment row but does align left.\n *   *Only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean} [padding=true]\n *   Whether to add a space of padding between delimiters and cells.\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {boolean} [delimiterStart=true]\n *   Whether to begin each row with the delimiter.\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean} [delimiterEnd=true]\n *   Whether to end each row with the delimiter.\n *\n *   > 👉 **Note**: please don’t use this: it could create fragile structures\n *   > that aren’t understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean} [alignDelimiters=true]\n *   Whether to align the delimiters.\n *   By default, they are aligned:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {(value: string) => number} [stringLength]\n *   Function to detect the length of table cell content.\n *   This is used when aligning the delimiters (`|`) between table cells.\n *   Full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source.\n *   To fix this, you can pass this function, which receives the cell content\n *   and returns its “visible” size.\n *   Note that what is and isn’t visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['中文', 'Charlie'],\n *     ['👩‍❤️‍👩', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | 中文 | Charlie |\n *   | 👩‍❤️‍👩 | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['中文', 'Charlie'],\n *       ['👩‍❤️‍👩', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | 中文  | Charlie |\n *   | 👩‍❤️‍👩    | Delta   |\n *   ```\n */\n\n/**\n * @typedef {Options} MarkdownTableOptions\n * @todo\n *   Remove next major.\n */\n\n/**\n * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..\n *\n * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table\n *   Table data (matrix of strings).\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n */\nexport function markdownTable(table, options = {}) {\n  const align = (options.align || []).concat()\n  const stringLength = options.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (options.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      options.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (options.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (options.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (options.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        options.padding !== false &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(options.alignDelimiters === false && cell === '') &&\n        (options.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (options.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (options.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (options.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        options.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      options.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string|null|undefined} [value]\n * @returns {string}\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string} value\n * @returns {number}\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * @param {string|null|undefined} value\n * @returns {number}\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n    ? 108 /* `l` */\n    : code === 82 /* `R` */ || code === 114 /* `r` */\n    ? 114 /* `r` */\n    : 0\n}\n","export {\n  gfmTaskListItemFromMarkdown,\n  gfmTaskListItemToMarkdown\n} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n/**\n * @typedef {Extract<Root | Content, Parent>} Parents\n */\n\nimport {listItem} from 'mdast-util-to-markdown/lib/handle/list-item.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use\n// `track` from `state`.\n// To do: next major: replace exports with functions.\n// To do: next major: use `defaulthandlers.listItem`.\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM task list items.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmTaskListItemFromMarkdown = {\n  exit: {\n    taskListCheckValueChecked: exitCheck,\n    taskListCheckValueUnchecked: exitCheck,\n    paragraph: exitParagraphWithTaskListItem\n  }\n}\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM task list items.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmTaskListItemToMarkdown = {\n  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n  handlers: {listItem: listItemWithTaskListItem}\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2])\n  // We’re always in a paragraph, in a list item.\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2])\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1])\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, context, safeOptions) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = track(safeOptions)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = listItem(node, parent, context, {\n    ...safeOptions,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n","/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('../types.js').Map} Map\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkListItemIndent} from '../util/check-list-item-indent.js'\n\n/**\n * @param {ListItem} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state)\n  let bullet = state.bulletCurrent || checkBullet(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nexport function checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'tab'\n\n  // To do: remove in a major.\n  // @ts-expect-error: deprecated.\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","import remarkParse from './lib/index.js'\n\nexport default remarkParse\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-from-markdown').Options} Options\n */\n\nimport {fromMarkdown} from 'mdast-util-from-markdown'\n\n/** @type {import('unified').Plugin<[Options?] | void[], string, Root>} */\nexport default function remarkParse(options) {\n  /** @type {import('unified').ParserFunction<Root>} */\n  const parser = (doc) => {\n    // Assume options.\n    const settings = /** @type {Options} */ (this.data('settings'))\n\n    return fromMarkdown(\n      doc,\n      Object.assign({}, settings, options, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data('micromarkExtensions') || [],\n        mdastExtensions: this.data('fromMarkdownExtensions') || []\n      })\n    )\n  }\n\n  Object.assign(this, {Parser: parser})\n}\n","// Note: types exported from `index.d.ts`.\nexport {fromMarkdown} from './lib/index.js'\n","/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Root | Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n *\n * @typedef {Omit<UnistParent, 'type' | 'children'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | undefined | null | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {void}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isn’t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Node | Fragment>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {<Key extends keyof CompileData>(key: Key) => CompileData[Key]} getData\n *   Get data from the key/value store.\n * @property {<Key extends keyof CompileData>(key: Key, value?: CompileData[Key]) => void} setData\n *   Set data into the key/value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<Kind extends Node>(this: CompileContext, node: Kind, token: Token, onError?: OnEnterError) => Kind} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\n// To do: micromark: create a registry of tokens?\n// To do: next major: don’t return given `Node` from `enter`.\n// To do: next major: remove setter/getter.\n\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n\n/**\n * @param value\n *   Markdown to parse.\n * @param encoding\n *   Character encoding for when `value` is `Buffer`.\n * @param options\n *   Configuration.\n * @returns\n *   mdast tree.\n */\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  }\n  configure(config, (options || {}).mdastExtensions || [])\n\n  /** @type {CompileData} */\n  const data = {}\n  return compile\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    /** @type {Array<number>} */\n    const listStack = []\n    let index = -1\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n    index = -1\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n\n    // Call transforms.\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n    return tree\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token | undefined} */\n    let listItem\n    /** @type {number | undefined} */\n    let lineIndex\n    /** @type {number | undefined} */\n    let firstBlankLineIndex\n    /** @type {boolean | undefined} */\n    let atMarker\n    while (++index <= length) {\n      const event = events[index]\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: we’ll add `end` in a second.\n            end: undefined\n          }\n          // @ts-expect-error: `listItem` is most definitely defined, TS...\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  /**\n   * Set data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @param {CompileData[Key]} [value]\n   *   New value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  /**\n   * Get data.\n   *\n   * @template {keyof CompileData} Key\n   *   Field type.\n   * @param {Key} key\n   *   Key of field.\n   * @returns {CompileData[Key]}\n   *   Value.\n   */\n  function getData(key) {\n    return data[key]\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Node} create\n   *   Create a node.\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {void}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n\n  /**\n   * @template {Node} Kind\n   *   Node type.\n   * @this {CompileContext}\n   *   Context.\n   * @param {Kind} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {Kind}\n   *   The given node.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler])\n    // @ts-expect-error: `end` will be patched later.\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {Node}\n   *   The closed node.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n    node.position.end = point(token.end)\n    return node\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor = this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1]\n    let tail = node.children[node.children.length - 1]\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      // @ts-expect-error: we’ll add `end` later.\n      tail.position = {\n        start: point(token.start)\n      }\n      // @ts-expect-error: Assume `parent` accepts `text`.\n      node.children.push(tail)\n    }\n    this.stack.push(tail)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.value = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1]\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n    // To do: clean.\n    if (getData('inReference')) {\n      /** @type {ReferenceType} */\n      const referenceType = getData('referenceType') || 'shortcut'\n      node.type += 'Reference'\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType\n      // @ts-expect-error: mutate.\n      delete node.url\n      delete node.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier\n      // @ts-expect-error: mutate.\n      delete node.label\n    }\n    setData('referenceType')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token)\n    const ancestor = this.stack[this.stack.length - 2]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string)\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // Assume a reference.\n    setData('inReference', true)\n    if (node.type === 'link') {\n      /** @type {Array<StaticPhrasingContent>} */\n      // @ts-expect-error: Assume static phrasing content.\n      const children = fragment.children\n      node.children = children\n    } else {\n      node.alt = value\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.url = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    node.title = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n    let value\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      const result = decodeNamedCharacterReference(data)\n      value = result\n    }\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node = this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n\n  /** @returns {HTML} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Extension | Array<Extension>>} extensions\n * @returns {void}\n */\nfunction configure(combined, extensions) {\n  let index = -1\n  while (++index < extensions.length) {\n    const value = extensions[index]\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {void}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      if (key === 'canContainEols') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'transforms') {\n        const right = extension[key]\n        if (right) {\n          combined[key].push(...right)\n        }\n      } else if (key === 'enter' || key === 'exit') {\n        const right = extension[key]\n        if (right) {\n          Object.assign(combined[key], right)\n        }\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n","/**\n * @typedef {import('./lib/index.js').Options} Options\n */\n\nexport {toString} from './lib/index.js'\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [includeImageAlt=true]\n *   Whether to use `alt` for `image`s.\n * @property {boolean | null | undefined} [includeHtml=true]\n *   Whether to use `value` of HTML.\n */\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Get the text content of a node or list of nodes.\n *\n * Prefers the node’s plain-text fields, otherwise serializes its children,\n * and if the given value is an array, serialize the nodes in it.\n *\n * @param {unknown} value\n *   Thing to serialize, typically `Node`.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `value`.\n */\nexport function toString(value, options) {\n  const settings = options || emptyOptions\n  const includeImageAlt =\n    typeof settings.includeImageAlt === 'boolean'\n      ? settings.includeImageAlt\n      : true\n  const includeHtml =\n    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true\n\n  return one(value, includeImageAlt, includeHtml)\n}\n\n/**\n * One node or several nodes.\n *\n * @param {unknown} value\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized node.\n */\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if ('value' in value) {\n      return value.type === 'html' && !includeHtml ? '' : value.value\n    }\n\n    if (includeImageAlt && 'alt' in value && value.alt) {\n      return value.alt\n    }\n\n    if ('children' in value) {\n      return all(value.children, includeImageAlt, includeHtml)\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml)\n  }\n\n  return ''\n}\n\n/**\n * Serialize a list of nodes.\n *\n * @param {Array<unknown>} values\n *   Thing to serialize.\n * @param {boolean} includeImageAlt\n *   Include image `alt`s.\n * @param {boolean} includeHtml\n *   Include HTML.\n * @returns {string}\n *   Serialized nodes.\n */\nfunction all(values, includeImageAlt, includeHtml) {\n  /** @type {Array<string>} */\n  const result = []\n  let index = -1\n\n  while (++index < values.length) {\n    result[index] = one(values[index], includeImageAlt, includeHtml)\n  }\n\n  return result.join('')\n}\n\n/**\n * Check if `value` looks like a node.\n *\n * @param {unknown} value\n *   Thing.\n * @returns {value is Node}\n *   Whether `value` is a node.\n */\nfunction node(value) {\n  return Boolean(value && typeof value === 'object')\n}\n","/**\n * @typedef {import('micromark-util-types').Create} Create\n * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n */\n\nimport {combineExtensions} from 'micromark-util-combine-extensions'\nimport {content} from './initialize/content.js'\nimport {document} from './initialize/document.js'\nimport {flow} from './initialize/flow.js'\nimport {text, string} from './initialize/text.js'\nimport {createTokenizer} from './create-tokenizer.js'\nimport * as defaultConstructs from './constructs.js'\n\n/**\n * @param {ParseOptions | null | undefined} [options]\n * @returns {ParseContext}\n */\nexport function parse(options) {\n  const settings = options || {}\n  const constructs =\n    /** @type {FullNormalizedExtension} */\n    combineExtensions([defaultConstructs, ...(settings.extensions || [])])\n\n  /** @type {ParseContext} */\n  const parser = {\n    defined: [],\n    lazy: {},\n    constructs,\n    content: create(content),\n    document: create(document),\n    flow: create(flow),\n    string: create(string),\n    text: create(text)\n  }\n  return parser\n\n  /**\n   * @param {InitialConstruct} initial\n   */\n  function create(initial) {\n    return creator\n    /** @type {Create} */\n    function creator(from) {\n      return createTokenizer(parser, initial, from)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {InitialConstruct} */\nexport const content = {\n  tokenize: initializeContent\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Initializer}\n */\nfunction initializeContent(effects) {\n  const contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  /** @type {Token} */\n  let previous\n  return contentStart\n\n  /** @type {State} */\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, contentStart, 'linePrefix')\n  }\n\n  /** @type {State} */\n  function paragraphInitial(code) {\n    effects.enter('paragraph')\n    return lineStart(code)\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    const token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous\n    })\n    if (previous) {\n      previous.next = token\n    }\n    previous = token\n    return data(code)\n  }\n\n  /** @type {State} */\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText')\n      effects.exit('paragraph')\n      effects.consume(code)\n      return\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit('chunkText')\n      return lineStart\n    }\n\n    // Data.\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\n/**\n * @typedef {[Construct, ContainerState]} StackItem\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n/** @type {InitialConstruct} */\nexport const document = {\n  tokenize: initializeDocument\n}\n\n/** @type {Construct} */\nconst containerConstruct = {\n  tokenize: tokenizeContainer\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Initializer}\n */\nfunction initializeDocument(effects) {\n  const self = this\n  /** @type {Array<StackItem>} */\n  const stack = []\n  let continued = 0\n  /** @type {TokenizeContext | undefined} */\n  let childFlow\n  /** @type {Token | undefined} */\n  let childToken\n  /** @type {number} */\n  let lineStartOffset\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // First we iterate through the open blocks, starting with the root\n    // document, and descending through last children down to the last open\n    // block.\n    // Each block imposes a condition that the line must satisfy if the block is\n    // to remain open.\n    // For example, a block quote requires a `>` character.\n    // A paragraph requires a non-blank line.\n    // In this phase we may match all or just some of the open blocks.\n    // But we cannot close unmatched blocks yet, because we may have a lazy\n    // continuation line.\n    if (continued < stack.length) {\n      const item = stack[continued]\n      self.containerState = item[1]\n      return effects.attempt(\n        item[0].continuation,\n        documentContinue,\n        checkNewContainers\n      )(code)\n    }\n\n    // Done.\n    return checkNewContainers(code)\n  }\n\n  /** @type {State} */\n  function documentContinue(code) {\n    continued++\n\n    // Note: this field is called `_closeFlow` but it also closes containers.\n    // Perhaps a good idea to rename it but it’s already used in the wild by\n    // extensions.\n    if (self.containerState._closeFlow) {\n      self.containerState._closeFlow = undefined\n      if (childFlow) {\n        closeFlow()\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when dealing with lazy lines in `writeToChild`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the flow chunk.\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          point = self.events[indexBeforeFlow][1].end\n          break\n        }\n      }\n      exitContainers(continued)\n\n      // Fix positions.\n      let index = indexBeforeExits\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n      return checkNewContainers(code)\n    }\n    return start(code)\n  }\n\n  /** @type {State} */\n  function checkNewContainers(code) {\n    // Next, after consuming the continuation markers for existing blocks, we\n    // look for new block starts (e.g. `>` for a block quote).\n    // If we encounter a new block start, we close any blocks unmatched in\n    // step 1 before creating the new block as a child of the last matched\n    // block.\n    if (continued === stack.length) {\n      // No need to `check` whether there’s a container, of `exitContainers`\n      // would be moot.\n      // We can instead immediately `attempt` to parse one.\n      if (!childFlow) {\n        return documentContinued(code)\n      }\n\n      // If we have concrete content, such as block HTML or fenced code,\n      // we can’t have containers “pierce” into them, so we can immediately\n      // start.\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        return flowStart(code)\n      }\n\n      // If we do have flow, it could still be a blank line,\n      // but we’d be interrupting it w/ a new container if there’s a current\n      // construct.\n      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer\n      // needed in micromark-extension-gfm-table@1.0.6).\n      self.interrupt = Boolean(\n        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack\n      )\n    }\n\n    // Check if there is a new container.\n    self.containerState = {}\n    return effects.check(\n      containerConstruct,\n      thereIsANewContainer,\n      thereIsNoNewContainer\n    )(code)\n  }\n\n  /** @type {State} */\n  function thereIsANewContainer(code) {\n    if (childFlow) closeFlow()\n    exitContainers(continued)\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function thereIsNoNewContainer(code) {\n    self.parser.lazy[self.now().line] = continued !== stack.length\n    lineStartOffset = self.now().offset\n    return flowStart(code)\n  }\n\n  /** @type {State} */\n  function documentContinued(code) {\n    // Try new containers.\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  /** @type {State} */\n  function containerContinue(code) {\n    continued++\n    stack.push([self.currentConstruct, self.containerState])\n    // Try another.\n    return documentContinued(code)\n  }\n\n  /** @type {State} */\n  function flowStart(code) {\n    if (code === null) {\n      if (childFlow) closeFlow()\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n\n  /** @type {State} */\n  function flowContinue(code) {\n    if (code === null) {\n      writeToChild(effects.exit('chunkFlow'), true)\n      exitContainers(0)\n      effects.consume(code)\n      return\n    }\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      writeToChild(effects.exit('chunkFlow'))\n      // Get ready for the next line.\n      continued = 0\n      self.interrupt = undefined\n      return start\n    }\n    effects.consume(code)\n    return flowContinue\n  }\n\n  /**\n   * @param {Token} token\n   * @param {boolean | undefined} [eof]\n   * @returns {void}\n   */\n  function writeToChild(token, eof) {\n    const stream = self.sliceStream(token)\n    if (eof) stream.push(null)\n    token.previous = childToken\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.defineSkip(token.start)\n    childFlow.write(stream)\n\n    // Alright, so we just added a lazy line:\n    //\n    // ```markdown\n    // > a\n    // b.\n    //\n    // Or:\n    //\n    // > ~~~c\n    // d\n    //\n    // Or:\n    //\n    // > | e |\n    // f\n    // ```\n    //\n    // The construct in the second example (fenced code) does not accept lazy\n    // lines, so it marked itself as done at the end of its first line, and\n    // then the content construct parses `d`.\n    // Most constructs in markdown match on the first line: if the first line\n    // forms a construct, a non-lazy line can’t “unmake” it.\n    //\n    // The construct in the third example is potentially a GFM table, and\n    // those are *weird*.\n    // It *could* be a table, from the first line, if the following line\n    // matches a condition.\n    // In this case, that second line is lazy, which “unmakes” the first line\n    // and turns the whole into one content block.\n    //\n    // We’ve now parsed the non-lazy and the lazy line, and can figure out\n    // whether the lazy line started a new flow block.\n    // If it did, we exit the current containers between the two flow blocks.\n    if (self.parser.lazy[token.start.line]) {\n      let index = childFlow.events.length\n      while (index--) {\n        if (\n          // The token starts before the line ending…\n          childFlow.events[index][1].start.offset < lineStartOffset &&\n          // …and either is not ended yet…\n          (!childFlow.events[index][1].end ||\n            // …or ends after it.\n            childFlow.events[index][1].end.offset > lineStartOffset)\n        ) {\n          // Exit: there’s still something open, which means it’s a lazy line\n          // part of something.\n          return\n        }\n      }\n\n      // Note: this algorithm for moving events around is similar to the\n      // algorithm when closing flow in `documentContinue`.\n      const indexBeforeExits = self.events.length\n      let indexBeforeFlow = indexBeforeExits\n      /** @type {boolean | undefined} */\n      let seen\n      /** @type {Point | undefined} */\n      let point\n\n      // Find the previous chunk (the one before the lazy line).\n      while (indexBeforeFlow--) {\n        if (\n          self.events[indexBeforeFlow][0] === 'exit' &&\n          self.events[indexBeforeFlow][1].type === 'chunkFlow'\n        ) {\n          if (seen) {\n            point = self.events[indexBeforeFlow][1].end\n            break\n          }\n          seen = true\n        }\n      }\n      exitContainers(continued)\n\n      // Fix positions.\n      index = indexBeforeExits\n      while (index < self.events.length) {\n        self.events[index][1].end = Object.assign({}, point)\n        index++\n      }\n\n      // Inject the exits earlier (they’re still also at the end).\n      splice(\n        self.events,\n        indexBeforeFlow + 1,\n        0,\n        self.events.slice(indexBeforeExits)\n      )\n\n      // Discard the duplicate exits.\n      self.events.length = index\n    }\n  }\n\n  /**\n   * @param {number} size\n   * @returns {void}\n   */\n  function exitContainers(size) {\n    let index = stack.length\n\n    // Exit open containers.\n    while (index-- > size) {\n      const entry = stack[index]\n      self.containerState = entry[1]\n      entry[0].exit.call(self, effects)\n    }\n    stack.length = size\n  }\n  function closeFlow() {\n    childFlow.write([null])\n    childToken = undefined\n    childFlow = undefined\n    self.containerState._closeFlow = undefined\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeContainer(effects, ok, nok) {\n  // Always populated by defaults.\n\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n","/**\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\nimport {blankLine, content} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {InitialConstruct} */\nexport const flow = {\n  tokenize: initializeFlow\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Initializer}\n */\nfunction initializeFlow(effects) {\n  const self = this\n  const initial = effects.attempt(\n    // Try to parse a blank line.\n    blankLine,\n    atBlankEnding,\n    // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        'linePrefix'\n      )\n    )\n  )\n  return initial\n\n  /** @type {State} */\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    self.currentConstruct = undefined\n    return initial\n  }\n\n  /** @type {State} */\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n\n/**\n * @param {'string' | 'text'} field\n * @returns {InitialConstruct}\n */\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n      const list = constructs[code]\n      let index = -1\n      if (list) {\n        // Always populated by defaults.\n\n        while (++index < list.length) {\n          const item = list[index]\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n      return false\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n * @returns {Resolver}\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number | undefined} */\n    let enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n        enter = undefined\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean | undefined} */\n      let tabs\n      while (index--) {\n        const chunk = chunks[index]\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n      eventIndex++\n    }\n  }\n  return events\n}\n","/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * @callback Restore\n * @returns {void}\n *\n * @typedef Info\n * @property {Restore} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {void}\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n  let chunks = []\n  /** @type {Array<Token>} */\n  let stack = []\n  /** @type {boolean | undefined} */\n  let consumed = true\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n\n  /**\n   * The state function.\n   *\n   * @type {State | void}\n   */\n  let state = initialize.tokenize.call(context, effects)\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n  return context\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main()\n\n    // Exit if we’re not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n    addResult(initialize, 0)\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {line, column, offset, _index, _bufferIndex} = point\n    return {\n      line,\n      column,\n      offset,\n      _index,\n      _bufferIndex\n    }\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {void}\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index]\n\n      // If we’re in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {void}\n   */\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++\n\n      // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code\n\n    // Mark as consumed.\n    consumed = true\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   */\n  function constructFactory(onreturn, fields) {\n    return hook\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | Construct | ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State | undefined} [bogusState]\n     * @returns {State}\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n      let constructIndex\n      /** @type {Construct} */\n      let currentConstruct\n      /** @type {Info} */\n      let info\n      return Array.isArray(constructs) /* c8 ignore next 1 */\n        ? handleListOfConstructs(constructs)\n        : 'tokenize' in constructs\n        ? // @ts-expect-error Looks like a construct.\n          handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n      function handleMapOfConstructs(map) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        if (list.length === 0) {\n          return bogusState\n        }\n        return handleConstruct(list[constructIndex])\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n      function handleConstruct(construct) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          // Always populated by defaults.\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a “live binding”, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        consumed = true\n        info.restore()\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n        return bogusState\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {void}\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n\n    /**\n     * Restore state.\n     *\n     * @returns {void}\n     */\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {void}\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'end' | 'start'>} token\n * @returns {Array<Chunk>}\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n  let view\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n    if (startBufferIndex > -1) {\n      const head = view[0]\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex)\n      } else {\n        view.shift()\n      }\n    }\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n  return view\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean | undefined} [expandTabs=false]\n * @returns {string}\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n        case -4: {\n          value = '\\n'\n          break\n        }\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n    atTab = chunk === -2\n    result.push(value)\n  }\n  return result.join('')\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n */\n\nimport {\n  attention,\n  autolink,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  list,\n  setextUnderline,\n  thematicBreak\n} from 'micromark-core-commonmark'\nimport {resolver as resolveText} from './initialize/text.js'\n\n/** @satisfies {Extension['document']} */\nexport const document = {\n  [42]: list,\n  [43]: list,\n  [45]: list,\n  [48]: list,\n  [49]: list,\n  [50]: list,\n  [51]: list,\n  [52]: list,\n  [53]: list,\n  [54]: list,\n  [55]: list,\n  [56]: list,\n  [57]: list,\n  [62]: blockQuote\n}\n\n/** @satisfies {Extension['contentInitial']} */\nexport const contentInitial = {\n  [91]: definition\n}\n\n/** @satisfies {Extension['flowInitial']} */\nexport const flowInitial = {\n  [-2]: codeIndented,\n  [-1]: codeIndented,\n  [32]: codeIndented\n}\n\n/** @satisfies {Extension['flow']} */\nexport const flow = {\n  [35]: headingAtx,\n  [42]: thematicBreak,\n  [45]: [setextUnderline, thematicBreak],\n  [60]: htmlFlow,\n  [61]: setextUnderline,\n  [95]: thematicBreak,\n  [96]: codeFenced,\n  [126]: codeFenced\n}\n\n/** @satisfies {Extension['string']} */\nexport const string = {\n  [38]: characterReference,\n  [92]: characterEscape\n}\n\n/** @satisfies {Extension['text']} */\nexport const text = {\n  [-5]: lineEnding,\n  [-4]: lineEnding,\n  [-3]: lineEnding,\n  [33]: labelStartImage,\n  [38]: characterReference,\n  [42]: attention,\n  [60]: [autolink, htmlText],\n  [91]: labelStartLink,\n  [92]: [hardBreakEscape, characterEscape],\n  [93]: labelEnd,\n  [95]: attention,\n  [96]: codeText\n}\n\n/** @satisfies {Extension['insideSpan']} */\nexport const insideSpan = {\n  null: [attention, resolveText]\n}\n\n/** @satisfies {Extension['attentionMarkers']} */\nexport const attentionMarkers = {\n  null: [42, 95]\n}\n\n/** @satisfies {Extension['disable']} */\nexport const disable = {\n  null: []\n}\n","/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {boolean | null | undefined} [end=false]\n * @returns {Array<Chunk>}\n */\n\nconst search = /[\\0\\t\\n\\r]/g\n\n/**\n * @returns {Preprocessor}\n */\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean | undefined} */\n  let start = true\n  /** @type {boolean | undefined} */\n  let atCarriageReturn\n  return preprocessor\n\n  /** @type {Preprocessor} */\n  function preprocessor(value, encoding, end) {\n    /** @type {Array<Chunk>} */\n    const chunks = []\n    /** @type {RegExpMatchArray | null} */\n    let match\n    /** @type {number} */\n    let next\n    /** @type {number} */\n    let startPosition\n    /** @type {number} */\n    let endPosition\n    /** @type {Code} */\n    let code\n\n    // @ts-expect-error `Buffer` does allow an encoding.\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n    if (start) {\n      // To do: `markdown-rs` actually parses BOMs (byte order mark).\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++\n      }\n      start = undefined\n    }\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5)\n          atCarriageReturn = undefined\n        }\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n        switch (code) {\n          case 0: {\n            chunks.push(65533)\n            column++\n            break\n          }\n          case 9: {\n            next = Math.ceil(column / 4) * 4\n            chunks.push(-2)\n            while (column++ < next) chunks.push(-1)\n            break\n          }\n          case 10: {\n            chunks.push(-4)\n            column = 1\n            break\n          }\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n      startPosition = endPosition + 1\n    }\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5)\n      if (buffer) chunks.push(buffer)\n      chunks.push(null)\n    }\n    return chunks\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\nimport {subtokenize} from 'micromark-util-subtokenize'\n\n/**\n * @param {Array<Event>} events\n * @returns {Array<Event>}\n */\nexport function postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n  return events\n}\n","export {stringifyPosition} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n */\n\n/**\n * @typedef NodeLike\n * @property {string} type\n * @property {PositionLike | null | undefined} [position]\n *\n * @typedef PositionLike\n * @property {PointLike | null | undefined} [start]\n * @property {PointLike | null | undefined} [end]\n *\n * @typedef PointLike\n * @property {number | null | undefined} [line]\n * @property {number | null | undefined} [column]\n * @property {number | null | undefined} [offset]\n */\n\n/**\n * Serialize the positional info of a point, position (start and end points),\n * or node.\n *\n * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]\n *   Node, position, or point.\n * @returns {string}\n *   Pretty printed positional info of a node (`string`).\n *\n *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)\n *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for\n *   column, `s` for `start`, and `e` for end.\n *   An empty string (`''`) is returned if the given value is neither `node`,\n *   `position`, nor `point`.\n */\nexport function stringifyPosition(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if ('position' in value || 'type' in value) {\n    return position(value.position)\n  }\n\n  // Position.\n  if ('start' in value || 'end' in value) {\n    return position(value)\n  }\n\n  // Point.\n  if ('line' in value || 'column' in value) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\n/**\n * @param {Point | PointLike | null | undefined} point\n * @returns {string}\n */\nfunction point(point) {\n  return index(point && point.line) + ':' + index(point && point.column)\n}\n\n/**\n * @param {Position | PositionLike | null | undefined} pos\n * @returns {string}\n */\nfunction position(pos) {\n  return point(pos && pos.start) + '-' + point(pos && pos.end)\n}\n\n/**\n * @param {number | null | undefined} value\n * @returns {number}\n */\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","export {unified} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('vfile').VFileCompatible} VFileCompatible\n * @typedef {import('vfile').VFileValue} VFileValue\n * @typedef {import('..').Processor} Processor\n * @typedef {import('..').Plugin} Plugin\n * @typedef {import('..').Preset} Preset\n * @typedef {import('..').Pluggable} Pluggable\n * @typedef {import('..').PluggableList} PluggableList\n * @typedef {import('..').Transformer} Transformer\n * @typedef {import('..').Parser} Parser\n * @typedef {import('..').Compiler} Compiler\n * @typedef {import('..').RunCallback} RunCallback\n * @typedef {import('..').ProcessCallback} ProcessCallback\n *\n * @typedef Context\n * @property {Node} tree\n * @property {VFile} file\n */\n\nimport {bail} from 'bail'\nimport isBuffer from 'is-buffer'\nimport extend from 'extend'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\n\n// Expose a frozen processor.\nexport const unified = base().freeze()\n\nconst own = {}.hasOwnProperty\n\n// Function to create the first processor.\n/**\n * @returns {Processor}\n */\nfunction base() {\n  const transformers = trough()\n  /** @type {Processor['attachers']} */\n  const attachers = []\n  /** @type {Record<string, unknown>} */\n  let namespace = {}\n  /** @type {boolean|undefined} */\n  let frozen\n  let freezeIndex = -1\n\n  // Data management.\n  // @ts-expect-error: overloads are handled.\n  processor.data = data\n  processor.Parser = undefined\n  processor.Compiler = undefined\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  // @ts-expect-error: overloads are handled.\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  // @ts-expect-error: overloads are handled.\n  processor.run = run\n  processor.runSync = runSync\n  // @ts-expect-error: overloads are handled.\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  /** @type {Processor} */\n  function processor() {\n    const destination = base()\n    let index = -1\n\n    while (++index < attachers.length) {\n      destination.use(...attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /**\n   * @param {string|Record<string, unknown>} [key]\n   * @param {unknown} [value]\n   * @returns {unknown}\n   */\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  /** @type {Processor['freeze']} */\n  function freeze() {\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      const [attacher, ...options] = attachers[freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      /** @type {Transformer|void} */\n      const transformer = attacher.call(processor, ...options)\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Number.POSITIVE_INFINITY\n\n    return processor\n  }\n\n  /**\n   * @param {Pluggable|null|undefined} [value]\n   * @param {...unknown} options\n   * @returns {Processor}\n   */\n  function use(value, ...options) {\n    /** @type {Record<string, unknown>|undefined} */\n    let settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, ...options)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = Object.assign(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    /**\n     * @param {import('..').Pluggable<unknown[]>} value\n     * @returns {void}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...options] = value\n          addPlugin(plugin, ...options)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {void}\n     */\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = Object.assign(settings || {}, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList|null|undefined} [plugins]\n     * @returns {void}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {...unknown} [value]\n     * @returns {void}\n     */\n    function addPlugin(plugin, value) {\n      let index = -1\n      /** @type {Processor['attachers'][number]|undefined} */\n      let entry\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entry = attachers[index]\n          break\n        }\n      }\n\n      if (entry) {\n        if (isPlainObj(entry[1]) && isPlainObj(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        // @ts-expect-error: fine.\n        attachers.push([...arguments])\n      }\n    }\n  }\n\n  /** @type {Processor['parse']} */\n  function parse(doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Parser(String(file), file).parse()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /** @type {Processor['stringify']} */\n  function stringify(node, doc) {\n    processor.freeze()\n    const file = vfile(doc)\n    const Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      // @ts-expect-error: `newable` checks this.\n      return new Compiler(node, file).compile()\n    }\n\n    // @ts-expect-error: `newable` checks this.\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /**\n   * @param {Node} node\n   * @param {VFileCompatible|RunCallback} [doc]\n   * @param {RunCallback} [callback]\n   * @returns {Promise<Node>|void}\n   */\n  function run(node, doc, callback) {\n    assertNode(node)\n    processor.freeze()\n\n    if (!callback && typeof doc === 'function') {\n      callback = doc\n      doc = undefined\n    }\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((node: Node) => void)} resolve\n     * @param {(error: Error) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.\n      transformers.run(node, vfile(doc), done)\n\n      /**\n       * @param {Error|null} error\n       * @param {Node} tree\n       * @param {VFile} file\n       * @returns {void}\n       */\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['runSync']} */\n  function runSync(node, file) {\n    /** @type {Node|undefined} */\n    let result\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    // @ts-expect-error: we either bailed on an error or have a tree.\n    return result\n\n    /**\n     * @param {Error|null} [error]\n     * @param {Node} [tree]\n     * @returns {void}\n     */\n    function done(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * @param {VFileCompatible} doc\n   * @param {ProcessCallback} [callback]\n   * @returns {Promise<VFile>|undefined}\n   */\n  function process(doc, callback) {\n    processor.freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!callback) {\n      return new Promise(executor)\n    }\n\n    executor(null, callback)\n\n    /**\n     * @param {null|((file: VFile) => void)} resolve\n     * @param {(error?: Error|null|undefined) => void} reject\n     * @returns {void}\n     */\n    function executor(resolve, reject) {\n      const file = vfile(doc)\n\n      processor.run(processor.parse(file), file, (error, tree, file) => {\n        if (error || !tree || !file) {\n          done(error)\n        } else {\n          /** @type {unknown} */\n          const result = processor.stringify(tree, file)\n\n          if (result === undefined || result === null) {\n            // Empty.\n          } else if (looksLikeAVFileValue(result)) {\n            file.value = result\n          } else {\n            file.result = result\n          }\n\n          done(error, file)\n        }\n      })\n\n      /**\n       * @param {Error|null|undefined} [error]\n       * @param {VFile|undefined} [file]\n       * @returns {void}\n       */\n      function done(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          // @ts-expect-error: `callback` is defined if `resolve` is not.\n          callback(null, file)\n        }\n      }\n    }\n  }\n\n  /** @type {Processor['processSync']} */\n  function processSync(doc) {\n    /** @type {boolean|undefined} */\n    let complete\n\n    processor.freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n\n    const file = vfile(doc)\n\n    processor.process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    /**\n     * @param {Error|null|undefined} [error]\n     * @returns {void}\n     */\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n/**\n * Check if `value` is a constructor.\n *\n * @param {unknown} value\n * @param {string} name\n * @returns {boolean}\n */\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    // Prototypes do exist.\n    // type-coverage:ignore-next-line\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    // type-coverage:ignore-next-line\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n/**\n * Check if `value` is an object with keys.\n *\n * @param {Record<string, unknown>} value\n * @returns {boolean}\n */\nfunction keys(value) {\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {VFileCompatible} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is VFileValue}\n */\nfunction looksLikeAVFileValue(value) {\n  return typeof value === 'string' || isBuffer(value)\n}\n","/**\n * Throw a given error.\n *\n * @param {Error|null|undefined} [error]\n *   Maybe error.\n * @returns {asserts error is null|undefined}\n */\nexport function bail(error) {\n  if (error) {\n    throw error\n  }\n}\n","export default function isPlainObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n","/**\n * @typedef {(error?: Error|null|undefined, ...output: Array<any>) => void} Callback\n * @typedef {(...input: Array<any>) => any} Middleware\n *\n * @typedef {(...input: Array<any>) => void} Run\n *   Call all middleware.\n * @typedef {(fn: Middleware) => Pipeline} Use\n *   Add `fn` (middleware) to the list.\n * @typedef {{run: Run, use: Use}} Pipeline\n *   Middleware.\n */\n\n/**\n * Create new middleware.\n *\n * @returns {Pipeline}\n */\nexport function trough() {\n  /** @type {Array<Middleware>} */\n  const fns = []\n  /** @type {Pipeline} */\n  const pipeline = {run, use}\n\n  return pipeline\n\n  /** @type {Run} */\n  function run(...values) {\n    let middlewareIndex = -1\n    /** @type {Callback} */\n    const callback = values.pop()\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Expected function as last argument, not ' + callback)\n    }\n\n    next(null, ...values)\n\n    /**\n     * Run the next `fn`, or we’re done.\n     *\n     * @param {Error|null|undefined} error\n     * @param {Array<any>} output\n     */\n    function next(error, ...output) {\n      const fn = fns[++middlewareIndex]\n      let index = -1\n\n      if (error) {\n        callback(error)\n        return\n      }\n\n      // Copy non-nullish input into values.\n      while (++index < values.length) {\n        if (output[index] === null || output[index] === undefined) {\n          output[index] = values[index]\n        }\n      }\n\n      // Save the newly created `output` for the next call.\n      values = output\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next)(...output)\n      } else {\n        callback(null, ...output)\n      }\n    }\n  }\n\n  /** @type {Use} */\n  function use(middelware) {\n    if (typeof middelware !== 'function') {\n      throw new TypeError(\n        'Expected `middelware` to be a function, not ' + middelware\n      )\n    }\n\n    fns.push(middelware)\n    return pipeline\n  }\n}\n\n/**\n * Wrap `middleware`.\n * Can be sync or async; return a promise, receive a callback, or return new\n * values and errors.\n *\n * @param {Middleware} middleware\n * @param {Callback} callback\n */\nexport function wrap(middleware, callback) {\n  /** @type {boolean} */\n  let called\n\n  return wrapped\n\n  /**\n   * Call `middleware`.\n   * @this {any}\n   * @param {Array<any>} parameters\n   * @returns {void}\n   */\n  function wrapped(...parameters) {\n    const fnExpectsCallback = middleware.length > parameters.length\n    /** @type {any} */\n    let result\n\n    if (fnExpectsCallback) {\n      parameters.push(done)\n    }\n\n    try {\n      result = middleware.apply(this, parameters)\n    } catch (error) {\n      const exception = /** @type {Error} */ (error)\n\n      // Well, this is quite the pickle.\n      // `middleware` received a callback and called it synchronously, but that\n      // threw an error.\n      // The only thing left to do is to throw the thing instead.\n      if (fnExpectsCallback && called) {\n        throw exception\n      }\n\n      return done(exception)\n    }\n\n    if (!fnExpectsCallback) {\n      if (result instanceof Promise) {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /**\n   * Call `callback`, only once.\n   * @type {Callback}\n   */\n  function done(error, ...output) {\n    if (!called) {\n      called = true\n      callback(error, ...output)\n    }\n  }\n\n  /**\n   * Call `done` with one value.\n   *\n   * @param {any} [value]\n   */\n  function then(value) {\n    done(null, value)\n  }\n}\n","export {VFile} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Value} Value\n */\n\n/**\n * @typedef {Record<string, unknown> & {type: string, position?: Position | undefined}} NodeLike\n *\n * @typedef {'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'base64url' | 'latin1' | 'binary' | 'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *\n *   This is a copy of the types from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {Options | URL | Value | VFile} Compatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n *   Set multiple values.\n * @property {Value | null | undefined} [value]\n *   Set `value`.\n * @property {string | null | undefined} [cwd]\n *   Set `cwd`.\n * @property {Array<string> | null | undefined} [history]\n *   Set `history`.\n * @property {URL | string | null | undefined} [path]\n *   Set `path`.\n * @property {string | null | undefined} [basename]\n *   Set `basename`.\n * @property {string | null | undefined} [stem]\n *   Set `stem`.\n * @property {string | null | undefined} [extname]\n *   Set `extname`.\n * @property {string | null | undefined} [dirname]\n *   Set `dirname`.\n * @property {Data | null | undefined} [data]\n *   Set `data`.\n *\n * @typedef Map\n *   Raw source map.\n *\n *   See:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n *   Which version of the source map spec this map is following.\n * @property {Array<string>} sources\n *   An array of URLs to the original source files.\n * @property {Array<string>} names\n *   An array of identifiers which can be referenced by individual mappings.\n * @property {string | undefined} [sourceRoot]\n *   The URL root from which all sources are relative.\n * @property {Array<string> | undefined} [sourcesContent]\n *   An array of contents of the original source files.\n * @property {string} mappings\n *   A string of base64 VLQs which contain the actual mappings.\n * @property {string} file\n *   The generated file this source map is associated with.\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} Options\n *   Configuration.\n *\n *   A bunch of keys that will be shallow copied over to the new file.\n *\n * @typedef {Record<string, unknown>} ReporterSettings\n *   Configuration for reporters.\n */\n\n/**\n * @template {ReporterSettings} Settings\n *   Options type.\n * @callback Reporter\n *   Type for a reporter.\n * @param {Array<VFile>} files\n *   Files to report.\n * @param {Settings} options\n *   Configuration.\n * @returns {string}\n *   Report.\n */\n\nimport bufferLike from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n/**\n * Order of setting (least specific to most), we need this because otherwise\n * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n * stem can be set.\n *\n * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}\n */\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` — `{value: options}`\n   * *   `URL` — `{path: options}`\n   * *   `VFile` — shallow copies its data over to the new file\n   * *   `object` — all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(value) {\n    /** @type {Options | VFile} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      options = value\n    }\n\n    /**\n     * Place to store custom information (default: `{}`).\n     *\n     * It’s OK to store custom data directly on the file but moving it to\n     * `data` is recommended.\n     *\n     * @type {Data}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     *\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of filepaths the file moved between.\n     *\n     * The first is the original path and the last is the current path.\n     *\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).\n     *\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     *\n     * @type {Value}\n     */\n    this.value\n\n    // The below are non-standard, they are “well-known”.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     *\n     * This is used by vfile reporters.\n     *\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Custom, non-string, compiled, representation.\n     *\n     * This is used by unified to store non-string results.\n     * One example is when turning markdown into React nodes.\n     *\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Source map.\n     *\n     * This type is equivalent to the `RawSourceMap` type from the `source-map`\n     * module.\n     *\n     * @type {Map | null | undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (\n        prop in options &&\n        options[prop] !== undefined &&\n        options[prop] !== null\n      ) {\n        // @ts-expect-error: TS doesn’t understand basic reality.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) {\n        // @ts-expect-error: fine to set other things.\n        this[prop] = options[prop]\n      }\n    }\n  }\n\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if there’s no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if there’s no `path` yet.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when it’s a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding || undefined)\n  }\n\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > 👉 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string | null | undefined} part\n *   File path part.\n * @param {string} name\n *   Part name.\n * @returns {void}\n *   Nothing.\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string | undefined} part\n *   Thing.\n * @param {string} name\n *   Part name.\n * @returns {asserts part is string}\n *   Nothing.\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string | undefined} path\n *   Path.\n * @param {string} name\n *   Dependency name.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n\n/**\n * Assert `value` is a buffer.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Buffer}\n *   Whether `value` is a Node.js buffer.\n */\nfunction buffer(value) {\n  return bufferLike(value)\n}\n","export {VFileMessage} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {object & {type: string, position?: Position | undefined}} NodeLike\n */\n\nimport {stringifyPosition} from 'unist-util-stringify-position'\n\n/**\n * Message.\n */\nexport class VFileMessage extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   > 👉 **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(reason, place, origin) {\n    /** @type {[string | null, string | null]} */\n    const parts = [null, null]\n    /** @type {Position} */\n    let position = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: {line: null, column: null},\n      // @ts-expect-error: \"\n      end: {line: null, column: null}\n    }\n\n    super()\n\n    if (typeof place === 'string') {\n      origin = place\n      place = undefined\n    }\n\n    if (typeof origin === 'string') {\n      const index = origin.indexOf(':')\n\n      if (index === -1) {\n        parts[1] = origin\n      } else {\n        parts[0] = origin.slice(0, index)\n        parts[1] = origin.slice(index + 1)\n      }\n    }\n\n    if (place) {\n      // Node.\n      if ('type' in place || 'position' in place) {\n        if (place.position) {\n          // To do: next major: deep clone.\n          // @ts-expect-error: looks like a position.\n          position = place.position\n        }\n      }\n      // Position.\n      else if ('start' in place || 'end' in place) {\n        // @ts-expect-error: looks like a position.\n        // To do: next major: deep clone.\n        position = place\n      }\n      // Point.\n      else if ('line' in place || 'column' in place) {\n        // To do: next major: deep clone.\n        position.start = place\n      }\n    }\n\n    // Fields from `Error`.\n    /**\n     * Serialized positional info of error.\n     *\n     * On normal errors, this would be something like `ParseError`, buit in\n     * `VFile` messages we use this space to show where an error happened.\n     */\n    this.name = stringifyPosition(place) || '1:1'\n\n    /**\n     * Reason for message.\n     *\n     * @type {string}\n     */\n    this.message = typeof reason === 'object' ? reason.message : reason\n\n    /**\n     * Stack of message.\n     *\n     * This is used by normal errors to show where something happened in\n     * programming code, irrelevant for `VFile` messages,\n     *\n     * @type {string}\n     */\n    this.stack = ''\n\n    if (typeof reason === 'object' && reason.stack) {\n      this.stack = reason.stack\n    }\n\n    /**\n     * Reason for message.\n     *\n     * > 👉 **Note**: you should use markdown.\n     *\n     * @type {string}\n     */\n    this.reason = this.message\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * State of problem.\n     *\n     * * `true` — marks associated file as no longer processable (error)\n     * * `false` — necessitates a (potential) change (warning)\n     * * `null | undefined` — for things that might not need changing (info)\n     *\n     * @type {boolean | null | undefined}\n     */\n    this.fatal\n\n    /**\n     * Starting line of error.\n     *\n     * @type {number | null}\n     */\n    this.line = position.start.line\n\n    /**\n     * Starting column of error.\n     *\n     * @type {number | null}\n     */\n    this.column = position.start.column\n\n    /**\n     * Full unist position.\n     *\n     * @type {Position | null}\n     */\n    this.position = position\n\n    /**\n     * Namespace of message (example: `'my-package'`).\n     *\n     * @type {string | null}\n     */\n    this.source = parts[0]\n\n    /**\n     * Category of message (example: `'my-rule'`).\n     *\n     * @type {string | null}\n     */\n    this.ruleId = parts[1]\n\n    /**\n     * Path of a file (used throughout the `VFile` ecosystem).\n     *\n     * @type {string | null}\n     */\n    this.file\n\n    // The following fields are “well known”.\n    // Not standard.\n    // Feel free to add other non-standard fields to your messages.\n\n    /**\n     * Specify the source value that’s being reported, which is deemed\n     * incorrect.\n     *\n     * @type {string | null}\n     */\n    this.actual\n\n    /**\n     * Suggest acceptable values that can be used instead of `actual`.\n     *\n     * @type {Array<string> | null}\n     */\n    this.expected\n\n    /**\n     * Link to docs for the message.\n     *\n     * > 👉 **Note**: this must be an absolute URL that can be passed as `x`\n     * > to `new URL(x)`.\n     *\n     * @type {string | null}\n     */\n    this.url\n\n    /**\n     * Long form description of the message (you should use markdown).\n     *\n     * @type {string | null}\n     */\n    this.note\n    /* eslint-enable no-unused-expressions */\n  }\n}\n\nVFileMessage.prototype.file = ''\nVFileMessage.prototype.name = ''\nVFileMessage.prototype.reason = ''\nVFileMessage.prototype.message = ''\nVFileMessage.prototype.stack = ''\nVFileMessage.prototype.fatal = null\nVFileMessage.prototype.column = null\nVFileMessage.prototype.line = null\nVFileMessage.prototype.source = null\nVFileMessage.prototype.ruleId = null\nVFileMessage.prototype.position = null\n","// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string | URL} path\n *   File URL.\n * @returns {string}\n *   File URL.\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * Get a path from a POSIX URL.\n *\n * @param {URL} url\n *   URL.\n * @returns {string}\n *   File path.\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * Check if `fileUrlOrPath` looks like a URL.\n *\n * @param {unknown} fileUrlOrPath\n *   File path or URL.\n * @returns {fileUrlOrPath is URL}\n *   Whether it’s a URL.\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileUrlOrPath) {\n  return (\n    fileUrlOrPath !== null &&\n    typeof fileUrlOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileUrlOrPath.origin\n  )\n}\n","import type { TopLevelContent } from \"mdast\"\n\nimport { Element } from \"../types\"\nimport { assertUnreachable } from \"../utils\"\nimport { parseBlockquote } from \"./parse-blockquote\"\nimport { parseCodeBlock } from \"./parse-code-block\"\nimport { parseFootnoteDefinition } from \"./parse-footnote-definition\"\nimport { parseHeading } from \"./parse-heading\"\nimport { parseHTML } from \"./parse-html\"\nimport { parseList } from \"./parse-list\"\nimport { parseParagraph } from \"./parse-paragraph\"\nimport { parseTable } from \"./parse-table\"\nimport { parseThematicBreak } from \"./parse-thematic-break\"\n\nexport function parseContents(contents: TopLevelContent[]): Element[] {\n  const elements: Element[] = []\n  for (const content of contents) {\n    elements.push(...parseContent(content))\n  }\n  return elements\n}\n\nexport function parseContent(content: TopLevelContent): Element[] {\n  switch (content.type) {\n    case \"blockquote\":\n      return parseBlockquote(content)\n    case \"code\":\n      return parseCodeBlock(content)\n    case \"definition\":\n      /**\n       * A `definition` is used by a `linkRef` or `imageRef`; however, we inline\n       * these with our `./remark-inline-links`\n       */\n      throw new Error(`The type \"definition\" should not exist. See comments`)\n    case \"footnoteDefinition\":\n      return parseFootnoteDefinition(content)\n    case \"heading\":\n      return parseHeading(content)\n    case \"html\":\n      return parseHTML(content)\n    case \"list\":\n      return parseList(content)\n    case \"paragraph\":\n      /**\n       * Returns a `paragraph` or an `image-block` Element.\n       */\n      return parseParagraph(content)\n    case \"table\":\n      return parseTable(content)\n    case \"thematicBreak\":\n      return parseThematicBreak()\n    case \"yaml\":\n      /**\n       * YAML FrontMatter is not used in Wysimark.\n       */\n      return []\n  }\n  assertUnreachable(content)\n}\n","import { Element } from \"./types\"\n\nexport function assert(pass: boolean, message: string) {\n  if (!pass) throw new Error(`${message}`)\n}\n\nexport function assertElementType(element: Element, type: Element[\"type\"]) {\n  if (element.type !== type)\n    throw new Error(\n      `Expected element to be of type ${JSON.stringify(\n        element\n      )} but is ${JSON.stringify(element, null, 2)}`\n    )\n}\n\nexport function assertUnreachable(x: never): never {\n  throw new Error(\n    `Didn't expect to get here with value ${JSON.stringify(x, null, 2)}`\n  )\n}\n","import type { Blockquote } from \"mdast\"\n\nimport { Element } from \"../types\"\nimport { parseContents } from \"./parse-content\"\n\nexport function parseBlockquote(content: Blockquote): Element[] {\n  return [{ type: \"block-quote\", children: parseContents(content.children) }]\n}\n","import type { Code } from \"mdast\"\n\nimport { Element } from \"../types\"\n\nexport function parseCodeBlock(content: Code): Element[] {\n  const codeLines = content.value.split(\"\\n\")\n  return [\n    {\n      type: \"code-block\",\n      language: content.lang || \"text\",\n      children: codeLines.map((codeLine) => ({\n        type: \"code-block-line\",\n        children: [{ text: codeLine }],\n      })),\n    },\n  ]\n}\n","import type { FootnoteDefinition } from \"mdast\"\n\nimport { Element } from \"../types\"\nimport { parseContents } from \"./parse-content\"\n\n/**\n * GitHub Flavored Markdown does not support footnotes and therefore, at the\n * moment, Wysimark does not support footnotes.\n *\n * However, we do provide some compatibility. Remarks, by default, parses\n * Footnote Definitions and we convert them into a blockquote. We insert an\n * extra paragraph at the top that contains the footnote identifier in square\n * brackets like `[1]`\n */\nexport function parseFootnoteDefinition(\n  footnote: FootnoteDefinition\n): Element[] {\n  return [\n    {\n      type: \"block-quote\",\n      children: [\n        /**\n         * Insert an initial paragraph with the footnote identifier in square\n         * brackets.\n         */\n        { type: \"paragraph\", children: [{ text: `[${footnote.identifier}]` }] },\n        /**\n         * The rest of the children are parsed as is and supports the full range\n         * of element types like headings, lists and nested block quotes.\n         */\n        ...parseContents(footnote.children),\n      ],\n    },\n  ]\n}\n","import type { Heading } from \"mdast\"\n\nimport { Element } from \"../types\"\nimport { parsePhrasingContents } from \"./parse-phrasing-content/parse-phrasing-content\"\n\nexport function parseHeading(content: Heading): Element[] {\n  return [\n    {\n      type: \"heading\",\n      level: content.depth,\n      children: parsePhrasingContents(content.children),\n    },\n  ]\n}\n","import type { PhrasingContent } from \"mdast\"\n\nimport { MarkProps, Segment } from \"../../types\"\nimport { assertUnreachable } from \"../../utils\"\nimport { normalizeSegments } from \"./normalize-segments\"\nimport { parseInlineImage } from \"./parse-inline-image\"\n\nexport function parsePhrasingContents(\n  phrasingContents: PhrasingContent[],\n  marks: MarkProps = {}\n): Segment[] {\n  const segments: Segment[] = []\n  for (const phrasingContent of phrasingContents) {\n    segments.push(...parsePhrasingContent(phrasingContent, marks))\n  }\n  const nextInlines = normalizeSegments(segments)\n  return nextInlines\n}\n\nfunction parsePhrasingContent(\n  phrasingContent: PhrasingContent,\n  marks: MarkProps = {}\n): Segment[] {\n  switch (phrasingContent.type) {\n    case \"delete\":\n      return parsePhrasingContents(phrasingContent.children, {\n        ...marks,\n        strike: true,\n      })\n    case \"emphasis\":\n      return parsePhrasingContents(phrasingContent.children, {\n        ...marks,\n        italic: true,\n      })\n    case \"footnoteReference\":\n      return [{ text: `[${phrasingContent.identifier}]` }]\n    case \"html\":\n      return [{ text: phrasingContent.value, code: true }]\n    case \"image\":\n      return parseInlineImage(phrasingContent)\n    case \"inlineCode\": {\n      return [{ text: phrasingContent.value, ...marks, code: true }]\n    }\n    case \"link\":\n      return [\n        {\n          type: \"anchor\",\n          href: phrasingContent.url,\n          title:\n            /**\n             * Ensure that `title` is undefined if it's null.\n             */\n            phrasingContent.title == null ? undefined : phrasingContent.title,\n          children: parsePhrasingContents(phrasingContent.children, marks),\n        },\n      ]\n    case \"strong\":\n      return parsePhrasingContents(phrasingContent.children, {\n        ...marks,\n        bold: true,\n      })\n    case \"text\":\n      return [{ text: phrasingContent.value, ...marks }]\n    case \"linkReference\":\n    case \"imageReference\":\n      throw new Error(\n        `linkReference and imageReference should be converted to link and image through our transformInlineLinks function`\n      )\n    case \"break\":\n      /**\n       * NOTE:\n       *\n       * I don't think this is doing anything at the moment as a \"\\n\" is being\n       * read without being turned into a break. We can test this by doing a\n       * console.log before the return below.\n       */\n      return [{ text: \"\\n\" }]\n    case \"footnote\":\n      /**\n       * TODO: Support footnotes\n       *\n       * This is a footnote, and should be converte to a suitable alternative or\n       * for us to explicitly support a Footnote type in the future. At the\n       * moment, we don't explicitly support a footnote as it's (a) not part of\n       * GFM and (b) not really that useful while (c) adding complexity to the\n       * UI for something that's not used.\n       */\n      throw new Error(\"footnote is not supported yet\")\n  }\n  assertUnreachable(phrasingContent)\n}\n","import { Text as SlateText } from \"slate\"\n\nimport { Segment } from \"../../types\"\nimport { normalizeSegment } from \"./normalize-segment\"\n\n/**\n * After generating segments by just pushing them onto an Array, we want to get\n * them into proper form for use in Slate.\n *\n * Slate expects its data structure to follow [certain\n * rules](https://docs.slatejs.org/concepts/11-normalizing) and we make sure\n * they are followed.\n *\n * These are the rules for segments (text/inline) that we enforce:\n *\n * - Rule 1: All Element nodes must contain at least one Text descendant\n * - Rule 2: Two adjacent texts with the same custom properties will be merged.\n * - Rule 4: Inline nodes cannot be the first or last child of a parent block,\n *   nor can it be next to another inline node in the children array.\n *\n */\nexport function normalizeSegments(segments: Segment[]): Segment[] {\n  const nextSegments: Segment[] = []\n\n  /**\n   * Rule 2:\n   *\n   * Build up the nextSegments. The `normalizeSegment` function called inside\n   * does the work of checking to see if the segment before is a Text with the\n   * exact same marks. If it is, then instead of pushing on another Text\n   * segment, it merges the current segment Text into the previous Segment.\n   *\n   * Rule 4 (part 3):\n   *\n   * It also checks for two inline elements and inserts an empty Text node\n   * between them by emitting a `{text: ''}` before the inline Element segment.\n   */\n  for (let i = 0; i < segments.length; i++) {\n    /**\n     * When we provide the `prevSegment` notice that is is actually the\n     * `prevSegment` from our `nextSegments` and not `segments[i-1]`.\n     *\n     * This is important because `normalizeSegment` will mutate `prevSegment`\n     */\n\n    const mutablePrevSegment: Segment | undefined =\n      nextSegments[nextSegments.length - 1]\n    nextSegments.push(...normalizeSegment(segments[i], mutablePrevSegment))\n  }\n\n  /**\n   * Rule 1:\n   *\n   * If there are no segments, we ensure there is at least one by inserting an\n   * empty Text\n   */\n  if (nextSegments.length === 0) nextSegments.push({ text: \"\" })\n  /**\n   * Rule 4 (part 1 & part 2):\n   *\n   * If the first segment isn't Text, insert a Text\n   */\n  if (!SlateText.isText(nextSegments[0])) nextSegments.unshift({ text: \"\" })\n  /**\n   * Rule 4:\n   *\n   * If the last segment isn't Text, insert a Text\n   */\n  if (!SlateText.isText(nextSegments[nextSegments.length - 1]))\n    nextSegments.push({ text: \"\" })\n  return nextSegments\n}\n","import { Text as SlateText } from \"slate\"\n\nimport { getMarksFromText } from \"../../serialize/serialize-line/utils\"\nimport { Segment, Text } from \"../../types\"\n\n/**\n * This is algorithm checks for equality of marks.\n */\nexport function areMarksEqual(a: Text, b: Text): boolean {\n  const marksA = getMarksFromText(a)\n  const marksB = getMarksFromText(b)\n  /**\n   *\n   * WARNING:\n   *\n   * This algorithm is specific to our use case. a, b contain non-repeated\n   * items. It will fail in other scenarios.\n   *\n   * > If you want to check if both arrays are equals, containing the same\n   * > unsorted items (but not used multiple times)\n   *\n   * https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript#comment68674302_19746771\n   */\n  return (\n    marksA.length == marksB.length && marksA.every((v) => marksB.includes(v))\n  )\n}\n\n/**\n * Enforces Rule 2\n *\n * Two adjacent texts with the same custom properties will be merged.\n * https://docs.slatejs.org/concepts/11-normalizing\n *\n * normalizeSegment does most of the work for merging two segments with the same\n * marks together.\n *\n * Normally, this method emits the current `segment`; however, if the current\n * segment and the previous segment have the same marks, it instead emits an\n * empty array indicating not to add the current segment. Instead, it merges the\n * current segment text into the text of the previous segment.\n *\n * Enforce Rule 4 (part 3)\n *\n * \"Inline nodes cannot be the first or last child of a parent block, nor can it\n * be next to another inline node in the children array.\"\n *\n * Mainly, it's enforcing the part about the fact that there must be a Text node\n * between two inline Element nodes.\n */\nexport function normalizeSegment(\n  segment: Segment,\n  /**\n   * Let's be explicit that we are doing something unusual here in that we are\n   * mutating the previous segment by naming it as such.\n   */\n  mutablePrevSegment?: Segment\n): Segment[] {\n  const segmentIsText = SlateText.isText(segment)\n  const prevSegmentIsText = SlateText.isText(mutablePrevSegment)\n\n  /**\n   * Rule 4 (part 3):\n   *\n   * If there is a previous segment and the previous segment and the current\n   * segment are both inline elements, we want to insert a space between them\n   * which this does.\n   *\n   * It stops checking for merging two texts with each other since if they are\n   * two inline elements, it doesn't need to check for text anymore.\n   */\n  if (mutablePrevSegment && !prevSegmentIsText && !segmentIsText) {\n    return [{ text: \"\" }, segment]\n  }\n\n  /**\n   * If the current segment is an Inline Element, then we can't merge it so we\n   * return it as is\n   */\n  if (!segmentIsText) return [segment]\n  /**\n   * If the previous segment is an Inline Element or it's node defined, then we\n   * can't merge into it so we return it as is\n   */\n  if (mutablePrevSegment === undefined || !prevSegmentIsText) return [segment]\n\n  /**\n   * If the two Text segments have the same marks, then merge them\n   */\n  const marksEqual = areMarksEqual(mutablePrevSegment, segment)\n  if (marksEqual) {\n    mutablePrevSegment.text = [mutablePrevSegment.text, segment.text].join(\"\")\n    return []\n  }\n\n  return [segment]\n}\n","export * from \"./is-utils\"\nexport * from \"./mark-utils\"\nexport * from \"./text-utils\"\n","import * as Slate from \"slate\"\n\nimport { AnchorElement } from \"~/src/anchor-plugin\"\n\nimport { Segment, Text } from \"../../../types\"\nimport { LineElement, Node } from \"../normalize-line/types\"\n\n/**\n * Is this a Text Node\n */\nexport function isText(segment: Node | undefined): segment is Text {\n  return Slate.Text.isText(segment)\n}\n\n/**\n * Is this an Element Node\n *\n * In the context of our normalizers, passing `isElement` means that it is\n * a `LineElement` or `AnchorElement`\n *\n * TODO:\n *\n * We should also add the following in the future:\n *\n * - `ImageInlineElement`\n * - `AttachmentElement`\n */\nexport function isElement(\n  segment: Node\n): segment is LineElement | AnchorElement {\n  return Slate.Element.isElement(segment)\n}\n\n/**\n * Identify this as a plain, non-code Text space. This is fairly specific\n * because we only want to manipulate non-code Text spaces. If the Text is\n * `code` then we can apply our marks next to it.\n *\n * - Does the passed in `Text` node made up of only one or more spaces\n * - The `Text` node must not be `code`\n */\nexport function isPlainSpace(segment: Segment): boolean {\n  return (\n    Slate.Text.isText(segment) && !!segment.text.match(/^\\s+$/) && !segment.code\n  )\n}\n","export * from \"./mark-convert-utils\"\nexport * from \"./mark-get-utils\"\nexport * from \"./mark-order-utils\"\n","import { MarkKey } from \"../../../../types\"\n\nexport const MARK_KEY_TO_TOKEN = {\n  bold: \"**\",\n  italic: \"_\",\n  // ins: \"++\",\n  strike: \"~~\",\n  sup: \"^\",\n  sub: \"~\",\n  /**\n   * IMPORTANT!\n   *\n   * We noop `code` here.\n   *\n   * We accept the `code` mark so as not to throw an error if it is found. We do\n   * this because we handle `code` text specially because of the way it needs to\n   * be escaped.\n   *\n   * This is handled in the `serializeLine` code.\n   */\n  code: \"\",\n} as Record<MarkKey, string>\n\n/**\n * Convert a single mark to a string\n */\nfunction convertMarkToSymbol(mark: MarkKey): string {\n  if (mark in MARK_KEY_TO_TOKEN) return MARK_KEY_TO_TOKEN[mark]\n  throw new Error(\n    `Could not find mark ${JSON.stringify(mark)} in MARK_KEY_TO_TOKEN lookup`\n  )\n}\n\n/**\n * Convert an array of marks to a string\n */\nexport function convertMarksToSymbolsExceptCode(marks: MarkKey[]) {\n  return marks.map(convertMarkToSymbol).join(\"\")\n}\n","import { Text as SlateText } from \"slate\"\n\nimport { MarkKey, Segment, Text } from \"../../../../types\"\nimport { isPlainSpace, isText } from \"../is-utils\"\n\n/**\n * Gets all the marks in current `Text`\n */\nexport function getMarksFromText(text: Text): MarkKey[] {\n  /**\n   * disable esling to eat the `_` without throwing an error\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { text: _, ...marks } = text\n  return Object.keys(marks) as MarkKey[]\n}\n\n/**\n * Gets all the marks from the current segment\n */\nexport function getMarksFromSegment(segment: Segment): MarkKey[] {\n  if (SlateText.isText(segment)) {\n    if (isPlainSpace(segment)) {\n      throw new Error(\n        `You probably didn't mean to do this. We should only be getting marks from segments that are not plain space segments.`\n      )\n    }\n    return getMarksFromText(segment)\n  } else if (segment.type === \"anchor\") {\n    return getCommonAnchorMarks(segment.children as Segment[])\n  } else {\n    /**\n     * TODO: Need to handle images still.\n     */\n    throw new Error(`Unhandled type ${segment.type}`)\n  }\n}\n\nexport function getCommonAnchorMarks(segments: Segment[]): MarkKey[] {\n  let commonMarks: MarkKey[] | undefined\n  for (const segment of segments) {\n    if (!isText(segment)) {\n      /**\n       * Use this to test for images in anchors\n       *\n       * [![Semantic description](https://roneo.org/img/ok.png \"Your title\")](http://jamstack.club)\n       */\n      if (segment.type === \"image-inline\") continue\n      /**\n       * TODO: This is not actually true. It can be an inline image which we\n       * still need to add.\n       */\n      throw new Error(\n        `Expected every segment in an anchor to be a Text segment`\n      )\n    }\n    if (isPlainSpace(segment)) continue\n    const currentMarks = getMarksFromText(segment)\n    if (commonMarks === undefined) {\n      commonMarks = currentMarks\n      continue\n    }\n    commonMarks = commonMarks.filter((commonMark) =>\n      currentMarks.includes(commonMark)\n    )\n  }\n  if (commonMarks === undefined)\n    throw new Error(\n      `No text segments were found as children in this anchor which should not be possible`\n    )\n  return commonMarks\n}\n","import { MarkKey } from \"../../../../types\"\n\n/**\n * When adding back marks, this is the order in which we add them back.\n *\n * The order is determined by an educated guess about which marks are more\n * likely to be chaging inside other marks. For example, this is probably pretty\n * common:\n *\n * **This is x^2^**\n *\n * Having a superscript inside of a bold. But it's probably rare to have bold\n * switched on/off inside a superscript.\n */\nconst ORDERED_MARK_KEYS: MarkKey[] = [\n  \"bold\",\n  \"italic\",\n  \"underline\",\n  \"strike\",\n  \"sup\",\n  \"sub\",\n  \"code\",\n]\n\n/**\n * Sort Algorithm\n *\n * https://stackoverflow.com/a/44063445\n */\nexport function sortMarks(marks: MarkKey[]): MarkKey[] {\n  return marks\n    .slice()\n    .sort((a, b) => ORDERED_MARK_KEYS.indexOf(a) - ORDERED_MARK_KEYS.indexOf(b))\n}\n","const ESCAPES = [\n  \"\\\\\", // escape\n  \"`\", // code\n  \"*\", // bold/italic/hr\n  \"_\", // bold/italic/hr\n  \"[\", // link/list\n  \"]\", // link/list\n  \"(\", // link\n  \")\", // link\n  \"#\", // headings\n  \"+\", // list\n  \"-\", // hr/list\n  \".\", // numbered list\n  \"!\", // image\n  \"|\", // table\n  \"^\", // sup\n  \"~\", // sub/strikethrough\n  \"<\", // link/html\n  \">\", // link/html\n  /**\n   * Includes all the characters in the list of Backslash escapes in the example\n   * for GitHub Flavored Markdown.\n   *\n   * https://github.github.com/gfm/#backslash-escapes\n   */\n  \"{\",\n  \"}\",\n  \"=\",\n  \":\",\n  \";\",\n  \"$\",\n  \"%\",\n  \"&\",\n  \"?\",\n  '\"',\n  \"'\",\n  \",\",\n  \"\\\\\",\n  \"/\",\n  \"@\",\n]\n\nconst ESCAPES_REGEXP = new RegExp(\n  `(${ESCAPES.map((symbol) => `\\\\${symbol}`).join(\"|\")})`,\n  \"g\"\n)\n\n/**\n * Escape text that could have an ambiguous meaning in markdown\n */\nexport function escapeText(s: string) {\n  return s.replace(ESCAPES_REGEXP, (s: string) => `\\\\${s}`)\n  // .replace(/\\n/g, \"<br>\")\n}\n","import type { Image } from \"mdast\"\n\nimport { ImageSharedElement } from \"~/src/image-plugin/types\"\n\nimport { Segment } from \"../../../types\"\nimport { imageParsers } from \"./image-parsers\"\n\nexport type ImageData = Omit<ImageSharedElement, \"children\">\n\n/**\n * Iterate through all the image parsers utnil we find one that returns\n * `ImageData`. Combine that `ImageData` with the `type` and `children` and\n * return it as the `ImageInlineElement`\n */\nexport function parseInlineImage(image: Image): Segment[] {\n  for (const imageParser of imageParsers) {\n    const imageData = imageParser(image)\n    if (!imageData) continue\n    return [\n      {\n        type: \"image-inline\",\n        ...imageData,\n        children: [{ text: \"\" }],\n      },\n    ]\n  }\n  throw new Error(`Shouldn't get here because last parser always returns data`)\n}\n","import { parseGenericImage } from \"./parse-generic-image\"\nimport { parsePortiveImage } from \"./parse-portive-image\"\nimport { parseUncommonMarkImage } from \"./parse-uncommon-mark-image\"\n\nexport const imageParsers = [\n  parsePortiveImage,\n  parseUncommonMarkImage,\n  parseGenericImage,\n]\n","import type { Image } from \"mdast\"\n\nimport { ImageData } from \"./index\"\n\n/**\n * As a fallback, we don't\n */\nexport function parseGenericImage(image: Image): ImageData {\n  return {\n    url: image.url,\n    title: image.title || undefined,\n    alt: image.alt || undefined,\n  }\n}\n","import type { Image } from \"mdast\"\n\nimport { parseUrl } from \"../../../parseUrl\"\nimport { ImageData } from \"./index\"\nimport { parseSize } from \"./parse-utils\"\n\nexport function parsePortiveImage(image: Image): ImageData | undefined {\n  // const url = new URL(image.url)\n  const url = parseUrl(image.url)\n  /**\n   * Only parse portive URL if it is a portive recognized domain\n   */\n  if (!url.hostname.match(/[.]portive[.]com$/i)) return\n  /**\n   * Should have a size param as part of the query string\n   */\n  const sizeParam = url.searchParams.get(\"size\")\n  if (sizeParam === null) return\n  /**\n   * And the query string should parse properly as an ImageSize\n   */\n  const size = parseSize(sizeParam)\n  if (size === null) return\n  /**\n   * The Portive image URL should end in something like `--640x480.jpg` which\n   * identifies its width/height.\n   */\n  const srcSizeMatch = url.pathname.match(/[-][-](\\d+)x(\\d+)[.][a-zA-Z]+$/)\n  if (srcSizeMatch === null) return\n  /**\n   * Return the `ImageData`\n   */\n  return {\n    url: `${url.origin}${url.pathname}`,\n    title: image.title || undefined,\n    alt: image.alt || undefined,\n    width: size.width,\n    height: size.height,\n    srcWidth: parseInt(srcSizeMatch[1]),\n    srcHeight: parseInt(srcSizeMatch[2]),\n  }\n}\n","type ParsedUrl = {\n  origin: string\n  hostname: string\n  pathname: string\n  searchParams: URLSearchParams\n  hash: string\n}\n\n/**\n * NOTE: As per the URL spec:\n *\n * - searchParams part does not include the \"?\"\n * - hash part includes the \"#\"\n */\nconst URL_REGEX = /^(\\/[^?#]*)(?:\\?([^#]*))?(#.*)?$/\n\nexport function parseUrl(url: string): ParsedUrl {\n  try {\n    const urlData = new URL(url)\n    return {\n      origin: urlData.origin,\n      hostname: urlData.hostname,\n      pathname: urlData.pathname,\n      searchParams: urlData.searchParams,\n      hash: urlData.hash,\n    }\n  } catch (error) {\n    const matchdata = url.match(URL_REGEX)\n    if (matchdata === null)\n      throw new Error(`Invalid format should not happen: ${url}`)\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_, pathname, searchParams, hash] = [...matchdata]\n    return {\n      origin: \"\",\n      hostname: \"\",\n      pathname: pathname || \"\",\n      searchParams: new URLSearchParams(searchParams),\n      hash: hash || \"\",\n    }\n  }\n}\n","/**\n * Takes a `string` in the form `640x480` (i.e. number x number) and return an\n * ImageSize object with `width` and `height`.\n */\nexport function parseSize(\n  s: string | null\n): { width: number; height: number } | null {\n  if (typeof s !== \"string\") return null\n  const sizeMatch = s.match(/^(\\d+)x(\\d+)$/)\n  if (sizeMatch === null) return null\n  return {\n    width: parseInt(sizeMatch[1]),\n    height: parseInt(sizeMatch[2]),\n  }\n}\n","import type { Image } from \"mdast\"\n\nimport { parseUrl } from \"../../../parseUrl\"\nimport { ImageData } from \"./index\"\nimport { parseSize } from \"./parse-utils\"\n\n/**\n * UncommonMark images are just regular images with some additional encoding in\n * the URL hash which allows us to embed extra information without affecting the\n * image that is rendered nor does it affect the `title` or `alt` attributes.\n */\nexport function parseUncommonMarkImage(image: Image): ImageData | undefined {\n  const url = parseUrl(image.url)\n  /**\n   * If there's no hash, it's not UncommonMark\n   */\n  if (url.hash.length === 0) return\n  /**\n   * We use `URLSearchParams` to decode the size data after the `#` because it's\n   * free (embedded in every browser without more code) and available (including\n   * Node)!\n   */\n  const params = new URLSearchParams(url.hash.slice(1))\n  const size = parseSize(params.get(\"size\"))\n  const srcSize = parseSize(params.get(\"srcSize\"))\n  if (!size || !srcSize) return\n  /**\n   * If we successfully parsed all the ImageSize info, then return the\n   * `ImageData`\n   */\n  return {\n    url: `${url.origin}${url.pathname}`,\n    title: image.title || undefined,\n    alt: image.alt || undefined,\n    width: size.width,\n    height: size.height,\n    srcWidth: srcSize.width,\n    srcHeight: srcSize.height,\n  }\n}\n","import type { HTML } from \"mdast\"\n\nimport { Element } from \"../types\"\n\nexport function parseHTML(content: HTML): Element[] {\n  return [\n    {\n      type: \"code-block\",\n      language: \"html\",\n      children: content.value.split(\"\\n\").map((line) => ({\n        type: \"code-block-line\",\n        children: [{ text: line }],\n      })),\n    },\n  ]\n}\n","export * from \"./parse-list\"\n","import type { List } from \"mdast\"\n\nimport { Element } from \"../../types\"\nimport { parseListItem } from \"./parse-list-item\"\n\nexport function parseList(list: List, depth = 0): Element[] {\n  // console.log(JSON.stringify(list, null, 2))\n  const elements: Element[] = []\n  for (const listItem of list.children) {\n    elements.push(\n      ...parseListItem(listItem, { depth, ordered: !!list.ordered })\n    )\n  }\n  return elements\n}\n","import type { ListItem } from \"mdast\"\n\nimport { Element } from \"../../types\"\nimport { parseListItemChild } from \"./parse-list-item-child\"\n\nexport function parseListItem(\n  listItem: ListItem,\n  options: { depth: number; ordered: boolean }\n): Element[] {\n  const elements: Element[] = []\n  for (const child of listItem.children) {\n    elements.push(\n      ...parseListItemChild(child, { ...options, checked: listItem.checked })\n    )\n  }\n  return elements\n}\n","import type { ListItem } from \"mdast\"\n\nimport { Element } from \"../../types\"\nimport { parseContent } from \"../parse-content\"\nimport { parsePhrasingContents } from \"../parse-phrasing-content/parse-phrasing-content\"\nimport { parseList } from \"./parse-list\"\n\nexport function parseListItemChild(\n  child: ListItem[\"children\"][number],\n  {\n    depth,\n    ordered,\n    checked,\n  }: { depth: number; ordered: boolean; checked: boolean | null | undefined }\n): Element[] {\n  switch (child.type) {\n    case \"paragraph\":\n      if (checked === true || checked === false) {\n        return [\n          {\n            type: \"task-list-item\",\n            depth,\n            checked,\n            children: parsePhrasingContents(child.children),\n          },\n        ]\n      } else if (ordered) {\n        return [\n          {\n            type: \"ordered-list-item\",\n            depth,\n            children: parsePhrasingContents(child.children),\n          },\n        ]\n      } else {\n        return [\n          {\n            type: \"unordered-list-item\",\n            depth,\n            children: parsePhrasingContents(child.children),\n          },\n        ]\n      }\n    case \"list\":\n      return parseList(child, depth + 1)\n    default:\n      /**\n       * NOTE:\n       *\n       * We break out of a list when the children of a list item are not more\n       * lists/list items.\n       *\n       * This is one area where we don't strictly adhere to the Markdown\n       * specification and it is intentional because adhering strictly to the\n       * Markdown specification would create a harmful user experience.\n       *\n       * It appears that Markdown allows nesting other block types in lists\n       * other than list items. For example, one can place a table, block\n       * quote, heading or something else in a list item.\n       *\n       * There are a few problems with this from a user perspective:\n       *\n       * - It's unexpected. No other editors provide such a feature.\n       * - If we were to adopt this as a feature, the user experience would be\n       *   terrible, namely because it would be unpredictable what commands do\n       *   toggle headings or list items should do if they were nested.\n       *\n       */\n      return parseContent(child)\n  }\n}\n","import type { Paragraph } from \"mdast\"\n\nimport { ImageBlockElement, ImageInlineElement } from \"~/src/image-plugin/types\"\n\nimport { Element, Segment } from \"../types\"\nimport { parsePhrasingContents } from \"./parse-phrasing-content/parse-phrasing-content\"\n\nfunction isImageBlock(segments: Segment[]): boolean {\n  if (segments.length !== 3) return false\n  if (!(\"text\" in segments[0]) || segments[0].text !== \"\") return false\n  if (!(\"text\" in segments[2]) || segments[2].text !== \"\") return false\n  if (!(\"type\" in segments[1]) || segments[1].type !== \"image-inline\")\n    return false\n  return true\n}\n\nconst NBSP = \"\\u00A0\"\n\nfunction isSingleNBSP(segments: Segment[]): boolean {\n  if (segments.length !== 1) return false\n  if (!(\"text\" in segments[0]) || segments[0].text !== NBSP) return false\n  return true\n}\n\n/**\n * Parses to a Paragraph or an ImageBlock element.\n *\n * We need to do it this way because an ImageBlock is a Paragraph that happens\n * to have exactly one ImageInline child.\n */\nexport function parseParagraph(content: Paragraph): Element[] {\n  const segments = parsePhrasingContents(content.children)\n  if (isImageBlock(segments)) {\n    const imageSegment = segments[1] as ImageInlineElement\n    const imageBlockElement: ImageBlockElement = {\n      ...imageSegment,\n      type: \"image-block\",\n    }\n    return [imageBlockElement]\n  }\n  if (isSingleNBSP(segments)) {\n    return [\n      {\n        type: \"paragraph\",\n        children: [{ text: \"\" }],\n      },\n    ]\n  }\n\n  return [\n    {\n      type: \"paragraph\",\n      children: segments,\n    },\n  ]\n}\n","import type { Table, TableCell, TableRow } from \"mdast\"\n\nimport {\n  TableCellElement,\n  TableElement,\n  TableRowElement,\n} from \"~/src/table-plugin\"\n\nimport { parsePhrasingContents } from \"./parse-phrasing-content/parse-phrasing-content\"\n\nexport function parseTable(table: Table): [TableElement] {\n  if (table.align == null)\n    throw new Error(`Expected an array of AlignType for table.align`)\n  return [\n    {\n      type: \"table\",\n      columns: table.align.map((align) => ({\n        align: align || \"left\",\n      })),\n      children: table.children.map(parseTableRow),\n    },\n  ]\n}\n\nfunction parseTableRow(row: TableRow): TableRowElement {\n  if (row.type !== \"tableRow\") throw new Error(`Expected a tableRow`)\n  return { type: \"table-row\", children: row.children.map(parseTableCell) }\n}\n\nfunction parseTableCell(cell: TableCell): TableCellElement {\n  if (cell.type !== \"tableCell\") throw new Error(`Expected a tableCell`)\n  return {\n    type: \"table-cell\",\n    children: [\n      {\n        type: \"table-content\",\n        children: parsePhrasingContents(cell.children),\n      },\n    ],\n  }\n}\n","import { Element } from \"../types\"\n\nexport function parseThematicBreak(): Element[] {\n  return [\n    {\n      type: \"horizontal-rule\",\n      children: [{ text: \"\" }],\n    },\n  ]\n}\n","import type { Content, Image, Link, Parent, Root } from \"mdast\"\nimport { definitions } from \"mdast-util-definitions\"\nimport type { Node } from \"unist\"\nimport { SKIP, visit } from \"unist-util-visit\"\n\n/**\n * Based on the code from `remark-inline-links` but rewritten here because, for\n * reasons unknown to me, the plugin doesn't seem to execute at all despite not\n * throwing an error. Looks like the function that `remarkInlineLinks` returns\n * is never executed. Not sure if this is due to a change in `unified` but I\n * can't seem to find any mention anywhere of this no longer working including\n * in discussion or issues and the list of plugins show that\n * `remark-inline-links` is currently working and compatible with the lateste\n * version.\n *\n * Never-the-less, pulling it out and working on the ast directly (this function\n * modifies the AST in place) seems to work.\n *\n * https://github.com/remarkjs/remark-inline-links\n */\nexport function transformInlineLinks(tree: Root): void {\n  const definition = definitions(tree)\n\n  visit<Node>(tree as Node, (n, index, p) => {\n    const node = n as unknown as Content\n    const parent = p as unknown as Parent | null\n    if (\n      node.type === \"definition\" &&\n      parent !== null &&\n      typeof index === \"number\"\n    ) {\n      parent.children.splice(index, 1)\n      return [SKIP, index]\n    }\n\n    if (node.type === \"imageReference\" || node.type === \"linkReference\") {\n      const identifier =\n        \"identifier\" in node && typeof node.identifier === \"string\"\n          ? node.identifier\n          : \"\"\n      const def = definition(identifier)\n\n      if (def && parent !== null && typeof index === \"number\") {\n        const replacement: Image | Link =\n          node.type === \"imageReference\"\n            ? { type: \"image\", url: def.url, title: def.title, alt: node.alt }\n            : {\n                type: \"link\",\n                url: def.url,\n                title: def.title,\n                children: node.children,\n              }\n\n        parent.children[index] = replacement\n        return [SKIP, index]\n      }\n    }\n  })\n}\n","/**\n * @typedef {import('mdast').Root|import('mdast').Content} Node\n * @typedef {import('mdast').Definition} Definition\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `node`.\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} node\n */\nexport function definitions(node) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!node || !node.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(node, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /**\n   * Get a node from the bound definition cache.\n   *\n   * @param {string} identifier\n   * @returns {Definition|null}\n   */\n  function definition(identifier) {\n    const id = clean(identifier)\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n","// Note: types exported from `index.d.ts`\nexport {CONTINUE, EXIT, SKIP, visit} from './lib/index.js'\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Check if `Child` can be a child of `Ancestor`.\n *\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\n * `never`.\n *\n * @template {Node} Ancestor\n *   Node type.\n * @template {Node} Child\n *   Node type.\n * @typedef {(\n *   Ancestor extends Parent\n *     ? Child extends Ancestor['children'][number]\n *       ? Ancestor\n *       : never\n *     : never\n * )} ParentsOf\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform `parent`.\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of `parent` still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Visited extends Node ? number | null : never} index\n *   Index of `node` in `parent`.\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\n *   Parent of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * Build a typed `Visitor` function from a node and all possible parents.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Visited\n *   Node type.\n * @template {Parent} Ancestor\n *   Parent type.\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\n */\n\n/**\n * Build a typed `Visitor` function from a list of descendants and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} Descendant\n *   Node type.\n * @template {Test} Check\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromMatch<\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\n *     Extract<Descendant, Parent>\n *   >\n * )} BuildVisitorFromDescendants\n */\n\n/**\n * Build a typed `Visitor` function from a tree and a test.\n *\n * It will infer which values are passed as `node` and which as `parent`.\n *\n * @template {Node} [Tree=Node]\n *   Node type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {(\n *   BuildVisitorFromDescendants<\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\n *     Check\n *   >\n * )} BuildVisitor\n */\n\nimport {visitParents} from 'unist-util-visit-parents'\n\n/**\n * Visit nodes.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\n","import { Element } from \"../types\"\nimport { normalizeElementListDepths } from \"./normalize/normalizeElementListDepths\"\nimport { serializeElements } from \"./serialize-elements\"\n\nexport function serialize(elements: Element[]): string {\n  const normalizedElements = normalizeElementListDepths(elements)\n  return serializeElements(normalizedElements)\n}\n","import { ListItemElement } from \"~/src/list-plugin/types\"\n\nimport { Element } from \"../../types\"\n\n/**\n * Provides a type guard for `ListItemElement`.\n */\nfunction isListItemElement(element: Element): element is ListItemElement {\n  return (\n    element.type === \"ordered-list-item\" ||\n    element.type === \"unordered-list-item\" ||\n    element.type === \"task-list-item\"\n  )\n}\n\nexport function normalizeElementListDepths(elements: Element[]) {\n  const normalizedElements: Element[] = []\n\n  /**\n   * previousDepth of -1 indicates that the previous element was not a list\n   * item.\n   */\n  let previousDepth = -1\n\n  for (const element of elements) {\n    /**\n     * If it's not a list item, just reset previousDepth and add the element\n     * to `normalizedElements`.\n     */\n    if (!isListItemElement(element)) {\n      normalizedElements.push(element)\n      previousDepth = -1\n      continue\n    }\n\n    /**\n     * If it is a list item, we need to make sure the depth never increases by\n     * more than 1. This is important because if we skip the first depth (i.e.\n     * we start at depth of 2) then we get the first list indented which makes\n     * Markdown think it's a code block. After the first list item, we don't\n     * want to indent by more than one depth level because Markdown will assume\n     * that's still a single depth level. When we outdent a level, Markdown\n     * could get confused.\n     *\n     * WARNING:\n     *\n     * This does create a situation where the list in Wysimark is not saved and\n     * loaded to return the same document; however, the alternative is that we\n     * prevent the editor from creating a list which skips a depth. This could\n     * be perceived as broken UI by the user. This appraoch feels less obtrusive\n     * to the user.\n     */\n    const nextDepth =\n      element.depth > previousDepth + 1 ? previousDepth + 1 : element.depth\n    normalizedElements.push({ ...element, depth: nextDepth })\n    previousDepth = nextDepth\n  }\n\n  return normalizedElements\n}\n","import { Element } from \"../types\"\nimport { serializeElement } from \"./serialize-element\"\n\nexport function serializeElements(elements: Element[]): string {\n  const segments: string[] = []\n\n  /**\n   * The orders array keeps track of the number of ordered list items at each\n   * depth. This is used to generate the number for each ordered list item.\n   */\n  let orders: number[] = []\n\n  for (const element of elements) {\n    if (element.type === \"ordered-list-item\") {\n      /**\n       * When we're at an ordered list item, we increment the order at the\n       * current depth level and we remove any orders at a deeper depth level.\n       */\n      orders[element.depth] = (orders[element.depth] || 0) + 1\n      orders = orders.slice(0, element.depth + 1)\n    } else if (\n      element.type === \"unordered-list-item\" ||\n      element.type === \"task-list-item\"\n    ) {\n      /**\n       * When we're at an unordered list item, we slice the orders array to\n       * remove any orders at a deeper depth level.\n       */\n      orders = orders.slice(0, element.depth)\n    } else {\n      /**\n       * When we're at any other element, we reset the orders array because\n       * we're no longer in a list.\n       */\n      orders = []\n    }\n\n    segments.push(serializeElement(element, orders))\n  }\n  /**\n   * NOTE:\n   *\n   * We remove trailing whitespace because we want minimum viable markdown.\n   * It also makes it easier to test.\n   */\n  const joined = segments.join(\"\") //.trim()\n\n  /**\n   * If there is no content return an empty string for the Markdown.\n   */\n  if (joined.trim() === \"\") return \"\"\n\n  /**\n   * The following code replaces consecutive newlines with a single newline\n   * with a bit of additional logic to handle newlines at the beginning.\n   */\n  return replaceConsecutiveNewlines(replaceLeadingNewlines(joined)).trim()\n}\n\n/**\n * Replace two leading newlines with a non-breaking space to indicate a\n * paragraph that won't be collapsed.\n */\nfunction replaceLeadingNewlines(input: string): string {\n  return input.replace(/^\\n\\n/g, \"&nbsp;\\n\\n\")\n}\n\n/**\n * In the rest of the Markdown, replace four or more consecutive newlines with\n * non-breaking spaces and newlines to indicate a paragraph that won't be\n * collapsed.\n */\nfunction replaceConsecutiveNewlines(input: string): string {\n  return input.replace(/(\\n{4,})/g, (match) => {\n    const newlineCount = match.length\n    const count = Math.floor((newlineCount - 2) / 2)\n    return \"\\n\\n\" + Array(count).fill(\"&nbsp;\").join(\"\\n\\n\") + \"\\n\\n\"\n  })\n}\n","import { Element, Segment } from \"../types\"\nimport { assertUnreachable } from \"../utils\"\nimport { serializeCodeBlock } from \"./serialize-code-block\"\nimport { serializeElements } from \"./serialize-elements\"\nimport { serializeImageBlock } from \"./serialize-image-block\"\nimport { serializeLine } from \"./serialize-line\"\nimport { serializeTable } from \"./serialize-table\"\n\nconst LIST_INDENT_SIZE = 4\n\nexport function serializeElement(element: Element, orders: number[]): string {\n  switch (element.type) {\n    case \"anchor\":\n      return `[${serializeLine(element.children as Segment[])}](${\n        element.href\n      })`\n    case \"block-quote\": {\n      const lines = serializeElements(element.children as Element[])\n      return `${lines\n        .split(\"\\n\")\n        .map((line) => `> ${line}`.trim())\n        .join(\"\\n\")}\\n\\n`\n    }\n    case \"code-block\":\n      return serializeCodeBlock(element)\n    case \"code-block-line\":\n      throw new Error(\n        `code-block-line should only be present as child of code-block`\n      )\n    case \"heading\":\n      return `${\"#\".repeat(element.level)} ${serializeLine(\n        element.children as Segment[]\n      )}\\n\\n`\n    case \"horizontal-rule\":\n      return \"---\\n\\n\"\n    case \"paragraph\":\n      return `${serializeLine(element.children as Segment[])}\\n\\n`\n    /**\n     * Table\n     */\n    case \"table\":\n      return serializeTable(element)\n    case \"table-row\":\n    case \"table-cell\":\n    case \"table-content\":\n      throw new Error(\n        `Table elements should only be present as children of table which should be handled by serializeTable. Got ${element.type} may indicate an error in normalization.`\n      )\n    /**\n     * List\n     */\n    case \"unordered-list-item\": {\n      const indent = \" \".repeat(element.depth * LIST_INDENT_SIZE)\n      return `${indent}- ${serializeLine(element.children as Segment[])}\\n\\n`\n    }\n    case \"ordered-list-item\": {\n      const indent = \" \".repeat(element.depth * LIST_INDENT_SIZE)\n      return `${indent}${orders[element.depth]}. ${serializeLine(\n        element.children as Segment[]\n      )}\\n\\n`\n    }\n    case \"task-list-item\": {\n      const indent = \" \".repeat(element.depth * LIST_INDENT_SIZE)\n      let line = serializeLine(element.children as Segment[])\n      if (line.trim() === \"\") {\n        line = \"&#32;\"\n      }\n      return `${indent}- [${element.checked ? \"x\" : \" \"}] ${line}\\n\\n`\n    }\n    case \"image-block\":\n      return serializeImageBlock(element)\n    case \"image-inline\":\n      throw new Error(\n        `This shouldn't happen because inlines are handled in serializeSegment`\n      )\n  }\n  assertUnreachable(element)\n}\n","import { CodeBlockElement } from \"~/src/code-block-plugin\"\n\nimport { serializeCodeLine } from \"./serialize-code-line\"\n\n/**\n * Serializing a code block is usually three backticks folloed by the language,\n * then the code is raw verbatim and then three backticks to close.\n *\n * However, we have to account for if any line in the code starts with three\n * backticks. In that case, we need to start our code block with 4 backticks.\n * And if there are 4 backticks in the code, then we need to start it with 5.\n *\n * We always need to start our code block with one more backtick than can be\n * found starting any line in the code block.\n */\nexport function serializeCodeBlock(codeBlock: CodeBlockElement): string {\n  const lines: string[] = []\n  /**\n   * Start with the default number of backticks\n   */\n  let backticks = 3\n  for (const codeLine of codeBlock.children) {\n    /**\n     * Grab a raw code line from it\n     */\n    const lineOfCode = serializeCodeLine(codeLine)\n    /**\n     * Check if it starts with any backticks and if it does, make our backticks\n     * one larger than the largest one.\n     */\n    const match = lineOfCode.match(/^([`]+)/)\n    if (match) backticks = Math.max(backticks, match[1].length + 1)\n    /**\n     * Add it to our lines\n     */\n    lines.push(lineOfCode)\n  }\n  /**\n   * At the very end, when we know how many backticks we need, add our backticks\n   * and language at the start and the closing backticks at the end.\n   */\n  lines.unshift(`${\"`\".repeat(backticks)}${codeBlock.language}`)\n  lines.push(`${\"`\".repeat(backticks)}`)\n  return `${lines.join(\"\\n\")}\\n\\n`\n}\n","import { CodeBlockLineElement } from \"~/src/code-block-plugin\"\n\n/**\n * Serializing a code line is simple under the assumption that the normalizers\n * in Wysimark are working correctly. Technically, a code-line should have\n * exactly one child with one `Text` node with no marks in it.\n */\nexport function serializeCodeLine(codeLine: CodeBlockLineElement): string {\n  /**\n   * As a safety measure, we make sure that we are receiving a `codeLine`\n   */\n  if (codeLine.type !== \"code-block-line\")\n    throw new Error(\n      `Expected all children of code-block to be a codeline but is ${JSON.stringify(\n        codeLine,\n        null,\n        2\n      )}`\n    )\n  /**\n   * We are converting all segments under the assumption that they are text\n   * segments.\n   */\n  return codeLine.children.map((segment) => segment.text).join(\"\")\n}\n","import { ImageBlockElement } from \"~/src/image-plugin/types\"\n\nimport { serializeImageShared } from \"../serialize-image-shared\"\n\nexport function serializeImageBlock(element: ImageBlockElement): string {\n  return serializeImageShared(element)\n}\n","import { ImageSharedElement } from \"~/src/image-plugin/types\"\n\nimport { serializeGenericImageUrl } from \"./serialize-generic-image-url\"\nimport { serializePortiveImageUrl } from \"./serialize-portive-image-url\"\nimport { serializeUncommonmarkImageUrl } from \"./serialize-uncommonmark-image-url\"\n\nconst urlSerializers = [\n  serializePortiveImageUrl,\n  serializeUncommonmarkImageUrl,\n  serializeGenericImageUrl,\n]\n\nexport function serializeImageShared(image: ImageSharedElement): string {\n  for (const urlSerializer of urlSerializers) {\n    const url = urlSerializer(image)\n    if (typeof url === \"string\") {\n      /**\n       * Sometimes the serialized URL will return \"\" which means that the URL\n       * hasn't returned yet. When this happens, we don't want the markdown for\n       * the image to be added to the final value because the image would be\n       * invalid. This happens when the image is uploading.\n       */\n      if (url === \"\") return \"\"\n      return `![${image.alt}](${url}${\n        typeof image.title === \"string\" ? ` \"${image.title}\"` : \"\"\n      })`\n    }\n  }\n  /**\n   * Shouldn't get here because the last url seializer `serializeGenericUrl`\n   * always returns a value.\n   */\n  throw new Error(`Shouldn't get here`)\n}\n","import { ImageSharedElement } from \"~/src/image-plugin/types\"\n\n/**\n * As a fallback, if there is no width/height or srcWidth/srcHeight info then\n * just save the image url and do not save with uncommonMark hints.\n */\nexport function serializeGenericImageUrl(image: ImageSharedElement): string {\n  return image.url\n}\n","import { ImageSharedElement } from \"~/src/image-plugin/types\"\n\nimport { parseUrl } from \"../../parseUrl\"\n\n/**\n * When an image is in the `.portive.com` subdomain like `files.portive.com` or\n * `staging.files.portive.com` and if the image has a `width` and `height` then\n * we encode the `width` and `height in the `url` as part of the query string.\n *\n * https://files.portive.com/f/abcdef--640x480.jpg?size=320x240\n *\n * Indicates a src image of 640x480 that will be resized and sent to the browser\n * at 320x240\n *\n * This does these things:\n *\n * - When parsing the image URL, we are able to pull the width/height out of the\n *   URL and use it to populate those values in the editor.\n *\n * - The query string will also physically resize the image before delivering it\n *   from Portive. This means that in regular Markdown that doesn't have any\n *   special understanding of Portive's special querystring encodings, the image\n *   is still returned in the correct size.\n */\nexport function serializePortiveImageUrl(\n  image: ImageSharedElement\n): string | undefined {\n  if (image.url.startsWith(\"$\")) return \"\"\n  const { hostname } = parseUrl(image.url)\n  /**\n   * Only parse portive URL if it is a portive recognized domain\n   */\n  if (hostname.match(/[.]portive[.]com$/i) && image.width && image.height)\n    return `${image.url}?size=${image.width}x${image.height}`\n}\n","import { ImageSharedElement } from \"~/src/image-plugin/types\"\n\n/**\n * In UncommonMark, we provide hints after the hash `#` portion of the URL that\n * does not affect the URL of the image being delivered. It is usually used to\n * tell the browser to scroll to the given section in a linked document.\n *\n * https://imageservice.com/abcdefg.jpg#srcSize=1024x768&size=640x480\n */\nexport function serializeUncommonmarkImageUrl(\n  image: ImageSharedElement\n): string | undefined {\n  if (image.width && image.height && image.srcWidth && image.srcHeight)\n    return `${image.url}#srcSize=${image.srcWidth}x${image.srcHeight}&size=${image.width}x${image.height}`\n}\n","export * from \"./serialize-line\"\n","import { Element as SlateElement, Text as SlateText } from \"slate\"\n\nimport { MarkKey, Segment } from \"../../types\"\nimport { diffMarks } from \"./diff-marks\"\nimport { normalizeLine } from \"./normalize-line\"\nimport { serializeSegment } from \"./segment/serialize-segment\"\nimport {\n  convertMarksToSymbolsExceptCode,\n  getMarksFromSegment,\n  isPlainSpace,\n} from \"./utils\"\n\n/**\n * Takes a line (an array of Segment) and turns it into markdown.\n *\n * The majority of this code deals with how we convert marks like `bold` and\n * `italic` into symbols and where to place them. There are several complicated\n * cases we need to handle like:\n *\n * - Symbols must always be placed on the inside of spaces next to the word like\n *   \" **bold** \" and not \"** bold **\". We need to be aware of our placement of\n *   symbols around spaces but spaces themselves can safely and actually must\n *   ignore the actual marks on them. A bold space and a not-bold space are\n *   considered the same in Markdown.\n * - Anchors must have common marks moved out of them\n * - Anchors must have not common marks set inside of them\n */\nexport function serializeLine(\n  inputSegments: Segment[],\n  leadingMarks: MarkKey[] = [],\n  trailingMarks: MarkKey[] = []\n): string {\n  /**\n   * Normalize line does a lot of the work here to take any spaces that can be\n   * found around the edges of segments and turns them into their own segments.\n   * We don't need to do this in spaces on the inside of segments though.\n   *\n   * This is important because at the boundaries of segments, that's when marks\n   * change (e.g. bold/italic) and it is at these points, we need to put spaces\n   * into separate segments so that we can place the symbols for the marks\n   * around them.\n   */\n  const segments = normalizeLine(inputSegments)\n  const substrings: string[] = []\n\n  /**\n   * In order to seed the loop, we start by creating a `leadingDiff` going from\n   * the `leadingMarks` provided to this method and the marks in the first\n   * segment.\n   *\n   * The `leadingMarks` will always be `[]` at the beginning. When we get into a\n   * nested `anchor` though, there may be some marks that had been previously\n   * set outside of the anchor that need to be considered.\n   */\n  let leadingDiff = diffMarks(leadingMarks, getMarksFromSegment(segments[0]))\n\n  /**\n   * In each iteration, we want to serialize the following:\n   *\n   * - Symbols that represent all the marks to add to this segment\n   * - The markdown for the segment itself (text, inline code, anchor, inline\n   *   image)\n   * - Symbols that represent all the marks to remove from this segment\n   */\n  for (let i = 0; i < segments.length; i++) {\n    /**\n     * This is the current segment that we are looking at.\n     */\n    const segment = segments[i]\n\n    /**\n     * If it's plain space, add it to markdown and start at the top of the loop\n     * again\n     *\n     * Basically, ignore the symbols we need to add when it's a space.\n     *\n     * The symbols get handled by the non-space segments.\n     *\n     * When we continue, we end up with the same `leadingDiff` from the last\n     * segment which is what we want. This is because the `leadingDiff` actually\n     * applies to the next Segment which should be either a not space Text or an\n     * Element.\n     */\n    if (SlateText.isText(segment) && isPlainSpace(segment)) {\n      substrings.push(segment.text)\n      continue\n    }\n\n    /**\n     * Here is where we add the serialization of the segment.\n     *\n     * First we start by adding the symbols needed to add the marks to this\n     * segment.\n     */\n    substrings.push(convertMarksToSymbolsExceptCode(leadingDiff.add))\n\n    /**\n     * Then we add the Text or the Anchor for the segment\n     */\n    substrings.push(serializeSegment(segment))\n\n    /**\n     * Now we are searching for the next segment which we want to grab the marks\n     * from. Basically, any segment that isn't a space. For clarity, in this\n     * algorithm, we should never have two `isPlainSpace` segments in a row\n     * because this would have been normalized to one `isPlainSpace` segment in\n     * the call to `normalizeLine`\n     */\n    const nextMarks = getNextMarks(segments, i, trailingMarks)\n    const trailingDiff = diffMarks(leadingDiff.nextOrderedMarks, nextMarks)\n    substrings.push(convertMarksToSymbolsExceptCode(trailingDiff.remove))\n\n    /**\n     * The `trailingDiff` becomes the new `leadingDiff`\n     */\n    leadingDiff = trailingDiff\n  }\n  return substrings.join(\"\")\n}\n\n/**\n * Looks for the next set of valid marks by\n *\n * This method is local to `serialize-line` as it's intimiately tied with the\n * call to `getNextMarks` in `serializeLine`\n */\nfunction getNextMarks(\n  segments: Segment[],\n  index: number,\n  trailingMarks: MarkKey[]\n): MarkKey[] {\n  /**\n   * Starting at the index `i` following the current index `index`\n   *\n   * If it's a plain space, skip it.\n   *\n   * If it isn't, get the marks for the segment.\n   *\n   * NOTE:\n   *\n   * If the segment is an `anchor` we the common marks for all the segments in\n   * the anchor not including the plain spaces.\n   */\n  for (let i = index + 1; i < segments.length; i++) {\n    const segment = segments[i]\n    if (isPlainSpace(segment)) continue\n    if (SlateElement.isElement(segment) && segment.type === \"image-inline\")\n      continue\n    return getMarksFromSegment(segment)\n  }\n  return trailingMarks\n}\n","import { MarkKey } from \"../../../types\"\nimport { findMarksToAdd } from \"./find-marks-to-add\"\nimport { findMarksToRemove } from \"./find-marks-to-remove\"\n\n/**\n * Takes a set of incoming marks and a set of target markets and returns what\n * marks need to be removed including the order in which they need to be removed\n * and what marks need to be added including the order in which they needed to\n * be added.\n *\n * The algorithm, collectively, is a little complex because we must always\n * remove an inner set of mark symbols before we can remove an outer set. This\n * means that sometimes when we want to remove a mark, we end up actually having\n * to add one. Like in this scenario:\n *\n * **_bold italic_** _italic_\n *\n * In order to go from bold and italic to just italic, we need to first remove\n * the inner italic, then remove the outer bold, and because the italic was\n * removed we need to add back the italic.\n *\n * Note that the algorithm is asymmetrical. It's just the way it has to be.\n */\nexport function diffMarks(orderedMarks: MarkKey[], targetMarks: MarkKey[]) {\n  /**\n   * First we remove the marks in order to arrive at our target marks.\n   *\n   * The algorithm basically just takes off the inner-most (right-most) marks\n   * and adds them to `marsToRemove` until we don't have any marks that aren't\n   * also in the `targetMarks`.\n   *\n   * Because we may be over-removing the marks, the method returns a\n   * `nextOrderedMarks` or basically the `orderedMarks` after the remove has\n   * happened. We then use this as the basis to add any marks we need back to\n   * arrive at our `targetMarks`.\n   */\n  const { orderedMarksToRemove, nextOrderedMarks } = findMarksToRemove(\n    orderedMarks,\n    targetMarks\n  )\n  /**\n   * We call out to a method that adds the necessary marks back in. The\n   * algorithm here is pretty straightforward. Just add back the marks we need\n   * and to achieve some level of consistency, add them back in a specific order\n   * that feels nice and makes sense. For example, superscript/subscript is more\n   * nested than bold because they are more likely to be toggled.\n   */\n  const { orderedMarksToAdd } = findMarksToAdd(nextOrderedMarks, targetMarks)\n  return {\n    remove: orderedMarksToRemove,\n    add: orderedMarksToAdd,\n    nextOrderedMarks: [...nextOrderedMarks, ...orderedMarksToAdd],\n  }\n}\n","import { MarkKey } from \"../../../types\"\nimport { sortMarks } from \"../utils\"\n\n/**\n * Find the marks to add in ordere to get our orderedMarks to match the\n * `targetMarks`.\n *\n * We do this in a smart, but perhaps, imperfect way.\n *\n * When we need to add marks, we add them in an order that is more likely to\n * reduce the number of marks we add. See the comments under `MARK_KEY_ORDER` to\n * find out how.\n *\n * That said, we could probably choose a more complex algorithm that looks at\n * all the text to find out how to most efficiently place which marks as outer\n * or inner marks; however, there will still be situations in which the choice\n * will be arbitrary and this would likely greatly increase the complexity of\n * the code.\n *\n * This feels like a good trade-off and is likely to cause an unreadable\n * markdown representation. I suppose if for some reason a user had a bunch of\n * superscripted text which was intermittently styled with bold and italic, then\n * we'd have less than ideal markdown.\n */\nexport function findMarksToAdd(\n  orderedMarks: MarkKey[],\n  targetMarks: MarkKey[]\n) {\n  const marksWeNeedToAdd = targetMarks.filter(\n    (mark) => !orderedMarks.includes(mark)\n  )\n  const orderedMarksToAdd = sortMarks(marksWeNeedToAdd)\n  return { orderedMarksToAdd }\n}\n","import { MarkKey } from \"../../../types\"\n\n/**\n * Takes a list of our current `orderedMarks` (i.e. what marks have been applied\n * to our text and in which order) and then gives us a list of `targetMarks`\n * which, for clarity, the order doesn't matter.\n *\n * We then create a list of `orderedMarksToRemove` which is a list of marks we\n * need to remove in the correct order, in order to satisfy that there aren't\n * any marks left that aren't also in the `targetMarks`.\n */\nexport function findMarksToRemove(\n  orderedMarks: MarkKey[],\n  targetMarks: MarkKey[]\n): { orderedMarksToRemove: MarkKey[]; nextOrderedMarks: MarkKey[] } {\n  /**\n   * As a good practice, don't manipulate the incoming argument (even though\n   * technically it doesn't matter here)\n   */\n  const nextOrderedMarks = [...orderedMarks]\n\n  /**\n   * Find the marks that we need to remove.\n   */\n  const marksWeNeedToRemove = orderedMarks.filter(\n    (mark) => !targetMarks.includes(mark)\n  )\n\n  /**\n   * An ordered array of marks to remove\n   */\n  const orderedMarksToRemove: MarkKey[] = []\n\n  /**\n   * We iterate a maximum number of times with an upper limit of\n   * `nextOrderedMarks.length` to prevent infinite loops.\n   *\n   * If we meet our condition of removing all the `marksWeNeedToRemove` we are\n   * going to break out of this loop early which is common. Used a for loop\n   * instead of counting the number of loops and throwing an error.\n   */\n  for (let i = 0; i < orderedMarks.length; i++) {\n    /**\n     * If we don't have any more marks we need to remove, we are done so leave\n     * the loop.\n     */\n    if (marksWeNeedToRemove.length === 0) break\n    /**\n     * Remove the last mark\n     */\n    const markToRemove = nextOrderedMarks.pop()\n    if (markToRemove === undefined) {\n      throw new Error(\n        `This shouldn't happen unless we made a mistake in the algorithm`\n      )\n    }\n    /**\n     * Add to our `orderedMarkToRemove` which is done in the correct order\n     * because we are popping them off from the right.\n     */\n    orderedMarksToRemove.push(markToRemove)\n\n    /**\n     * Whatever we added to our list of `orderedMarksToRemove` we can now take\n     * off our list of `marksWeNeedToRemove`. Sometimes we will be removed marks\n     * that don't take anything off our list of `marksWeNeedToRemove` because of\n     * the order in which we need to remove marks.\n     *\n     * For this reason, the check to see if the `mark` was in our list of\n     * `marksWeNeedToRemove` is important.\n     */\n    const index = marksWeNeedToRemove.indexOf(markToRemove)\n    if (index !== -1) {\n      marksWeNeedToRemove.splice(index, 1)\n    }\n  }\n\n  return { orderedMarksToRemove, nextOrderedMarks }\n}\n","import { Element } from \"slate\"\n\nimport { Segment } from \"../../../types\"\nimport { normalizeNodes } from \"./normalize-nodes\"\nimport { LineElement } from \"./types\"\n\n/**\n * A very focused duplicate function that only duplicates the `children` of\n * `anchor` elements.\n *\n * It's designed this way to be fast and to avoid duplicating the entire tree\n * as only anchors have children that will be manipulated.\n */\nconst duplicateSegments = (segments: Segment[]): Segment[] => {\n  return segments.map((segment) => {\n    if (Element.isElement(segment) && segment.type === \"anchor\") {\n      return {\n        ...segment,\n        children: duplicateSegments(segment.children as Segment[]),\n      }\n    } else {\n      return segment\n    }\n  })\n}\n\n/**\n * Entry Point for normalizing\n */\nexport function normalizeLine(segments: Segment[]) {\n  /**\n   * We need to duplicate `segments` because `normalizeNodes` will manipulate the\n   * array but the original array coming from Slate will be readOnly.\n   */\n  const line: LineElement = {\n    type: \"line\",\n    children: duplicateSegments(segments),\n  }\n  normalizeNodes([line], undefined)\n  return line.children\n}\n","import { AnchorElement } from \"~/src/anchor-plugin\"\n\nimport { isElement } from \"../utils\"\nimport { runNormalizersOnNode } from \"./run-normalizers-on-node\"\nimport { LineElement, Node, NormalizeOptions } from \"./types\"\n\nconst MAX_RERUNS = 72\n\nexport function normalizeNodes(\n  nodes: Node[],\n  parent?: AnchorElement | LineElement\n): boolean {\n  let isAnyUpdated = false\n  let isUpdated\n  let runs = 0\n  const maxReruns = (nodes.length + 1) * MAX_RERUNS\n  do {\n    isUpdated = false\n    runs = runs + 1\n    if (runs > maxReruns)\n      throw new Error(\n        `There have been ${runs} normalization passes (72x the number of nodes at this level). This likely indicates a bug in the code.`\n      )\n    segmentLoop: for (let i = 0; i < nodes.length; i++) {\n      const node: Node = nodes[i]\n      /**\n       * Normalize the children of the current Node before normalizing the\n       * Node itself.\n       */\n      if (isElement(node)) {\n        const isChildrenUpdated = normalizeNodes(\n          node.children as Array<AnchorElement | LineElement>,\n          node\n        )\n        if (isChildrenUpdated) {\n          isUpdated = true\n          isAnyUpdated = true\n          break segmentLoop\n        }\n      }\n      /**\n       * Create the normalizeOptions\n       */\n      const prevNode: Node | undefined = nodes[i - 1]\n      const nextNode: Node | undefined = nodes[i + 1]\n      const options: NormalizeOptions = {\n        parent,\n        node,\n        prevNode,\n        nextNode,\n        index: i,\n        nodes,\n      }\n\n      /**\n       * Run the normalizers on this node.\n       */\n      if (runNormalizersOnNode(options)) {\n        isUpdated = true\n        isAnyUpdated = true\n        break segmentLoop\n      }\n    }\n  } while (isUpdated)\n  return isAnyUpdated\n}\n","import { normalizers } from \"./normalizers\"\nimport { NormalizeOptions } from \"./types\"\n\n/**\n * Attempts to run all normalizers on the given Node one by one.\n *\n * If any normalizer makes an update, this function exits immediately and\n * returns a `true` value indicating that a normalizer has made an update.\n *\n * Because we don't know how that update modified the data structure, another\n * pass will be made at running all the normalizers.\n *\n * This is not the most efficient route, but there isn't a lot of processing\n * we need to do and this reduces the likelihood of bugs. Normalization is\n * similar to how it works in Slate but we don't keep track of dirty paths\n * and simply rerun the normalizations at the given level until it is clean.\n */\nexport function runNormalizersOnNode(normalizeOptions: NormalizeOptions) {\n  for (const normalizer of normalizers) {\n    const isHandled = normalizer(normalizeOptions)\n    if (isHandled) {\n      return true\n    }\n  }\n  return false\n}\n","import { NormalizeOptions } from \"../types\"\nimport { mergeAdjacentSpaces } from \"./merge-adjacent-spaces\"\nimport {\n  moveSpacesAtEndOfAnchor,\n  moveSpacesAtStartOfAnchor,\n} from \"./move-spaces-out-of-anchors\"\nimport { mustHaveOneTextChild } from \"./must-have-one-text-child\"\nimport { sliceSpacesAtNodeBoundaries } from \"./slice-spaces-at-node-boundaries\"\nimport { trimSpaceAtEndOfLine } from \"./trim-spaces-at-end-of-line\"\nimport { trimSpaceAtStartOfLine } from \"./trim-spaces-at-start-of-line\"\n\nexport const normalizers: Array<(options: NormalizeOptions) => boolean> = [\n  sliceSpacesAtNodeBoundaries,\n  moveSpacesAtStartOfAnchor,\n  moveSpacesAtEndOfAnchor,\n  mergeAdjacentSpaces,\n  trimSpaceAtStartOfLine,\n  trimSpaceAtEndOfLine,\n  mustHaveOneTextChild,\n]\n","import { isPlainSpace, isText } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\n/**\n * If we ever find two spaces next to each other, merge them together.\n *\n * This can happen, for example, if there were spaces next to each other but\n * with different marks. It can also happen from other normalizers. For example,\n * there is a normalizer that moves spaces at the outer edges of an anchor\n * outside of the anchor.\n */\nexport function mergeAdjacentSpaces({\n  node,\n  nextNode,\n  nodes: nodes,\n  index,\n}: NormalizeOptions): boolean {\n  if (!isText(node) || !isPlainSpace(node) || node.code) return false\n  if (!isText(nextNode) || !isPlainSpace(nextNode) || node.code) return false\n  nodes.splice(index, 2, { text: `${node.text}${nextNode.text}` })\n  return true\n}\n","import { Segment } from \"../../../../types\"\nimport { isElement, isPlainSpace, isText } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\nexport function moveSpacesAtStartOfAnchor({\n  node,\n  nodes,\n  prevNode,\n  index,\n}: NormalizeOptions): boolean {\n  if (!isElement(node)) return false\n  if (node.type !== \"anchor\") return false\n  node\n  const firstChild = node.children[0] as Segment\n  if (isText(firstChild) && isPlainSpace(firstChild)) {\n    // remove the first child from the anchor\n    node.children.splice(0, 1)\n    // add the first child\n    if (isText(prevNode) && isPlainSpace(prevNode)) {\n      prevNode.text = `${prevNode.text}${firstChild.text}`\n    } else {\n      nodes.splice(index, 0, { text: firstChild.text })\n    }\n    return true\n  }\n  return false\n}\n\nexport function moveSpacesAtEndOfAnchor({\n  node,\n  nodes,\n  nextNode,\n  index,\n}: NormalizeOptions): boolean {\n  if (!isElement(node)) return false\n  if (node.type !== \"anchor\") return false\n  node\n  const lastChild = node.children[node.children.length - 1] as Segment\n  if (isText(lastChild) && isPlainSpace(lastChild)) {\n    // remove the first child from the anchor\n    node.children.splice(node.children.length - 1, 1)\n    // add the first child\n    if (isText(nextNode) && isPlainSpace(nextNode)) {\n      nextNode.text = `${lastChild.text}${nextNode.text}`\n    } else {\n      nodes.splice(index + 1, 0, { text: lastChild.text })\n    }\n    return true\n  }\n  return false\n}\n","import { isElement } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\nexport function mustHaveOneTextChild({ node }: NormalizeOptions): boolean {\n  if (!isElement(node)) return false\n  if (node.type !== \"line\") return false\n  if (node.children.length > 0) return false\n  node.children.push({ text: \"\" })\n  return true\n}\n","import { Text } from \"../../../../types\"\nimport { isPlainSpace, isText } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\n/**\n * If a Text Node has spaces at the very start, or at the very end, we slice\n * those spaces into their own nodes.\n *\n * This is to help us later with the serialize process because we need spaces\n * to be isolated so that when we apple tokens like `**bold**` we are able\n * to place the tokens so that they are always against the non-space characters.\n *\n * For example, `** bold**` would not bold the text because the `**` is not\n * touching the word `bold` on the left.\n *\n * The algorithm here works by looking for a RegExp match on spaces on the\n * left or the right. If either are found, then it splits it into three parts\n * (left space, middle and right space) and then filteres out any zero length\n * spaces at the end. In this way, we handle left and right spaces in one\n * pass.\n */\nexport function sliceSpacesAtNodeBoundaries({\n  node,\n  nodes,\n  index,\n}: NormalizeOptions): boolean {\n  if (!isText(node)) return false\n  if (isPlainSpace(node)) return false\n  /**\n   * The content of Inline Code is literal so don't move the spaces out of it.\n   */\n  if (node.code) return false\n  const match = node.text.match(/^(\\s*)(.*?)(\\s*)$/)\n  if (!match) return false\n  if (match[1].length === 0 && match[3].length === 0) return false\n  const nextSegments: Text[] = [\n    { text: match[1] },\n    { ...node, text: match[2] },\n    { text: match[3] },\n  ].filter((text) => text.text !== \"\")\n  nodes.splice(index, 1, ...nextSegments)\n  return true\n}\n","import { isElement, isPlainSpace, isText } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\nexport function trimSpaceAtEndOfLine({\n  index,\n  nodes,\n  node,\n  parent,\n}: NormalizeOptions): boolean {\n  if (index !== nodes.length - 1) return false\n  if (nodes.length <= 1) return false\n  if (!isText(node)) return false\n  if (!isPlainSpace(node)) return false\n  if (parent && isElement(parent) && parent.type === \"line\") {\n    nodes.splice(nodes.length - 1, 1)\n    return true\n  }\n  return false\n}\n","import { isElement, isPlainSpace, isText } from \"../../utils\"\nimport { NormalizeOptions } from \"../types\"\n\nexport function trimSpaceAtStartOfLine({\n  index,\n  nodes,\n  node,\n  parent,\n}: NormalizeOptions): boolean {\n  if (index !== 0) return false\n  if (nodes.length === 0) return false\n  if (!isText(node)) return false\n  if (!isPlainSpace(node)) return false\n  if (parent && isElement(parent) && parent.type === \"line\") {\n    nodes.splice(0, 1)\n    return true\n  }\n  return false\n}\n","import { Text as SlateText } from \"slate\"\n\nimport { Segment } from \"../../../types\"\nimport { assertUnreachable } from \"../../../utils\"\nimport { serializeImageShared } from \"../../serialize-image-shared\"\nimport { serializeCodeText } from \"../segment/serialize-code-text\"\nimport { serializeAnchor } from \"./serialize-anchor\"\nimport { serializeNonCodeText } from \"./serialize-non-code-text\"\n\nexport function serializeSegment(segment: Segment): string {\n  if (SlateText.isText(segment)) {\n    /**\n     * If the segment is a `code` segment, we need to use a different strategy\n     * for escaping the `code` segment. This is why it needs a separate\n     * serializing function.\n     */\n    if (segment.code) return serializeCodeText(segment)\n    /**\n     * Otherwise, we use the standard text escaping code.\n     */\n    return serializeNonCodeText(segment)\n  }\n  switch (segment.type) {\n    case \"anchor\": {\n      return serializeAnchor(segment)\n    }\n    case \"image-inline\":\n      return serializeImageShared(segment)\n    default:\n      assertUnreachable(segment)\n  }\n}\n","import { Text } from \"../../../types\"\n\nexport function serializeCodeText(text: Text): string {\n  let max = 0\n  for (const match of text.text.matchAll(/[`]+/g)) {\n    max = Math.max(max, match[0].length)\n  }\n  if (max === 0) return `\\`${text.text.replace(/[`]/g, \"\\\\`\")}\\``\n  return `${\"`\".repeat(max + 1)} ${text.text} ${\"`\".repeat(max + 1)}`\n}\n","import { AnchorElement } from \"~/src/anchor-plugin\"\n\nimport { Segment } from \"../../../types\"\nimport { serializeLine } from \"../serialize-line\"\nimport { getCommonAnchorMarks } from \"../utils\"\n\nfunction escapeTitle(title: string): string {\n  return title.replace(/\"/g, '\\\\\"')\n}\n\nexport function serializeAnchor(anchor: AnchorElement): string {\n  const commonAnchorMarks = getCommonAnchorMarks(anchor.children as Segment[])\n  if (anchor.href.startsWith(\"$\"))\n    return serializeLine(\n      anchor.children as Segment[],\n      commonAnchorMarks,\n      commonAnchorMarks\n    )\n  if (typeof anchor.title === \"string\" && anchor.title.length > 0) {\n    return (\n      /**\n       * TODO: Handle anchor children more elegantly in serializeAnchor.\n       *\n       * We type cast `children` as `Segment` here because the children of an\n       * `anchor` is limited to be Inline types. There are two things to do\n       * related to this though:\n       *\n       * - [ ] consider fixing the `anchor` type to actually limit the\n       *   children as expected.\n       * - [ ] consider expanding the definition of `Segment` to include\n       *   inline images as that is an acceptable inline value which is\n       *   currently not defined as part of Segment.\n       */\n      `[${serializeLine(\n        anchor.children as Segment[],\n        commonAnchorMarks,\n        commonAnchorMarks\n      )}](${anchor.href} \"${escapeTitle(anchor.title)}\")`\n    )\n  } else {\n    return (\n      /**\n       * TODO: Handle anchor children more elegantly in serializeAnchor.\n       *\n       * We type cast `children` as `Segment` here because the children of an\n       * `anchor` is limited to be Inline types. There are two things to do\n       * related to this though:\n       *\n       * - [ ] consider fixing the `anchor` type to actually limit the\n       *   children as expected.\n       * - [ ] consider expanding the definition of `Segment` to include\n       *   inline images as that is an acceptable inline value which is\n       *   currently not defined as part of Segment.\n       */\n      `[${serializeLine(\n        anchor.children as Segment[],\n        commonAnchorMarks,\n        commonAnchorMarks\n      )}](${anchor.href})`\n    )\n  }\n}\n","import { Text } from \"../../../types\"\nimport { escapeText } from \"../utils\"\n\nexport function serializeNonCodeText(text: Text): string {\n  return escapeText(text.text)\n}\n","import {\n  TableCellElement,\n  TableColumnAlign,\n  TableContentElement,\n  TableElement,\n  TableRowElement,\n} from \"~/src/table-plugin\"\n\nimport { Segment } from \"../../types\"\nimport { assert, assertElementType } from \"../../utils\"\nimport { serializeLine } from \"../serialize-line\"\n\nexport function serializeTable(element: TableElement): string {\n  const lines: string[] = []\n  lines.push(serializeTableRow(element.children[0]))\n  lines.push(serializeColumns(element.columns))\n  element.children.slice(1).forEach((row) => {\n    lines.push(serializeTableRow(row))\n  })\n  return `${lines.join(\"\\n\")}\\n\\n`\n}\n\nfunction serializeColumns(columns: TableElement[\"columns\"]): string {\n  const isAllLeft = columns.every((column) => column.align === \"left\")\n  /**\n   * If all of the columns are to the left, it looks nicer if we don't specify\n   * column alignment in the markdown at all. Just use the default `---` to\n   * specify each column.\n   */\n  if (isAllLeft) {\n    return `|${columns.map(() => \"---\").join(\"|\")}|`\n  }\n  /**\n   * If one or more of the columns is not aligned left, let's add some clarity\n   * and specify the alignment of all the columns including the `left` aligned\n   * ones.\n   */\n  return `|${columns.map((column) => serializeAlign(column.align)).join(\"|\")}|`\n}\n\nfunction serializeAlign(align: TableColumnAlign) {\n  switch (align) {\n    case \"left\":\n      return \":---\"\n    case \"center\":\n      return \":---:\"\n    case \"right\":\n      return \"---:\"\n  }\n}\n\nfunction serializeTableRow(element: TableRowElement): string {\n  assertElementType(element, \"table-row\")\n  return `|${element.children.map(serializeTableCell).join(\"|\")}|`\n}\n\nfunction serializeTableCell(element: TableCellElement): string {\n  assertElementType(element, \"table-cell\")\n  assert(\n    element.children.length === 1,\n    `Expected table-cell to have one child but is ${JSON.stringify(\n      element.children\n    )}`\n  )\n  return element.children.map(serializeTableContent).join()\n}\n\nfunction serializeTableContent(element: TableContentElement): string {\n  assertElementType(element, \"table-content\")\n  return serializeLine(element.children as Segment[])\n}\n","import { createSink } from \"~/src/sink\"\n\nimport { plugins, PluginTypes } from \"./plugins\"\n\nconst Sink = createSink<PluginTypes>(plugins)\n\nconst { withSink, SinkEditable } = Sink\nexport { SinkEditable, withSink }\n","export * from \"./create-plugin\"\nexport * from \"./create-sink\"\nexport * from \"./is-debug\"\nexport * from \"./types\"\nexport * from \"./utils\"\n","import { InputPluginSchema, TypedPluginFunction } from \"../types\"\nimport { BasePlugin } from \"../types/plugin/plugin\"\n\n/**\n * The `createPlugin` method here takes a function and returns the same\n * function.\n *\n * From a JavaScript point of view, it does nothing itself return itself.\n *\n * From a typing point of view, it takes these two arguments...\n *\n * - The CustomTypes used by the plugin as a Generic\n * - A function that when executed with an `Editor` object, returns a\n *   PluginObject as a function argument\n *\n * ...and ensure that the function argument adheres to the limits of the\n * Generic Argument.\n *\n * For example, if the CustomTypes defines an `Element`, then the function\n * argument will have its element related methods constrained to the Element\n * given in CustomTypes.\n *\n * The benefit of this is that it helps the Plugin only see what is relevant\n * to this plugin. In fact, it insists on it. This will prevent accidental\n * dependency on another plugin.\n *\n * You can add dependencies between plugins, but when we do that, it insists\n * on having that done explicitly.\n */\nexport const createPlugin = <T extends InputPluginSchema>(\n  fn: TypedPluginFunction<T>\n) => {\n  return { fn } as BasePlugin\n}\n","import { SinkEditable } from \"../editable\"\nimport { createWithSink } from \"../editor\"\nimport { BasePlugin, ExtractedPluginSchema } from \"../types\"\n\n/**\n * A sink is just a function\n */\nexport const createSink = <T extends ExtractedPluginSchema>(\n  pluginFunctions: BasePlugin[]\n) => {\n  const fns = pluginFunctions.map((plugin) => plugin.fn)\n  const withSink = createWithSink<T>(fns)\n\n  const returnValue = { withSink, SinkEditable }\n  return returnValue\n}\n","import { useEffect, useMemo } from \"react\"\nimport { Editor } from \"slate\"\nimport { useSlateStatic } from \"slate-react\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { SinkEditor } from \"../types\"\nimport { createDecorate } from \"./create-decorate\"\nimport { createEditable } from \"./create-editable\"\nimport {\n  createOnDrop,\n  createOnKeyDown,\n  createOnKeyUp,\n  createOnPaste,\n} from \"./create-handler\"\nimport { createRenderElement } from \"./create-render-element\"\nimport { createRenderLeaf } from \"./create-render-leaf\"\nimport { createRenderPlaceholder } from \"./create-render-placeholder\"\nexport { SinkReset } from \"./styles\"\n\n/**\n * In Editable, we use the Slate context to grab the right things from\n * the editor.\n */\nexport function SinkEditable(originalProps: EditableProps): JSX.Element {\n  const editor = useSlateStatic() as unknown as Editor & SinkEditor\n\n  /**\n   * We ask Slate to normalize the editor once at the very start.\n   *\n   * This is helpful for plugins that need to store some useful state in the\n   * document and to add or fix certain parts of the document. Not all of\n   * these values are stored in the saved documents.\n   *\n   * Some examples:\n   *\n   * - inserting collapsible paragraphs between void components. These should\n   *   not be saved.\n   *\n   * - Add column and row indexes to help with rendering which should not\n   *   be saved.\n   *\n   * Ideally, we wouldn't have to do any of this but pragmatically, it is\n   * the most performant route.\n   *\n   * Once we normalize the document once, the document is kept up to date\n   * through regular normalizing steps that are more performance because\n   * they only check changed nodes.\n   */\n  useEffect(() => {\n    Editor.normalize(editor, { force: true })\n  }, [])\n\n  const { plugins } = editor.sink\n\n  const nextProps: EditableProps = useMemo(\n    () => ({\n      ...originalProps,\n      decorate: createDecorate(originalProps.decorate, plugins),\n      renderElement: createRenderElement(originalProps.renderElement, plugins),\n      renderLeaf: createRenderLeaf(originalProps.renderLeaf, plugins),\n      renderPlaceholder: createRenderPlaceholder(\n        originalProps.renderPlaceholder,\n        plugins\n      ),\n      /**\n       * NOTE: We skip `onKeyUp` as it is deprecated. If somebody needs it in new\n       * code, we can add it back in.\n       *\n       * https://developer.mozilla.org/en-US/docs/Web/API/Element/keypress_event\n       */\n      onKeyDown: createOnKeyDown(originalProps.onKeyDown, plugins),\n      onKeyUp: createOnKeyUp(originalProps.onKeyUp, plugins),\n      onPaste: createOnPaste(originalProps.onPaste, plugins),\n      onDrop: createOnDrop(originalProps.onDrop, plugins),\n    }),\n    Object.values(originalProps)\n  )\n\n  const NextEditable = useMemo(() => createEditable(plugins), [plugins])\n\n  /**\n   * NOTE:\n   *\n   * The following code is used to see if we are getting unnecessary re-renders.\n   *\n   * Comment it out when we are happy.\n   *\n   * - We SHOULD see `SinkeEditable render` whenever the markdown is updated\n   * - We SHOULD NOT see `SinkEditable mount` or unmount at each update\n   */\n  // console.log(\"SinkEditable render\")\n\n  // console.log(Object.values(nextProps))\n\n  // useEffect(() => {\n  //   console.log(\"SinkEditable mount\")\n  //   return () => {\n  //     console.log(\"SinkEditable unmount\")\n  //   }\n  // }, [NextEditable, nextProps])\n\n  return <NextEditable {...nextProps} />\n}\n","import { NodeEntry, Range } from \"slate\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\nimport { defined } from \"./utils\"\n\n/**\n * Create the substituted `decorate` method.\n *\n * With decorate, we are taking all the ranges from all the decorators and\n * combining them together, including the ranges created from the `decorate`\n * attribute on `SinkEditable`.\n */\nexport function createDecorate(\n  originalFn: EditableProps[\"decorate\"],\n  plugins: BasePluginPolicy[]\n): NonNullable<EditableProps[\"decorate\"]> {\n  const fns = plugins\n    .map((plugin) => plugin.editableProps?.decorate)\n    .filter(defined)\n  return function (entry: NodeEntry): Range[] {\n    const ranges: Range[] = []\n    for (const fn of fns) {\n      const resultRanges = fn(entry)\n      ranges.push(...resultRanges)\n    }\n    if (originalFn) ranges.push(...originalFn(entry))\n    return ranges\n  }\n}\n","export function defined<T>(value: T | undefined): value is T {\n  return !!value\n}\n","import { Editable } from \"slate-react\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\nimport { defined } from \"./utils\"\n\ntype EditableType = (editableProps: EditableProps) => JSX.Element\n\n/**\n * create a new Editable component that takes all the `renderEditable` functions\n * which are components and have them wrap around the original Editable component.\n */\nexport function createEditable(\n  plugins: BasePluginPolicy[]\n): NonNullable<EditableType> {\n  const fns = plugins.map((plugin) => plugin.renderEditable).filter(defined)\n\n  /**\n   * This creates the inner-most RenderEditable.\n   */\n  let CurrentRenderEditable = (props: EditableProps) => <Editable {...props} />\n  /**\n   * We iterate through all the `renderEditable` functions and wrap them\n   * around the next inner-most `renderEditable`.\n   */\n  for (const fn of fns) {\n    /**\n     * Assigns the CurrentRenderEditable as the previous one so that we can\n     * have it available to call in the NextRenderEditable\n     */\n    const PrevRenderEditable = CurrentRenderEditable\n\n    CurrentRenderEditable = (props: EditableProps) => {\n      /**\n       * TODO:\n       *\n       * This should probably be fixed in the actual types; however, we\n       * know at this point that `renderEditable` is defined because we\n       * filtered it in an earlier step.\n       */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fn({\n        attributes: props,\n        Editable: PrevRenderEditable,\n      })\n    }\n  }\n\n  return CurrentRenderEditable\n\n  // return function SinkEditable(props) {\n  // /**\n  //  * This creates the inner-most RenderEditable.\n  //  */\n  // let CurrentRenderEditable = (props: EditableProps) => (\n  //   <Editable {...props} />\n  // )\n  // /**\n  //  * We iterate through all the `renderEditable` functions and wrap them\n  //  * around the next inner-most `renderEditable`.\n  //  */\n  // for (const fn of fns) {\n  //   /**\n  //    * Assigns the CurrentRenderEditable as the previous one so that we can\n  //    * have it available to call in the NextRenderEditable\n  //    */\n  //   const PrevRenderEditable = CurrentRenderEditable\n  //   CurrentRenderEditable = (props: EditableProps) => {\n  //     /**\n  //      * TODO:\n  //      *\n  //      * This should probably be fixed in the actual types; however, we\n  //      * know at this point that `renderEditable` is defined because we\n  //      * filtered it in an earlier step.\n  //      */\n  //     // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  //     return fn({\n  //       attributes: props,\n  //       Editable: PrevRenderEditable,\n  //     })\n  //   }\n  // }\n  // return <CurrentRenderEditable {...props} />\n  // }\n}\n","import { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\n\n/**\n * Create the substituted event handler method.\n *\n * Generally, we are looking for the first result from any plugin or on\n * SinkEditable and return the first one that returns a value only.\n *\n * Iterate over all the plugin handlers. If one handler returns `false`\n * then we go to the next one until we get one that returns `true`. If we don't\n * fine on that returns `true`, then we go to the handler passed to the\n * `SinkEditable` component.\n */\n\n/**\n * TODO:\n *\n * It's probably not THAT important, but the holy grail as a programmer here is\n * to:\n *\n * 1. Have these functions created without the boilerplate. It really feels\n *    like it could be one function that takes `plugins` and a `key` and all\n *    the typing and stuff would work.\n *\n * 2. Build it in a way that's easy to reason about. There is probably a way\n *    to do this that works, but nobody will ever be able to work on it if there\n *    is a problem, and probably a way to do it where it's somewhat\n *    comprehensible.\n */\n\n/**\n * Here we define strictly the type for a method that creates an Event Handler\n * on Editable. We define this separately because (a) it is easier to do it and\n * give clarity to it as a separate type and (b) we want to check the actual\n * method that we created against this type as an early warning signal if we\n * did something wrong.\n *\n * A method that creates a method, that pulls from a plugin a function that is\n * similar to, but not exactly, like the function that it is going to be\n * returning, is a bit of a nightmare and this helps make sure we don't make\n * mistakes.\n *\n * In other words, don't remove this and use the automatic typing as it's a\n * good way to make sure that this method is typed correctly.\n */\ntype CreateHandler<K extends keyof EditableProps> = (\n  originalFn: EditableProps[K],\n  plugins: BasePluginPolicy[]\n) => NonNullable<EditableProps[K]>\n\n/**\n * Takes an array of Plugin objects and extracts all of the specified\n * `editableProps` handler functions from it. If it's not defined, we skip it\n * so that we end up with an Array that is populated with the functions only\n * and no `undefined` in it.\n */\nfunction extractEditableFns<\n  K extends keyof Required<BasePluginPolicy>[\"editableProps\"]\n>(\n  plugins: BasePluginPolicy[],\n  key: K\n): NonNullable<Required<BasePluginPolicy>[\"editableProps\"][K]>[] {\n  const fns: NonNullable<Required<BasePluginPolicy>[\"editableProps\"][K]>[] = []\n  for (const plugin of plugins) {\n    const maybeFn = plugin.editableProps?.[key]\n    if (maybeFn) fns.push(maybeFn)\n  }\n  return fns\n}\n\n/**\n * Takes an array of handler functions that will return a boolean which\n * indicates that an event was handled. If the function was handled, then we\n * return and stop execution immediately.\n *\n * We keep going through all the handlers until something handles it.\n *\n * If none of the plugin fns handle it, then we check to see if there was an\n * original function defined and execute that if there is.\n */\nfunction createHandlerFn<A>(\n  fns: ((arg: A) => boolean)[],\n  originalFn: ((arg: A) => void) | undefined\n) {\n  return function (event: A) {\n    for (const fn of fns) {\n      if (fn(event)) return\n    }\n    originalFn?.(event)\n  }\n}\n\n/**\n * keyDown handler\n */\nexport const createOnKeyDown: CreateHandler<\"onKeyDown\"> = (\n  originalFn,\n  plugins\n) => {\n  const fns = extractEditableFns(plugins, \"onKeyDown\")\n  return createHandlerFn(fns, originalFn)\n}\n\n/**\n * keyUp handler\n */\nexport const createOnKeyUp: CreateHandler<\"onKeyUp\"> = (\n  originalFn,\n  plugins\n) => {\n  const fns = extractEditableFns(plugins, \"onKeyUp\")\n  return createHandlerFn(fns, originalFn)\n}\n\n/**\n * onPaste handler\n */\nexport const createOnPaste: CreateHandler<\"onPaste\"> = (\n  originalFn,\n  plugins\n) => {\n  const fns = extractEditableFns(plugins, \"onPaste\")\n  return createHandlerFn(fns, originalFn)\n}\n\n/**\n * onDrop handler\n */\nexport const createOnDrop: CreateHandler<\"onDrop\"> = (originalFn, plugins) => {\n  const fns = extractEditableFns(plugins, \"onDrop\")\n  return createHandlerFn(fns, originalFn)\n}\n","import { RenderElementProps } from \"slate-react\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\nimport { defined } from \"./utils\"\n\n/**\n * Create the substituted `renderElement` method.\n *\n * Generally, we are looking for the first result from any plugin or on\n * SinkEditable and return the first one that returns a value only.\n *\n * Iterate over all the plugin `renderElement`. If they return nothing\n * then we go to the next one until we hit a result. If we don't hit a\n * result, then we go to the `renderElement` passed to the `SinkEditable`\n * component.\n */\n\nexport function createRenderElement(\n  originalFn: EditableProps[\"renderElement\"],\n  plugins: BasePluginPolicy[]\n): NonNullable<EditableProps[\"renderElement\"]> {\n  const fns = plugins\n    .map((plugin) => plugin.editableProps?.renderElement)\n    .filter(defined)\n  return function renderElement(\n    renderElementProps: RenderElementProps\n  ): JSX.Element {\n    for (const fn of fns) {\n      const result = fn(renderElementProps)\n      if (result) return result\n    }\n    if (originalFn === undefined) {\n      throw new Error(\n        `Element with type ${renderElementProps.element.type} not handled. Note that renderElement is not defined on SinkEditable so this is only the result of checking the Sink Plugins.`\n      )\n    }\n    return originalFn(renderElementProps)\n  }\n}\n","import { cloneElement } from \"react\"\nimport { RenderLeafProps } from \"slate-react\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\nimport { defined } from \"./utils\"\n\n/**\n * Create the substituted `renderLeaf` method.\n *\n * Generally, we are looking for all the results from all the plugins and\n * SinkEditable and merge the results together by nesting the responses\n * starting from the first plugin on the outside to the `renderLeaf` method\n * on `SinkEditable` on the inside.\n */\n\nexport function createRenderLeaf(\n  originalFn: EditableProps[\"renderLeaf\"],\n  plugins: BasePluginPolicy[]\n): NonNullable<EditableProps[\"renderLeaf\"]> {\n  if (originalFn === undefined) {\n    throw new Error(`renderLeaf was not defined on SinkEditable`)\n  }\n\n  /**\n   * These get handled in reverse order. We wrap the last one around the\n   * actual `Text` and the earlier ones wrap around those. This\n   * feels more natural because the first plugin handles the outermost\n   * and we work our way inward.\n   */\n  const fns = plugins\n    .map((plugin) => plugin.editableProps?.renderLeaf)\n    .filter(defined)\n    .reverse()\n\n  return function (renderLeafProps) {\n    let value = originalFn({\n      ...renderLeafProps,\n      /**\n       * We override this because `attributes` should only appear on the\n       * uppermost leaf element if there are several nested ones and it's\n       * possible that this won't be the uppermost leaf.\n       *\n       * We add attributes back on at the very end so no need to worry if\n       * we omit it here.\n       */\n      attributes: {} as RenderLeafProps[\"attributes\"],\n    })\n    for (const fn of fns) {\n      const possibleValue = fn({\n        ...renderLeafProps,\n        children: value,\n      })\n      if (possibleValue) {\n        value = possibleValue\n      }\n    }\n    value = cloneElement(value, renderLeafProps.attributes) //{ key: 'your-unique-key-here' })\n    return value\n  }\n}\n","import { RenderPlaceholderProps } from \"slate-react\"\nimport { EditableProps } from \"slate-react/dist/components/editable\"\n\nimport { BasePluginPolicy } from \"../types\"\nimport { defined } from \"./utils\"\n\n/**\n * Create the substituted `renderElement` method.\n *\n * Generally, we are looking for the first result from any plugin or on\n * SinkEditable and return the first one that returns a value only.\n *\n * Iterate over all the plugin `renderElement`. If they return nothing\n * then we go to the next one until we hit a result. If we don't hit a\n * result, then we go to the `renderElement` passed to the `SinkEditable`\n * component.\n */\n\nexport function createRenderPlaceholder(\n  originalFn: EditableProps[\"renderPlaceholder\"],\n  plugins: BasePluginPolicy[]\n): NonNullable<EditableProps[\"renderPlaceholder\"]> | undefined {\n  if (originalFn) return originalFn\n  const fns = plugins\n    .map((plugin) => plugin.editableProps?.renderPlaceholder)\n    .filter(defined)\n  if (fns.length === 0) return undefined\n  return function (\n    renderPlaceholderProps: RenderPlaceholderProps\n  ): JSX.Element {\n    if (fns.length > 1) {\n      throw new Error(\n        `Only one plugin can define renderPlaceholder but there are ${fns.length}`\n      )\n    }\n    const fn = fns[0]\n    if (fn == null) throw new Error(`Expected fn to be defined`)\n    return fn(renderPlaceholderProps)\n  }\n}\n","import styled from \"@emotion/styled\"\n\nexport const SinkReset = styled(\"div\")`\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-size: 16px;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n    Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n  box-sizing: border-box;\n`\n","import { BaseEditor } from \"slate\"\n\nimport { BasePluginFn, ExtractedPluginSchema, FullSinkEditor } from \"../types\"\nimport { createBooleanAction } from \"./create-boolean-action\"\nimport { createVoidAction } from \"./create-void-action\"\n\nexport function createWithSink<T extends ExtractedPluginSchema>(\n  pluginFns: BasePluginFn[]\n) {\n  /**\n   * The `editor` in the props can be a `BaseEditor` but we transform it\n   * into a `SinkEditor` before returning it.\n   */\n  return <E extends BaseEditor>(\n    originalEditor: E,\n    options: T[\"Options\"]\n  ): E & FullSinkEditor => {\n    const editor = originalEditor as E & FullSinkEditor\n\n    /**\n     * Executes the plugin on the `editor` with every one of the\n     * `pluginFunctions` to get the `pluginObject`\n     */\n    const plugins = pluginFns.map((plugin) =>\n      plugin(editor, options, { createPolicy: (x) => x })\n    )\n    editor.sink = { plugins }\n\n    /**\n     * Create the default for SinkEditor methods if they don't already exist.\n     */\n    editor.isMaster = \"isMaster\" in editor ? editor.isMaster : () => false\n    editor.isSlave = \"isSlave\" in editor ? editor.isSlave : () => false\n    editor.isStandalone =\n      \"isStandalone\" in editor ? editor.isStandalone : () => false\n\n    Object.assign(editor, {\n      /**\n       * void\n       */\n      normalizeNode: createVoidAction(editor, \"normalizeNode\", plugins),\n      deleteBackward: createVoidAction(editor, \"deleteBackward\", plugins),\n      deleteForward: createVoidAction(editor, \"deleteForward\", plugins),\n      deleteFragment: createVoidAction(editor, \"deleteFragment\", plugins),\n      insertBreak: createVoidAction(editor, \"insertBreak\", plugins),\n      insertFragment: createVoidAction(editor, \"insertFragment\", plugins),\n      insertNode: createVoidAction(editor, \"insertNode\", plugins),\n      insertText: createVoidAction(editor, \"insertText\", plugins),\n      /**\n       * boolean\n       */\n      isInline: createBooleanAction(editor, \"isInline\", plugins),\n      isVoid: createBooleanAction(editor, \"isVoid\", plugins),\n      isMaster: createBooleanAction(editor, \"isMaster\", plugins),\n      isSlave: createBooleanAction(editor, \"isSlave\", plugins),\n      isStandalone: createBooleanAction(editor, \"isStandalone\", plugins),\n    })\n\n    return editor\n  }\n}\n","import { Element, Node } from \"slate\"\n\nimport { BasePluginPolicy, FullSinkEditor } from \"../types\"\n\n/**\n * Creates an overrideable editor action that takes a `Node` and returns a\n * `boolean` and creates a new version of the action that incorporates the\n * plugins.\n *\n * If the plugin returns a boolean, it takes the result and returns it.\n *\n * If the plugin returns undefined, it tries the next one.\n *\n * If no plugin handles the result, it returns the result of the original action.\n */\nexport function createBooleanAction<\n  K extends \"isVoid\" | \"isInline\" | \"isMaster\" | \"isSlave\" | \"isStandalone\"\n>(\n  editor: FullSinkEditor,\n  actionKey: K,\n  plugins: BasePluginPolicy[]\n): (node: Element) => boolean {\n  const originalAction = editor[actionKey]\n  const actionPlugins = plugins.filter((plugin) => plugin.editor?.[actionKey])\n  return function nextBooleanAction(node: Node): boolean {\n    for (const plugin of actionPlugins) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const result = plugin.editor?.[actionKey]?.(node)\n      if (typeof result === \"boolean\") return result\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return originalAction(node)\n  }\n}\n","import { BaseEditor } from \"slate\"\n\nimport { BasePluginPolicy } from \"../types\"\n\n/**\n * Creates an overrideable editor action like `insertBreak` or `deleteBackward`\n * that usually returns `void` and creates a new version of the action that\n * adds the action from the plugin.\n *\n * If the plugin returns `true` it takes the result and returns it.\n *\n * If the plugin returns `false`, it tries the next one.\n *\n * If no plugin handles the result, it executed the original action.\n */\nexport function createVoidAction<\n  K extends\n    | \"normalizeNode\"\n    | \"deleteBackward\"\n    | \"deleteForward\"\n    | \"deleteFragment\"\n    | \"insertBreak\"\n    | \"insertFragment\"\n    | \"insertNode\"\n    | \"insertText\"\n>(editor: BaseEditor, actionKey: K, plugins: BasePluginPolicy[]) {\n  const originalAction = editor[actionKey]\n  const actionPlugins = plugins.filter((plugin) => plugin.editor?.[actionKey])\n  return function nextVoidAction(...args: Parameters<BaseEditor[K]>[]): void {\n    let isHandled = false\n    const afterHandledCallbacks: (() => void)[] = []\n    for (const plugin of actionPlugins) {\n      // @ts-ignore\n      const response = plugin.editor?.[actionKey]?.(...args)\n      if (typeof response === \"function\") {\n        afterHandledCallbacks.push(response)\n      } else if (response === true) {\n        isHandled = true\n        break\n      }\n    }\n    if (!isHandled) {\n      // @ts-ignore\n      originalAction(...args)\n    }\n    afterHandledCallbacks.forEach((callback) => callback())\n  }\n}\n","export const isDebug = false\n","export * from \"./constrained/constrained-render-element-props\"\nexport * from \"./constrained/constrained-render-leaf-props\"\nexport * from \"./plugin\"\nexport * from \"./sink/sink-editor\"\n","import { BaseElement } from \"slate\"\n\n/**\n * Creates the RenderElementProps where the element argument coming in is\n * constrained to a specific element. This is useful during the creation of\n * a Plugin where we want to isolate the choice of `Element` to whatever is\n * available for that specific plugin.\n */\nexport type ConstrainedRenderElementProps<Element> = Element extends BaseElement\n  ? {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      children: any\n      element: Element\n      attributes: {\n        \"data-slate-node\": \"element\"\n        \"data-slate-inline\"?: true\n        \"data-slate-void\"?: true\n        dir?: \"rtl\"\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ref: any\n      }\n    }\n  : never\n","/**\n * Creates the RenderLeafProps where the leaf/text argument coming in is\n * constrained to a specific Text type. This is useful during the creation of\n * a Plugin where we want to isolate the choice of `Text` to whatever is\n * available for that specific plugin.\n *\n * NOTE: Because of the specific use case (i.e. for a Plugin) we have removed\n * the availability in the types of the `attributes` prop. This is because\n * we do not want the user adding this prop themselves. In plugins, this is\n * added automatically. This is done because only the outermost HTML Element\n * should have the attributes on it. If the user manually adds it, then we\n * end up with the attributes doubled up.\n */\nexport type ConstrainedRenderLeafProps<Text> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  children: any\n  leaf: Text\n  text: Text\n  /**\n   * KEEP:\n   *\n   * Removed from the props given because we don't want the user to add it\n   * themselves.\n   *\n   * Do not delete it as it's useful for reference.\n   */\n  // attributes: {\n  //   \"data-slate-leaf\": true\n  // }\n}\n","export * from \"./ExtractCustomTypes\"\nexport * from \"./merge-plugin-custom-types\"\nexport * from \"./plugin\"\nexport * from \"./plugin-custom-types\"\nexport * from \"./plugin-custom-types-for-create\"\nexport * from \"./plugin-function\"\nexport * from \"./plugin-policy\"\nexport * from \"./schema-types\"\nexport * from \"./VoidActionReturn\"\n","import { BaseEditor } from \"slate\"\nimport { HistoryEditor } from \"slate-history\"\nimport { ReactEditor } from \"slate-react\"\nimport { Simplify, UnionToIntersection } from \"type-fest\"\n\nimport { SinkEditor } from \"../sink/sink-editor\"\nimport { BasePlugin } from \"./plugin\"\n\nexport type ExtractCustomTypes<TA extends Array<BasePlugin>> =\n  /**\n   * This code takes an array of types and merges them together into a union.\n   */\n  TA extends Array<{\n    __types__: infer U\n  }>\n    ? {\n        // Name: U extends { Name: infer N } ? N : never\n        // Options: Simplify<\n        //   UnionToIntersection<U extends { Options: infer O } ? O : never>\n        // >\n        Editor: SinkEditor &\n          BaseEditor &\n          ReactEditor &\n          HistoryEditor &\n          UnionToIntersection<U extends { Editor: infer E } ? E : never>\n        Element: U extends { Element: infer E } ? E : never\n        Text: Simplify<\n          UnionToIntersection<U extends { Text: infer T } ? T : never>\n        >\n        Options: Simplify<\n          UnionToIntersection<U extends { Options: infer T } ? T : never>\n        >\n      }\n    : never\n","import { BaseElement, BaseText } from \"slate\"\nimport { UnionToIntersection } from \"type-fest\"\n\nimport { SinkEditor } from \"../sink/sink-editor\"\n\n/**\n * This Generic takes a tuple containing all of the PluginCustomTypes for\n * ths Sink and returns an object that contains the definitions for\n * `CustomTypes` for the `Editor`, `Element` and `Text`. These should be\n * combined with any existing `CustomTypes` on the Editor.\n *\n * NOTE:\n * The `Element` type returned cannot be plugged directly into the CustomTypes\n * due to a limitation on TypeScript. It complains this is recursive although\n * it seems to work fine by cutting and pasting the Element value using\n * TypeScript introspection.\n */\nexport type MergePluginCustomTypes<\n  T extends Array<{\n    Name: string\n    Editor?: Record<string, unknown>\n    Element?: BaseElement\n    Text?: BaseText\n  }>\n> = {\n  Name: T[number][\"Name\"]\n  Editor: SinkEditor & UnionToIntersection<T[number][\"Editor\"]>\n  /**\n   * The first part with the `infer` is so that we can extract\n   * `PluginCustomType` cleanly. If we don't extract `Element` first and we try\n   * and operate on the object, can't seem to get the typing to work. Note that\n   * the conditional is only there so that we can `infer` the\n   * `PluginCustomType`.\n   *\n   * The second part checks to see if there is an `Element` property and if\n   * there is, we extract that. TypeScript will turn all of these extracted\n   * `Element` types into a union (i.e. they will be \"|\" together).\n   *\n   * If the property doesn't exist, it will be treated as `never`. In TypeScript\n   * when we `|` a type with a `never` type, the `never` just gets ignored.\n   */\n  Element: T extends Array<infer PluginCustomType>\n    ? PluginCustomType extends { Element: unknown }\n      ? PluginCustomType[\"Element\"]\n      : never\n    : /**\n       * This actually should never happen because the incoming T is already\n       * typed to extend Array.\n       */\n      never\n\n  /**\n   * Same as above to create the `Union` but then at the very end we turn it\n   * into an intersection using the `type-fest` generic `UnionToIntersection`\n   */\n  Text: UnionToIntersection<\n    T extends Array<infer PluginCustomType>\n      ? PluginCustomType extends { Text: unknown }\n        ? PluginCustomType[\"Text\"]\n        : never\n      : /**\n         * This actually should never happen because the incoming T is already\n         * typed to extend Array.\n         */\n        never\n  >\n}\n","/**\n * IMPORTANT!\n *\n * NEVER!\n *\n * refer to a type that is defined in the `slate` package. This is because\n * any reference to a Slate type will cause a circular reference type error that\n * is very hard to track down.\n *\n * NOTE: This kind of happens in that `Element` will often have a reference to\n * `Descendant` but it looks like this is okay; however, let's not tempt fate\n * by only using it where the definition is absolutely necessary.\n *\n * ALWAYS!\n *\n * Be explicity about return types. If they are inferred through the return\n * type, because we need to provide `Editor` as an argument in certain cases,\n * we don't want to accidentally have `Editor` be provided as a return type\n * or this will create the circular reference.\n */\n// export type BasePluginTypes = {\n//   Name: string\n//   Options: Record<string, unknown>\n//   Editor: Record<string, unknown>\n//   Element: { type: string }\n//   Text: Record<string, unknown>\n// }\n\nimport { BasePluginFn } from \"./plugin-function\"\nimport {\n  BasePluginSchema,\n  InputPluginSchema,\n  NormalizeInputPluginSchema,\n} from \"./schema-types\"\n\n/**\n * When a Plugin is created using the `createPlugin` method, it returns a\n * Plugin.\n */\nexport type BasePlugin = { fn: BasePluginFn; __types__: BasePluginSchema }\n\n/**\n * When a Plugin is created using `createPlugin` we must\n */\nexport type TypedPlugin<T extends InputPluginSchema> = {\n  fn: BasePluginFn\n  __types__: NormalizeInputPluginSchema<T>\n}\n\n// /**\n//  * When a Plugin is created using the `createPlugin` method, it returns a\n//  * Plugin.\n//  */\n\n// export type BasePlugin = { fn: BasePluginFunction; __types__: BasePluginTypes }\n// /**\n//  * When a Plugin is created using `createPlugin` we must\n//  */\n\n// export type TypedPlugin<T extends InputPluginTypes> = {\n//   fn: BasePluginFunction\n//   __types__: NormalizeInputPluginTypes<T>\n// }\n\n// /**\n//  * These are the PluginTypes that are accepted as inputs into `createPlugin`\n//  * which has the same basic signature as `BasePluginTypes` but some of the\n//  * types are optional.\n//  *\n//  * These `InputPluginTypes` need to have their optional types filled in with\n//  * defaults before they can be used.\n//  *\n//  * See `NormalizeInputPluginTypes`\n//  */\n\n// export type InputPluginTypes = SetOptional<\n//   BasePluginTypes,\n//   \"Options\" | \"Editor\" | \"Element\" | \"Text\"\n// >\n// /**\n//  * Takes an `InputPluginTypes` (that has some optional types) and turns them\n//  * into a regular PluginTypes with any missing types filled in with defaults.\n//  */\n\n// export type NormalizeInputPluginTypes<T extends InputPluginTypes> = {\n//   Name: T[\"Name\"]\n//   Options: T[\"Options\"] extends object ? T[\"Options\"] : {}\n//   Editor: T[\"Editor\"] extends object ? T[\"Editor\"] : {}\n//   Element: T[\"Element\"] extends object ? T[\"Element\"] : never\n//   Text: T[\"Text\"] extends object ? T[\"Text\"] : {}\n// }\n","/**\n * When creating a single PluginCustomType, we want to constrain it as much as\n * possible. These are the constraints.\n */\nexport type BasePluginCustomTypes = {\n  /**\n   * Define a unique name for this plugin. This value must be manually set\n   * during the plugin definition so that it is part of the `PluginObject`.\n   *\n   * This is important because we want to be able to identify each plugin\n   * uniquely for debugging purposes.\n   */\n  Name: string\n  /**\n   * This is the **extension** to the Editor and not the combined editor.\n   * In other words, the properties here will not be part of `BaseEditor`.\n   */\n  Editor: Record<string, unknown>\n  /**\n   * Element should extend the BaseElement\n   */\n  Element: Record<string, unknown>\n  /**\n   * Text should extend the BaseText\n   */\n  Text: Record<string, unknown>\n}\n\n/**\n * When we are accepting an array of plugins, unfortunately we can't be as\n * restrictive as TypeScript throws an error saying that the second plugin is\n * incompatible with the first. So we have a less type safe version with any\n * for that use case.\n *\n * WEIRD:\n *\n * If I make any of these property keys optional, for example to suggest that\n * you don't need to provide a property for every entry in the array, this\n * shows a type mismatch when used in an array. It shows a type mismatch even\n * if the items in the array are all provided or if the array has only one\n * item that matches.\n */\nexport type ArraySafePluginCustomTypes = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Name: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Editor: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Element: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Text: any\n}\n\n/**\n * When we define a new Plugin's Custom Types, we want it to extend the\n * BasePluginCustomTypes to get some level of type safety.\n */\nexport type PluginCustomTypes<T extends BasePluginCustomTypes> = T\n","import { SetOptional } from \"type-fest\"\n\nimport { BasePluginCustomTypes } from \"..\"\n\n/**\n * TODO:\n *\n * These should be merged with the `plugin-custom-types` in the same directory.\n *\n * At some point, there was some fancy typing efforts in order to get the\n * CustomTypes automatically extracted from the plugins; however, it turns out\n * that due to limitations in TypeScript, at least as hard as we've tried,\n * this is impossible.\n *\n * Because of this, we should probably make efforts to simplify the Custom\n * Types as much as possible.\n */\n\n/**\n * These are the Input Custom Types for the Plugin which differ from the actual\n * Custom Types for the plugin because, apart from `Name`, most of the\n * keys except for `Name` are optional.\n */\n\n// export type InputPluginCustomTypes = {\n//   Name: string\n//   /**\n//    * This describes the additional properties on the Editor, not the full\n//    * Editor. This is why it does not extend BaseEditor.\n//    */\n//   Editor?: Record<string, unknown>\n//   /**\n//    * This describes an Element type to be used with this plugin. Note that it\n//    * can actually be multiple Element types combined with `|`\n//    */\n//   Element?: BaseElement\n//   /**\n//    * This describes a Text type to be used with this plugin.\n//    */\n//   Text?: BaseText\n// }\n\nexport type InputPluginCustomTypes = SetOptional<\n  BasePluginCustomTypes,\n  \"Editor\" | \"Element\" | \"Text\"\n>\n\nexport type NormalizeInputPluginCustomTypes<T extends InputPluginCustomTypes> =\n  {\n    Name: T[\"Name\"]\n    Editor: T[\"Editor\"] extends object ? T[\"Editor\"] : {}\n    Element: T[\"Element\"] extends object ? T[\"Element\"] : never\n    Text: T[\"Text\"] extends object ? T[\"Text\"] : {}\n  }\n","import { Editor } from \"slate\"\nimport { Simplify } from \"type-fest\"\n\nimport { FullSinkEditor } from \"../sink/sink-editor\"\nimport { BasePluginPolicy, PluginPolicy } from \"./plugin-policy\"\nimport { InputPluginSchema, NormalizeInputPluginSchema } from \"./schema-types\"\n\n/**\n * Shape of a PluginFn (Plugin Function).\n */\n\nexport type BasePluginFn = (\n  editor: FullSinkEditor,\n  options: {},\n  helpers: { createPolicy: (value: unknown) => unknown }\n) => BasePluginPolicy\n\nexport type TypedPluginFunction<T extends InputPluginSchema> = (\n  /**\n   * We make this T[\"Editor\"] to make sure we get all off the properties\n   * for the plugin but also add `Editor` so that Editor will pass the typing\n   * for Transform methods and such that take an `Editor` object.\n   */\n  editor: T[\"Editor\"] & Editor,\n  options: Simplify<NormalizeInputPluginSchema<T>[\"Options\"]>, // TODO: temporarily it's always empty\n  helpers: {\n    createPolicy: (\n      policy: PluginPolicy<NormalizeInputPluginSchema<T>>\n    ) => BasePluginPolicy\n  }\n) => BasePluginPolicy\n","import React from \"react\"\nimport { BaseRange, NodeEntry, Path } from \"slate\"\nimport { Editable } from \"slate-react\"\nimport {\n  EditableProps,\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from \"slate-react/dist/components/editable\"\nimport { SetReturnType } from \"type-fest\"\n\nimport {\n  BasePluginSchema,\n  ConstrainedRenderElementProps,\n  ConstrainedRenderLeafProps,\n} from \"..\"\nimport { VoidActionReturn } from \"./VoidActionReturn\"\n\nexport type RenderEditableProps = {\n  attributes: EditableProps\n  Editable: typeof Editable\n}\n\nexport type RenderEditable = (props: RenderEditableProps) => React.ReactElement\n\n/**\n * The return type of the BasePluginFn which specifies how the Plugin is\n * supposed to behave.\n */\n\nexport type BasePluginPolicy = {\n  name: string\n  editor?: {\n    isInline?: (element: Element) => boolean | void\n    isVoid?: (element: Element) => boolean | void\n    isMaster?: (element: Element) => boolean | void\n    isSlave?: (element: Element) => boolean | void\n    isStandalone?: (element: Element) => boolean | void\n    deleteBackward?: (\n      unit: \"character\" | \"word\" | \"line\" | \"block\"\n    ) => VoidActionReturn\n    deleteForward?: (\n      unit: \"character\" | \"word\" | \"line\" | \"block\"\n    ) => VoidActionReturn\n    deleteFragment?: () => VoidActionReturn\n    insertBreak?: () => VoidActionReturn\n    insertFragment?: (fragment: Node[]) => VoidActionReturn\n    insertNode?: (node: Node) => VoidActionReturn\n    insertText?: (text: string) => VoidActionReturn\n    normalizeNode?: (entry: NodeEntry) => VoidActionReturn\n  }\n  renderEditable?: RenderEditable\n  editableProps?: {\n    decorate?: ((entry: NodeEntry) => BaseRange[]) | undefined\n    renderElement?: (\n      props: RenderElementProps\n    ) => React.ReactElement | undefined\n    renderLeaf?: (props: RenderLeafProps) => React.ReactElement | undefined\n    renderPlaceholder?: (props: RenderPlaceholderProps) => JSX.Element\n    onKeyDown?: EditableVoidToBooleanHandlerType<\"onKeyDown\">\n    onKeyUp?: EditableVoidToBooleanHandlerType<\"onKeyDown\">\n    onPaste?: EditableVoidToBooleanHandlerType<\"onPaste\">\n    onDrop?: EditableVoidToBooleanHandlerType<\"onDrop\">\n  }\n}\n\n/**\n * Once a Plugin is executed, it returns this Object that defines how the\n * plugin should behave.\n */\nexport type PluginPolicy<T extends BasePluginSchema> = {\n  /**\n   * A string literal that uniquely identifies this plugin\n   */\n  name: T[\"Name\"]\n  // editor: PluginEditor\n  // withEditor?: (editor: PluginEditor) => PluginEditor\n  editor?: {\n    /**\n     * TODO:\n     *\n     * Option 1:\n     *\n     * Consider forcing these methods to return either `true` or `void` and\n     * not have an ability to specify `false` directly. This would potentially\n     * be better to reduce the number of non-necessary steps since at the end\n     * these methods return `false` anyways.\n     *\n     * Option 2:\n     *\n     * This may be better. Method should return either `true` or `false`.\n     * If it returns true, then the value is actually `true`. If it returns\n     * `false`, the the value is `false` unless some other plugin says it's\n     * true.\n     *\n     * This is a little harder to reason about, but it is more intuitive to\n     * say `false` than `undefined`.\n     */\n    /**\n     * If the element is considered handled, we return a boolean value.\n     * If it isn't handled yet, we don't return any value (e.g. `undefined`)\n     */\n    isInline?: (element: T[\"Element\"]) => boolean | void\n    isVoid?: (element: T[\"Element\"]) => boolean | void\n    /**\n     * Custom `SinkEditor` extensions to identify master and slave elements.\n     *\n     * Master and slave is out of style but the challenge was finding a name\n     * that better described the relationship. When one is found, change these\n     * names.\n     */\n    isMaster?: (element: T[\"Element\"]) => boolean | void\n    isSlave?: (element: T[\"Element\"]) => boolean | void\n    isStandalone?: (element: T[\"Element\"]) => boolean | void\n\n    /**\n     * - If the action insert considered handled, we return `true`.\n     * - If it isn't handled yet, return `false`.\n     * - If it isn't handled but we want a function to be called after it is\n     *   handled (e.g. to execute a normalizer) then return a void function\n     *   `() => void`\n     *\n     * For type safety, you can't return `undefined`.\n     *\n     * For a detailed description of this approach, see `./void-action.ts`\n     */\n    deleteBackward?: (\n      unit: \"character\" | \"word\" | \"line\" | \"block\"\n    ) => VoidActionReturn\n    deleteForward?: (\n      unit: \"character\" | \"word\" | \"line\" | \"block\"\n    ) => VoidActionReturn\n    deleteFragment?: () => VoidActionReturn\n    insertBreak?: () => VoidActionReturn\n    insertFragment?: (fragment: Node[]) => VoidActionReturn\n    insertNode?: (node: Node) => VoidActionReturn\n    insertText?: (text: string) => VoidActionReturn\n    normalizeNode?: (entry: NodeEntry) => VoidActionReturn\n  }\n  /**\n   * Let's a plugin modify the way the `Editable` is rendered.\n   *\n   * It's defined similar to `renderElement` but instead of adding `attributes`\n   * to your own React components, you can modify the `attributes` and add\n   * them to `Editable`.\n   *\n   * <Editable {...attributes} />\n   *\n   * Some things you can do with this are you can add an outer container and\n   * a toolbar before the `Editable` to add a toolbar. Another way this could\n   * be implemented would be to strip the `styles` and `className` from\n   * attributes and add it to your own container, and pass the rest of the\n   * non-styling attributes to `Editable`.\n   */\n  renderEditable?: RenderEditable\n  editableProps?: {\n    /**\n     * Same as the original Decorate but constrained to the supplied element\n     */\n    decorate?: ((entry: [T[\"Element\"], Path]) => BaseRange[]) | undefined\n    /**\n     * `renderElement` behaves similar to the `renderElement` prop on `Editable`\n     * but if `renderElement` returns undefined, we move on to the next\n     * next plugin's `renderElement`.\n     *\n     * `renderElement` is also typed to the `PluginElement`\n     */\n    renderElement?: (\n      props: ConstrainedRenderElementProps<T[\"Element\"]>\n    ) => React.ReactElement | undefined\n    /**\n     * `renderLeaf` behaves similar to the `renderLeaf` prop on `Editable`\n     * but if `renderLeaf` returns undefined, we move on to the next\n     * next plugin's `renderLeaf`.\n     *\n     * `renderLeaf` is also typed to the `PluginText`\n     *\n     * The `props.children` of `renderLeaf` may be the result of an earlier\n     * `renderLeaf` call. In order to make this work, the `attributes`\n     * are automatically added to the top-most element so you should not\n     * add it yourself. In fact, we remove `attributes` to prevent you from\n     * trying to do it yourself!\n     */\n    renderLeaf?: (\n      props: ConstrainedRenderLeafProps<T[\"Text\"]>\n    ) => React.ReactElement | undefined\n    renderPlaceholder?: (props: RenderPlaceholderProps) => JSX.Element\n    /**\n     * All of these plugin event handlers work like the standard event handler\n     * except they should return a `boolean` instead of `void`.\n     *\n     * the handler returns true, it signals that the plugin handled the event\n     * handler. If the handler return false, it signals that it hasn't handled\n     * it and will then try running the next one.\n     *\n     * The plugin must handle calling e.preventDefault and e.stopPropagation\n     * if it wishes to.\n     */\n    /**\n     * NOTE: We skip `onKeyUp` as it is now considered deprecated. If somebody\n     * needs it in new code, we can add it back in.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/keypress_event\n     */\n    onKeyDown?: EditableVoidToBooleanHandlerType<\"onKeyDown\">\n    onKeyUp?: EditableVoidToBooleanHandlerType<\"onKeyDown\">\n    onPaste?: EditableVoidToBooleanHandlerType<\"onPaste\">\n    onDrop?: EditableVoidToBooleanHandlerType<\"onDrop\">\n  }\n}\n\ntype EditableVoidToBooleanHandlerType<K extends keyof EditableProps> =\n  SetReturnType<NonNullable<EditableProps[K]>, boolean>\n\n// type EditableVoidToBooleanHandlersType<K extends keyof EditableProps> = {\n//   [key in K]: EditableVoidToBooleanHandlerType<K>\n// }\n\n// type EditableVoidToBooleanHandlers = EditableVoidToBooleanHandlersType<\n//   \"onKeyDown\" | \"onKeyUp\" | \"onKeyPress\" | \"onPaste\" | \"onDrop\"\n// >\n","import { SetOptional } from \"type-fest\"\n\n/**\n * IMPORTANT!\n *\n * NEVER!\n *\n * refer to a type that is defined in the `slate` package. This is because\n * any reference to a Slate type will cause a circular reference type error that\n * is very hard to track down.\n *\n * NOTE: This kind of happens in that `Element` will often have a reference to\n * `Descendant` but it looks like this is okay; however, let's not tempt fate\n * by only using it where the definition is absolutely necessary.\n *\n * ALWAYS!\n *\n * Be explicity about return types. If they are inferred through the return\n * type, because we need to provide `Editor` as an argument in certain cases,\n * we don't want to accidentally have `Editor` be provided as a return type\n * or this will create the circular reference.\n */\n\nexport type BasePluginSchema = {\n  Name: string\n  Options: Record<string, unknown>\n  Editor: Record<string, unknown>\n  Element: { type: string }\n  Text: Record<string, unknown>\n}\n/**\n * These are the PluginTypes that are accepted as inputs into `createPlugin`\n * which has the same basic signature as `BasePluginTypes` but some of the\n * types are optional.\n *\n * These `InputPluginTypes` need to have their optional types filled in with\n * defaults before they can be used.\n *\n * See `NormalizeInputPluginTypes`\n */\n\nexport type InputPluginSchema = SetOptional<\n  BasePluginSchema,\n  \"Options\" | \"Editor\" | \"Element\" | \"Text\"\n>\n/**\n * Takes an `InputPluginSchema` (that has some optional types) and turns them\n * into a regular PluginTypes with any missing types filled in with defaults.\n */\nexport type NormalizeInputPluginSchema<T extends InputPluginSchema> = {\n  Name: T[\"Name\"]\n  Options: T[\"Options\"] extends object ? T[\"Options\"] : {}\n  Editor: T[\"Editor\"] extends object ? T[\"Editor\"] : {}\n  Element: T[\"Element\"] extends object ? T[\"Element\"] : never\n  Text: T[\"Text\"] extends object ? T[\"Text\"] : {}\n}\n\n/**\n * The result of calling ExtractCustomTypes (may be renamed to\n * ExtractPluginSchema or something else in the future) on an array of\n * `PluginSchema` types.\n *\n * This value is used as an input to `createSink` so that we have access to the\n * `Options` type since the second argument to `createSink` is `options:\n * Options`\n */\nexport type ExtractedPluginSchema = {\n  Options: Record<string, unknown>\n  // Editor: Record<string, unknown>\n  Element: { type: string }\n  Text: Record<string, unknown>\n}\n","/**\n * On the editor, there are several methods that return void that are used to\n * override default editor behaviors.\n *\n * These are referred to as Overrideable core actions in the docs.\n *\n * - deleteBackward\n * - deleteForward\n * - deleteFragment\n * - insertBreak\n * - insertFragment\n * - insertNode\n * - insertText\n * - normalizeNode\n *\n * When there are plugins, Sink tries to find a plugin to handle the event and\n * if it cannot, uses the previously defined handler. For example, the user may\n * have specified `editor.insertBreak` on the `editor` earlier and that will\n * be called after all the plugins have been searched.\n *\n * We search through the plugins from the first to the last plugin.\n *\n * In a plugin, we specify the functions like we don on the editor but the\n * return value informs us how the plugin should proceed after. The return\n * value generally indicates whether the plugin has handled the event with one\n * special case:\n *\n * - `true`: If the return type is `true` then the plugin has indicated it has\n *   handled the event and no further processing is required. The handlers in\n *   all remaining plugins are skipped.\n *\n * - `false`: If the return type is `false` then the plugin has indicated it has\n *   not handled the event and will continue through the rest of the plugins\n *   looking for a plugin to handle the event.\n *\n * - `() => void`: If the return tyep is a function, the plugin has indicated\n *   it has not handled the event, but that it would like to register another\n *   function that should execute after the actual event handler has been\n *   executed. In particular, this is used when in certain situations we may\n *   want a normalizer to execute after the event handler has triggered. This\n *   is used in the `normalize-after-delete-plugin` for example.\n *\n * NOTE:\n *\n * This seems like an unusual specification at first glance and a purist might\n * argue, this could be handled more succinctly with a `next` function passed\n * in as the final argument.\n *\n * Here's why I elected to go this route but it boils down to the fact that\n * `next` functions make the function difficult to reason about.\n *\n * - 99% of the true, we want to indicate whether we handled the function or\n *   not and for that use case, true/false is simple to understand and natural.\n *   In the case where we need something to happen after, returning a function\n *   is unusual, but still easy to reason about. Also, the exclusivity of\n *   the function return is nice in that it assumes that the event wasn't\n *   handled, and of course, the function return would only ever be used if the\n *   function indeed wasn't handled. For if it was handled, there would be no\n *   need to have the after function because that could just be in the original\n *   function handler.\n *\n * - To use this, you have to build nested contexts that are always hard to\n *   reason about because you are passing a set of contexts from inner child\n *   to outer parent. This created difficult to comprehend complexity in the\n *   old Slate plugins architecture and is probably why it was abandoned.\n *\n * - It's also harder to type properly and to reason about it. The argument\n *   list changes in length depending on the function; furthermore, in some\n *   cases it is natural to ignore the arguments but we'd have to accept blank\n *   arguments that are unused to access the `next` function.\n *\n * - It's hard to debug. The plugin system as it currently is designed to\n *   execute linearly, instead of in a nested fashion. This makes it easy to\n *   add debug code, and know what happens before and after each step.\n */\n\nexport type VoidActionReturn = boolean | (() => void)\n\n/**\n * This is a more efficient way of typing a VoidAction from an original\n * action but, at the moment, we aren't doing this because it improves\n * readability on the PluginObject to just respecify the types. We don't have\n * to do any hide-and-seek to get the correct type.\n */\n// export type VoidActionType<T extends (...args: any[]) => void> = T extends (\n//   ...args: infer Args\n// ) => void\n//   ? (...args: Args) => boolean | (() => void)\n//   : never\n","import { BaseEditor, Element } from \"slate\"\nimport { HistoryEditor } from \"slate-history\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { BasePluginPolicy } from \"..\"\n\n/**\n * SinkEditor just adds a `sink` object where we drop all of our sink\n * related data on.\n */\nexport type SinkEditor = {\n  /**\n   * a master Element is one that has one or more elements that are depedant\n   * on it. For example, a `table` Element. For clarity, a `table-row` Element\n   * is not considered a master Element. Only the top-most element is.\n   *\n   * One use for identify a master is for adding a block quote. We want the\n   * block quote to always surround the master Element. A block-quote that\n   * surrounded a table-row, for example, would not make sense.\n   */\n  isMaster: (node: Element) => boolean\n  /**\n   * a slave Element is one that is dependant on another Element. For example,\n   * `table-row`, `table-cell` and `table-cotent` elements are all considered\n   * slave elements.\n   *\n   * At the time of writing, I haven't figured out a use case for a slave\n   * element actually...\n   */\n  isSlave: (node: Element) => boolean\n  isStandalone: (node: Element) => boolean\n  sink: {\n    plugins: BasePluginPolicy[]\n  }\n}\n\nexport type FullSinkEditor = SinkEditor &\n  BaseEditor &\n  ReactEditor &\n  HistoryEditor\n","export * from \"./core-utils\"\nexport * from \"./find-utils/find-element-up\"\nexport * from \"./icon-utils/tabler-icon\"\nexport * from \"./is-utils\"\nexport * from \"./key-utils\"\nexport * from \"./normalize-utils/force-normalize-path\"\nexport * from \"./normalize-utils/normalize-siblings\"\nexport * from \"./select-utils\"\nexport * from \"./standardize-utils\"\nexport * from \"./transform-utils\"\n","export * from \"./better-at\"\nexport * from \"./curry\"\nexport * from \"./is-mac\"\nexport * from \"./stop-event\"\n","import { Editor, Element, Location } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\n/**\n * Defines a value you'd find in a function's parameters as a replacement for\n * `at`. The benefit of using `BetterAt` is that it allows you to search\n * using an `Element`.\n */\nexport type BetterAt = Location | Element | null\n\n/**\n * Takes a `BetterAt` type which can include an `Element` and returns a\n * Location.\n */\nexport function betterAt(editor: Editor, at: Location | Element): Location {\n  if (!Element.isElement(at)) return at\n  return ReactEditor.findPath(editor, at)\n}\n","/**\n * Takes a function and returns a new function with the first X arguments of\n * that function pre-filled with the provided values.\n *\n * NOTE:\n *\n * This is not a full implementation of a curry but gives us what we want in a\n * lightweight manner, with low complexity and good typing. Namely, we need to\n * specify how many arguments to curry.\n *\n * This can probably be done in a way where the argument number doesn't have to\n * be specified ahead of time; however, these are the reasons I've kept it this\n * way for now.\n *\n * - It's easier to understand. We don't need to create a recursive TypeScript\n *   type.\n * - We only ever need currying a little anyways\n * - It's probably a little more performant this way\n *\n * WARNING FOR GENERICS:\n *\n * If the function you are currying has a generic, you will need to write a\n * generic manually for it then apply it manually using `as`. For example:\n *\n * const curriedToggleElements = curry(toggleElements, editor) as\n *   CurriedToggleElements\n */\n\n/**\n * Curry one argument from the left\n */\nexport function curryOne<CurriedArg, RestArgs extends unknown[], R>(\n  fn: (curriedArg: CurriedArg, ...restArgs: RestArgs) => R,\n  curriedArg: CurriedArg\n): (...args: RestArgs) => R {\n  return fn.bind(null, curriedArg)\n}\n\n/**\n * Curry two arguments from the left\n */\nexport function curryTwo<Arg1, Arg2, RestArgs extends unknown[], R>(\n  fn: (arg1: Arg1, arg2: Arg2, ...restArgs: RestArgs) => R,\n  arg1: Arg1,\n  arg2: Arg2\n): (...args: RestArgs) => R {\n  return fn.bind(null, arg1, arg2)\n}\n","const IS_MAC_REGEX = /mac os x/i\n\nlet isMacValue: boolean | undefined = undefined\n\n/**\n * `isMac` is a function and not a const because `window.navigator` only exists\n * on the browser and will throw an Error on the server.\n */\nexport function isMac() {\n  /**\n   * Memoized for performance\n   */\n  if (isMacValue !== undefined) return isMacValue\n  const { userAgent } = window.navigator\n  isMacValue = IS_MAC_REGEX.test(userAgent)\n  return isMacValue\n}\n","/**\n * Tiny helper to call `e.preventDefault()` and `e.stopPropagation()` as the\n * same time.\n */\nexport function stopEvent(e: Event | React.SyntheticEvent) {\n  e.preventDefault()\n  e.stopPropagation()\n}\n","import { Ancestor, Editor, Element, NodeEntry, Path } from \"slate\"\n\nimport { BetterAt, betterAt } from \"../core-utils/better-at\"\nimport {\n  NodeMatcher,\n  standardizeNodeMatcher,\n} from \"../standardize-utils/standardize-node-matcher\"\n\n/**\n * Checks to see if the current selection is inside of a Node that matches\n * `matchNode`.\n */\nexport function findElementUp<T extends Ancestor & Element = Element>(\n  editor: Editor,\n  matchNode: NodeMatcher,\n  { at = editor.selection }: { at?: BetterAt } = {}\n): NodeEntry<T> | undefined {\n  // if no selection, there will be no match\n  if (at === null) return\n  const nextAt = betterAt(editor, at)\n  const match = standardizeNodeMatcher(matchNode)\n  /**\n   * Normally, we are looking up from a range or a point, but if the `at`\n   * `Location` is a `Path`, then we need to check for an exact match at the\n   * `at` `Location` in addition to looking `Editor.above` the current\n   * `at` `Location`\n   */\n  if (Path.isPath(nextAt)) {\n    const nodeEntryExactlyAt = Editor.node(editor, nextAt)\n    if (nodeEntryExactlyAt && match(nodeEntryExactlyAt[0])) {\n      return nodeEntryExactlyAt as NodeEntry<T>\n    }\n  }\n  // look for a matching element\n  return Editor.above(editor, { at: nextAt, match })\n}\n\nexport function findElementUpPath(...args: Parameters<typeof findElementUp>) {\n  const entry = findElementUp(...args)\n  return entry?.[1]\n}\n","import { Element, Node } from \"slate\"\n\nexport type NodeMatcher = string | string[] | ((node: Node) => boolean)\n\n/**\n * Takes a string or a function that matches a Node and in both cases,\n * returns a function that matches a Node.\n *\n * The `matchNode` argument can either be a function that takes a `Node` and\n * returns a boolean or it can be a string representing the `type` property of\n * an `Element`\n */\n\nexport function standardizeNodeMatcher(\n  matchNode: NodeMatcher\n): (node: Node) => boolean {\n  if (typeof matchNode === \"function\") return matchNode\n  if (typeof matchNode === \"string\")\n    return (node: Node) => Element.isElement(node) && node.type === matchNode\n  if (Array.isArray(matchNode))\n    return (node: Node) =>\n      Element.isElement(node) && matchNode.includes(node.type)\n  throw new Error(\n    `Expected matchNode to be a function, string or array but is ${matchNode}`\n  )\n}\n","import { SVGProps } from \"react\"\n\n/**\n * A shortcut type to SVGProps<SVGSVGElement> but also more explicit in its\n * intent and allows for changing the props in the future without another\n * refactor.\n */\nexport type TablerIconProps = SVGProps<SVGSVGElement>\n\n/**\n * Efficient way to create a Tabler Icon.\n *\n * https://tabler-icons.io/\n *\n * - Grab the SVG from the Tabler Icon.\n * - Run it through https://react-svgr.com/playground/?icon=true&typescript=true\n * - Grab everything EXCEPT the first `path` which is unnecessary\n * - Place it as the children of this `<Icon>`\n */\nexport const TablerIcon = ({\n  strokeWidth = 1.5,\n  ...props\n}: TablerIconProps) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"1em\"\n    height=\"1em\"\n    strokeWidth={strokeWidth}\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    viewBox=\"0 0 24 24\"\n    {...props}\n  />\n)\n","export * from \"./is-collapsed\"\nexport * from \"./is-element-type\"\nexport * from \"./is-end-of-element\"\nexport * from \"./is-in-empty-element\"\nexport * from \"./is-start-of-element\"\n","import { Range } from \"slate\"\n\nexport function isCollapsed(\n  selection: Range | null | undefined\n): selection is Range {\n  if (selection == null) return false\n  return Range.isCollapsed(selection)\n}\n","import { Element, Node } from \"slate\"\n\nexport function isElementType<T extends Element>(\n  node: Node,\n  type: T[\"type\"] | Array<T[\"type\"]>\n): node is T {\n  if (Array.isArray(type)) {\n    return Element.isElement(node) && type.includes(node.type)\n  }\n  if (typeof type === \"string\") {\n    return Element.isElement(node) && node.type === type\n  }\n  throw new Error(\n    `Expected elementType to be string or array of string but is ${type}`\n  )\n}\n\nexport function createIsElementType<T extends Element>(\n  type: T[\"type\"] | Array<T[\"type\"]>\n): (node: Node) => node is T {\n  if (Array.isArray(type)) {\n    return (node: Node): node is T =>\n      Element.isElement(node) && type.includes(node.type)\n  } else {\n    return (node: Node): node is T =>\n      Element.isElement(node) && type == node.type\n  }\n}\n","import { Editor } from \"slate\"\n\nimport { findElementUp } from \"../find-utils/find-element-up\"\nimport { NodeMatcher } from \"../standardize-utils/standardize-node-matcher\"\nimport { isCollapsed } from \"./is-collapsed\"\n\n/**\n * Checks to see if the current selection is at the end of line for a node\n * that matches the `matchNode` argument.\n *\n * The `matchNode` argument can either be a function that takes a `Node` and\n * returns a boolean or it can be a string representing the `type` property of\n * an `Element`\n */\n\nexport function isEndOfElement(\n  editor: Editor,\n  matchNode: NodeMatcher\n): boolean {\n  const { selection } = editor\n  if (!isCollapsed(selection)) return false\n  const entry = findElementUp(editor, matchNode, { at: selection })\n  return !!entry && Editor.isEnd(editor, selection.anchor, entry[1])\n}\n","import { Editor } from \"slate\"\n\nimport { findElementUp } from \"../find-utils/find-element-up\"\nimport { NodeMatcher } from \"../standardize-utils/standardize-node-matcher\"\nimport { isCollapsed } from \"./is-collapsed\"\n\n/**\n * Checks to see if we are currently in an empty element.\n *\n * All these must be true:\n *\n * - There is a selection\n * - The selection is inside the matching element\n * - The matching element is empty\n */\nexport function isInEmptyElement(\n  editor: Editor,\n  matchNode: NodeMatcher\n): boolean {\n  const { selection } = editor\n  if (!isCollapsed(selection)) return false\n  const entry = findElementUp(editor, matchNode)\n  if (entry === undefined) return false\n  return Editor.isEmpty(editor, entry[0])\n}\n","import { Editor } from \"slate\"\n\nimport { findElementUp } from \"../find-utils/find-element-up\"\nimport { NodeMatcher } from \"../standardize-utils/standardize-node-matcher\"\nimport { isCollapsed } from \"./is-collapsed\"\n\n/**\n * Checks to see if the current selection is at the end of line for a node\n * that matches the `matchNode` argument.\n *\n * The `matchNode` argument can either be a function that takes a `Node` and\n * returns a boolean or it can be a string representing the `type` property of\n * an `Element`\n */\n\nexport function isStartOfElement(\n  editor: Editor,\n  matchNode: NodeMatcher\n): boolean {\n  const { selection } = editor\n  if (!isCollapsed(selection)) return false\n  const entry = findElementUp(editor, matchNode, { at: selection })\n  return !!entry && Editor.isStart(editor, selection.anchor, entry[1])\n}\n","export * from \"./create-autocomplete-space-handler\"\nexport * from \"./create-hotkey-handler\"\nexport * from \"./is-better-hotkey\"\n","import { isHotkey } from \"is-hotkey\"\nimport { Editor, Element as SlateElement, Range, Transforms } from \"slate\"\n\nimport { findElementUp, stopEvent } from \"~/src/sink\"\n\nexport const isSpace = isHotkey(\" \")\nexport const isShiftSpace = isHotkey(\"SHIFT+SPACE\")\n\nexport function createAutocompleteSpaceHandler(\n  editor: Editor,\n  methods: Record<string, undefined | (() => void)>\n) {\n  return (e: React.SyntheticEvent<Element, KeyboardEvent>): boolean => {\n    /**\n     * We support `shift+space` as well because when we are typing something\n     * like `## ` sometimes the finger hasn't left the shift key yet. In normal\n     * usage, we still get a space and so the feature feels intermittently\n     * broken if we don't support `shift+space`.\n     */\n    if (!isSpace(e.nativeEvent) && !isShiftSpace(e.nativeEvent)) return false\n\n    /**\n     * Make sure theere is a selection and it's collapsed\n     */\n    const { selection } = editor\n    if (selection === null) return false\n    if (Range.isExpanded(selection)) return false\n\n    /**\n     * Find a convertible block and if we can't find one, exit.\n     */\n    const convertibleBlockEntry = findElementUp(\n      editor,\n      (node) =>\n        /**\n         * NOTE: We alias to SlateElement because this page needs acces to both\n         * the global Eleent and the Slate Element.\n         */\n        SlateElement.isElement(node) &&\n        editor.convertElement.isConvertibleElement(node)\n    )\n    if (!convertibleBlockEntry) return false\n\n    /**\n     * Find a matching method. Note that the keys in `methods` are the `string`\n     * prefixes we are looking for like `##` for heading level 2.\n     *\n     * If no match, exit.\n     */\n    const range = {\n      anchor: Editor.start(editor, convertibleBlockEntry[1]),\n      focus: selection.focus,\n    }\n    const text = Editor.string(editor, range)\n    const method = methods[text]\n    if (!method) return false\n\n    /**\n     * We have a match. Stop other event handlers.\n     */\n    stopEvent(e)\n\n    /**\n     * Delete the autocomplete text that came before the space bar was pressed.\n     */\n    const deleteRange = {\n      anchor: Editor.start(editor, convertibleBlockEntry[1]),\n      focus: selection.focus,\n    }\n    Transforms.delete(editor, { at: deleteRange })\n\n    /**\n     * Execute the matching method.\n     */\n    method()\n    return true\n  }\n}\n","import { isBetterHotkey } from \"./is-better-hotkey\"\n\n/**\n * The function that is executed when the hotkey is pressed.\n *\n * If it returns `void` (undefined) we assume the Action was executed.\n * If we return a `boolean`, the Action is considered executed if it returns\n * `true` or not handled if it returns `false`.\n */\ntype Action = () => boolean | void\n\ntype IsKeyboardShortcut = (event: KeyboardEvent) => boolean\n\ntype ShortcutTuple = [IsKeyboardShortcut, Action]\n\n/**\n * Creates a `keyDown` handler from an object where the keys are the shortcut\n * and the values are the `Action` function to execute. If the\n * function returns `true`, the event is considered handled and the event\n * is stopped.\n *\n * In some situations, we don't want the event to be stopped.\n *\n * For example, hitting `up` or `down` in a table, starts a `setTimeout` but\n * we want the original keyboard event to be handled by the browser.\n */\n\nexport function createHotkeyHandler(shortcutsObject: Record<string, Action>) {\n  /**\n   * Don't populate the shortcuts at this point because it will run on the\n   * server. We can't run it on the server because we need to determine if we\n   * are on Mac or Windows and checking `window.navigate.userAgent` will cause\n   * a failure.\n   */\n  let shortcuts: ShortcutTuple[] | null = null\n\n  return function handleShortcuts(\n    event: React.SyntheticEvent<Element, KeyboardEvent>\n  ) {\n    /**\n     * We initialize shortcuts once on first usage.\n     */\n    if (shortcuts == null) {\n      shortcuts = Object.entries(shortcutsObject).map(([shortcut, fn]) => [\n        isBetterHotkey(shortcut),\n        fn,\n      ])\n    }\n    for (const [isShortcut, action] of shortcuts) {\n      if (isShortcut(event.nativeEvent)) {\n        /**\n         * If the keyboardAction returns true then the event has been handled.\n         * We can stop the event at this point and exit the loop.\n         */\n        const response = action()\n        if (response === true || response === undefined) {\n          event.preventDefault()\n          event.stopPropagation()\n          return true\n        }\n      }\n    }\n    return false\n  }\n}\n","import { isHotkey } from \"is-hotkey\"\n\nimport { isMac } from \"../core-utils/is-mac\"\n\nexport function isBetterHotkey(hotkey: string) {\n  const modifiedHotkey = hotkey.replace(\n    /\\bsuper\\b/g,\n    isMac() ? \"cmd+alt\" : \"ctrl+shift\"\n  )\n  return isHotkey(modifiedHotkey)\n}\n","import { Editor, Path, Transforms } from \"slate\"\n\n/**\n * Takes a given and makes that specific path dirty with respect to\n * normalization and executes a normalization path (unless in a\n * `withoutNormalizing` block in which case it will wait until it is completed).\n *\n * A few things you should know:\n *\n * - It doesn't dirty the ancestors. So if you are targeting an Element to be\n *   dirtied, make sure you aren't dirtying the Text node as that won't cause\n *   the parent Element to be dirtied.\n *\n * - It works by setting a key that doesn't make sense to a value and then\n *   unsetting it. This adds some unnecessary noise to the list of operations.\n *\n * The ideal method to implement this would be to modify the DIRTY_PATHS and\n * DIRTY_PATH_KEYS directly; however, these are presently not being exported.\n * This should probably be fixed in the future by an exported function called\n * something like `addDirtyPaths`.\n */\nexport function forceNormalizePath(editor: Editor, path: Path) {\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.setNodes(\n      editor,\n      // @ts-ignore\n      { __DOESNT_MATTER_JUST_TO_START_NORMALIZING__: \"123\" },\n      { at: path }\n    )\n    Transforms.setNodes(\n      editor,\n      // @ts-ignore\n      { __DOESNT_MATTER_JUST_TO_START_NORMALIZING__: null },\n      { at: path }\n    )\n  })\n}\n","import { Descendant, Editor, NodeEntry } from \"slate\"\n\n/**\n * This normalization utility is useful when you need to adjust an Element\n * depending on the Element before or after it.\n *\n * For example, if two of the same nodes are next to each other, they can be\n * merged together.\n *\n * Or in the case of a numbered list, we want to reset the counter only if\n * the list is deeper than the previous one.\n *\n * The thing that makes these method efficient is that it can often replace\n * having to search through all children of the parent of the current element.\n * Normally, to compare siblings, you'd have to look at the parent in order\n * to make sure you normalize siblings propertly; however, this method will\n * look both at the pair before/current and current/after to make sure that\n * neighbor siblings do the right thing.\n *\n * When used through a full normalization, it can solve bigger problems. For\n * example, if you have 5 elements that are all the same and they need to\n * all be merged, one by one, they will merged into a single Element.\n *\n * HINT:\n *\n * If there is a bug related to not being able to find a Path, remember to\n * return `true` in the `transform` function when a `transform` is executed.\n *\n * After a `transform` is run, the state of the document is changed and\n * running the second `transform` may result in accessing an invalid path.\n */\nexport function normalizeSiblings<T extends Descendant>(\n  editor: Editor,\n  entry: NodeEntry<T>,\n  transform: (a: NodeEntry<T>, b: NodeEntry<T>) => boolean\n): boolean {\n  const [, path] = entry\n\n  const prevEntry = Editor.previous<T>(editor, { at: path })\n  if (prevEntry && transform(prevEntry, entry)) return true\n\n  const nextEntry = Editor.next<T>(editor, { at: path })\n  if (nextEntry && transform(entry, nextEntry)) return true\n\n  return false\n}\n","import { Editor, Path, Transforms } from \"slate\"\n\n/**\n * Puts the selection at the start of a Node at the given path.\n */\nexport function selectStartOfElement(editor: Editor, path: Path) {\n  Transforms.select(editor, Editor.start(editor, path))\n}\n\n/**\n * Puts the selection at the start of a Node at the given path.\n */\nexport function selectEndOfElement(editor: Editor, path: Path) {\n  Transforms.select(editor, Editor.end(editor, path))\n}\n","export * from \"./standardize-node-matcher\"\nexport * from \"./target-element\"\n","import { Element } from \"slate\"\n\n/**\n * The TargetElement can be specified either as the actual value or as a\n * function that takes a srcElement and returns the targetElement.\n */\nexport type TargetElement<T extends Element = Element> =\n  | Omit<T, \"children\">\n  | ((srcElement: Element) => Omit<T, \"children\">)\n\n/**\n * TODO:\n *\n * This should probably just be moved into the `rewrapElement` function page\n * since it is not used outside of it. Originally, this may have served a\n * dual purpose but currently it seems like it only exists for the use of\n * `rewrapElement`.\n */\n\n/**\n * This function takes a `srcElement` and the idea is that we convert it into\n * some other type of element, which is the `targetElement`.\n *\n * The `TargetElement` can be specified either as:\n *\n * - an actual `Element` but without the `children`. This is because we are\n *   converting the `srcElement` to the `targetElement` and the `targetElement`\n *   will take on the `children` of the `srcElement`\n *\n * - A function that takes the `srcElement` and returns the `targetElement`\n *   without the `children`. This form of `TargetElement` can be useful in\n *   cases where we want to retain some of the properties of the `srcElement`.\n *   An example of this is a list item where we convert from a bullet to a\n *   numbered item. We would like to keep the `depth` information if it exists\n *   in this scenario.\n */\nexport function createTargetElement<T extends Element>(\n  srcElement: Element,\n  targetElement: TargetElement<T>\n) {\n  if (typeof targetElement !== \"function\") return targetElement\n  return targetElement(srcElement)\n}\n","export * from \"./insert-root-element\"\nexport * from \"./rewrap-element\"\nexport * from \"./set-nodes-dynamic\"\n","import { Editor, Element, Location, Path, Transforms } from \"slate\"\n\nimport { findElementUp } from \"~/src/sink\"\n\n/**\n * Inserts an Element into the document such that if it is in a `isMaster`\n * element (i.e. an Element that has a number of dependants like a table or\n * code block) then then inserted Element will appear after the `isMaster`\n * element.\n *\n * This prevents invalid states from happening like inserting a table inside\n * a table, or a code block in a table, or a table in a code block.\n */\nexport function insertRootElement(\n  editor: Editor,\n  element: Element,\n  { at = editor.selection }: { at?: Location | null } = {}\n): boolean {\n  /**\n   * If there's no `at` then insertion does not happen\n   */\n  if (at == null) return false\n  /**\n   * Look for a parent that `isMaster`\n   */\n  const entry = findElementUp(\n    editor,\n    (node) => Element.isElement(node) && editor.isMaster(node)\n  )\n  if (entry == null) {\n    /**\n     * If not `isMaster` then do a regular insert, select the original\n     * insertion point and move forward to select the first position inside\n     * the newly inserted element.\n     */\n    const selection = editor.selection\n    Editor.withoutNormalizing(editor, () => {\n      Transforms.insertNodes(editor, element, { at })\n      if (selection) {\n        Transforms.select(editor, selection)\n        Transforms.move(editor)\n      }\n    })\n  } else {\n    /**\n     * If it `isMaster` then find the next adjacent path to the master, insert\n     * there, and then select at the start of the insertion point.\n     */\n    const nextPath = Path.next(entry[1])\n    Editor.withoutNormalizing(editor, () => {\n      Transforms.insertNodes(editor, element, { at: nextPath })\n      Transforms.select(editor, Editor.start(editor, nextPath))\n    })\n  }\n  return true\n}\n","import { Editor, Element, NodeEntry, Path, Transforms } from \"slate\"\n\nimport {\n  createTargetElement,\n  TargetElement,\n} from \"../standardize-utils/target-element\"\n\n/**\n * Takes an existing Element at path `at` and swaps out that Element with a\n * new Element. It does this by unwrapping the Element and rewrapping it with\n * the new Element.\n *\n * This is useful because if we do it this way, we can preserve the selection.\n */\nexport function rewrapElement<T extends Element = Element>(\n  editor: Editor,\n  targetElement: TargetElement<T>,\n  at: Path\n) {\n  Editor.withoutNormalizing(editor, () => {\n    const originalEntry = Editor.node(editor, at) as NodeEntry<Element>\n    const nextElement = createTargetElement(originalEntry[0], targetElement)\n    /**\n     * Technicall, it's Omit<Element, 'children'> but `wrapNodes` actually\n     * accepts that just fine so we override the type.\n     */\n    Transforms.wrapNodes(editor, nextElement as T, { at })\n    Transforms.unwrapNodes(editor, { at: [...at, 0] })\n  })\n}\n","import { Editor, EditorNodesOptions, Node, Transforms } from \"slate\"\n\n/**\n * An improved version of `setNodes` that takes a `convert` option.\n *\n * In existing `setNodes` we can specify how we want to setNodes statically.\n * That is, before we execute `setNodes` we need to know which properties\n * we want to set.\n *\n * This version of `setNodes` allows us to dynamically setNodes by allowing\n * us to specify a function argument. The function takes the original value of\n * an Element and returns the match.\n */\nexport function setNodesDynamic<T extends Node>(\n  editor: Editor,\n  convert: (node: T) => Partial<T>,\n  options: EditorNodesOptions<T>\n) {\n  const entries = Array.from(Editor.nodes<T>(editor, options))\n  if (entries.length === 0) return false\n  for (const entry of entries) {\n    const [node] = entry\n    Transforms.setNodes(editor, convert(node), { at: entry[1] })\n  }\n  return true\n}\n","import { BaseEditor, BaseText } from \"slate\"\nimport { HistoryEditor } from \"slate-history\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { AnchorPlugin } from \"~/src/anchor-plugin\"\nimport { AtomicDeletePlugin } from \"~/src/atomic-delete-plugin\"\nimport { BlockQuotePlugin } from \"~/src/block-quote-plugin\"\nimport { CodeBlockPlugin } from \"~/src/code-block-plugin\"\nimport { CollapsibleParagraphPlugin } from \"~/src/collapsible-paragraph-plugin\"\nimport { ConvertElementPlugin } from \"~/src/convert-element-plugin\"\nimport { HeadingPlugin } from \"~/src/heading-plugin\"\nimport { HorizontalRulePlugin } from \"~/src/horizontal-rule-plugin\"\nimport { ImagePlugin } from \"~/src/image-plugin\"\nimport { InlineCodePlugin } from \"~/src/inline-code-plugin\"\nimport { ListPlugin } from \"~/src/list-plugin\"\nimport { MarksPlugin } from \"~/src/marks-plugin\"\nimport { NormalizeAfterDeletePlugin } from \"~/src/normalize-after-delete-plugin\"\nimport { ExtractCustomTypes } from \"~/src/sink\"\nimport { TablePlugin } from \"~/src/table-plugin\"\nimport { ThemePlugin } from \"~/src/theme-plugin\"\nimport { ToolbarPlugin } from \"~/src/toolbar-plugin\"\nimport { TrailingBlockPlugin } from \"~/src/trailing-block-plugin\"\nimport { UploadPlugin } from \"~/src/upload-plugin\"\n\nimport { AttachmentPlugin } from \"../attachment-plugin\"\nimport { PasteMarkdownPlugin } from \"../paste-markdown-plugin\"\nimport { PlaceholderPlugin } from \"../placeholder-plugin\"\nimport { WysimarkEditor } from \"./types\"\n\nexport const plugins = [\n  PasteMarkdownPlugin,\n  ConvertElementPlugin,\n  AnchorPlugin,\n  HeadingPlugin,\n  MarksPlugin,\n  InlineCodePlugin,\n  BlockQuotePlugin,\n  CodeBlockPlugin,\n  TablePlugin,\n  HorizontalRulePlugin,\n  TrailingBlockPlugin,\n  ListPlugin,\n  AtomicDeletePlugin,\n  NormalizeAfterDeletePlugin,\n  CollapsibleParagraphPlugin,\n  ThemePlugin,\n  ToolbarPlugin,\n  UploadPlugin,\n  AttachmentPlugin,\n  ImagePlugin,\n  PlaceholderPlugin,\n]\n\nexport type PluginTypes = ExtractCustomTypes<typeof plugins>\n\ntype CustomEditor = PluginTypes[\"Editor\"]\ntype CustomElement = PluginTypes[\"Element\"]\ntype CustomText = PluginTypes[\"Text\"]\n\nexport type OptionsType = PluginTypes[\"Options\"]\nexport type Element = CustomElement\nexport type Text = CustomText\n\ndeclare module \"slate\" {\n  interface CustomTypes {\n    Editor: BaseEditor &\n      ReactEditor &\n      HistoryEditor &\n      CustomEditor &\n      WysimarkEditor\n    Element: CustomElement\n    Text: BaseText & CustomText\n  }\n}\n","import { Descendant } from \"slate\"\n\nimport { createPlugin, curryOne } from \"~/src/sink\"\n\nimport { TypedPlugin } from \"../sink/types/plugin/plugin\"\nimport { onPaste } from \"./editable/on-paste\"\nimport { createAnchorMethods } from \"./methods\"\nimport { normalizeNode } from \"./normalize-node\"\nimport { Anchor } from \"./render-element/anchor\"\n\ntype AnchorMethods = ReturnType<typeof createAnchorMethods>\n\nexport type AnchorEditor = {\n  anchor: AnchorMethods\n}\n\nexport type AnchorElement = {\n  type: \"anchor\"\n  href: string\n  target?: string\n  title?: string\n  children: Descendant[]\n}\n\nexport type AnchorPluginCustomTypes = {\n  Name: \"anchor\"\n  Editor: AnchorEditor\n  Element: AnchorElement\n}\n\nexport const AnchorPlugin = createPlugin<AnchorPluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.anchor = createAnchorMethods(editor)\n    return createPolicy({\n      name: \"anchor\",\n      editor: {\n        isInline(element) {\n          if (element.type === \"anchor\") return true\n        },\n        normalizeNode: curryOne(normalizeNode, editor),\n      },\n      editableProps: {\n        onPaste: curryOne(onPaste, editor),\n        renderElement: ({ element, attributes, children }) => {\n          if (element.type === \"anchor\") {\n            return (\n              <Anchor element={element} attributes={attributes}>\n                {children}\n              </Anchor>\n            )\n          }\n        },\n      },\n    })\n  }\n) as TypedPlugin<AnchorPluginCustomTypes>\n","import { Editor } from \"slate\"\n\nexport function onPaste(\n  editor: Editor,\n  e: React.ClipboardEvent<HTMLDivElement>\n) {\n  const clipboardData = e.clipboardData\n  const { types } = clipboardData\n\n  console.log(clipboardData.getData(\"text/html\"))\n\n  /**\n   * We don't want to handle it if it's not just plain text. If it is\n   * plain text, it will have only one type and it will be \"text/plain\".\n   * HTML, for example, also has \"text/plain\" but also \"text/html\"\n   */\n  if (types.length > 1) return false\n  if (types[0] !== \"text/plain\") return false\n\n  /**\n   * Check to make sure the text is a URL\n   */\n  const text = clipboardData.getData(\"text/plain\")\n  if (!isUrl(text)) return false\n\n  /**\n   * If it is a URL, then insert the link\n   */\n  e.preventDefault()\n  e.stopPropagation()\n  editor.anchor.insertLink(text)\n  return true\n}\nfunction isUrl(s: string): boolean {\n  let url\n  try {\n    url = new URL(s)\n  } catch (_) {\n    return false\n  }\n  return (\n    url.protocol === \"http:\" ||\n    url.protocol === \"https:\" ||\n    url.protocol === \"mailto:\"\n  )\n}\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { editLink } from \"./editLink\"\nimport { insertLink } from \"./insertLink\"\nimport { removeLink } from \"./removeLink\"\n\nexport function createAnchorMethods(editor: Editor) {\n  return {\n    insertLink: curryOne(insertLink, editor),\n    removeLink: curryOne(removeLink, editor),\n    editLink: curryOne(editLink, editor),\n  }\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt, findElementUp } from \"../../sink\"\nimport { AnchorElement } from \"..\"\n\nexport function editLink(\n  editor: Editor,\n  { href, title }: { href: string; title?: string },\n  { at }: { at?: BetterAt }\n) {\n  const link = findElementUp(editor, \"anchor\", { at })\n  if (!link) return false\n  Transforms.setNodes<AnchorElement>(editor, { href, title }, { at: link[1] })\n  return true\n}\n","import { Editor, Range, Text, Transforms } from \"slate\"\n\nexport function insertLink(\n  editor: Editor,\n  href: string,\n  text: string = href,\n  { select = true }: { select?: boolean } = {}\n) {\n  /**\n   * If there is no selection, we default by inserting at the start of document.\n   */\n  const selection = editor.selection || {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.start(editor, [0]),\n  }\n  if (Range.isCollapsed(selection)) {\n    /**\n     * Insert the node and select it if select is true\n     */\n    Transforms.insertNodes(\n      editor,\n      {\n        type: \"anchor\",\n        href,\n        children: [{ text }],\n      },\n      { select, at: selection }\n    )\n    /**\n     * If select is true then select the inserted link\n     */\n    if (select && editor.selection) {\n      const entry = Editor.node(editor, editor.selection)\n      Transforms.select(editor, entry[1])\n    }\n  } else {\n    /**\n     * If there is a selection, we wrap the selection with our anchor.\n     */\n    Transforms.wrapNodes(\n      editor,\n      { type: \"anchor\", href, children: [] },\n      {\n        split: true,\n        match: (node) => Text.isText(node) || Editor.isInline(editor, node),\n      }\n    )\n  }\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt, findElementUp } from \"../../sink\"\n\nexport function removeLink(editor: Editor, { at }: { at?: BetterAt }) {\n  const link = findElementUp(editor, \"anchor\", { at })\n  if (!link) return false\n  Transforms.unwrapNodes(editor, { at: link[1] })\n  return true\n}\n","import { Editor, Element, Node, NodeEntry, Transforms } from \"slate\"\n\n/**\n * If there is an anchor node inside an anchor node, unwrap the inner anchor\n * node as that is not allowed.\n *\n * Another approach would be to lift the nodes but I think unwrapping the\n * inner one makes more sense. Consider these two scenarios (keeping in mind\n * that they will likely be rare):\n *\n * - User selects text that includes a link. Then user links it. The user would\n *   have a strong expectation that the link just applied would override the\n *   link on the inside.\n *\n * - The opposite: User select text inside an existing link then tries to link\n *   it. That's unusual and while the user may expect that inner selection to\n *   get linked, I think this is a rare enough case whereas the prior one seems\n *   like a slightly more natural one.\n *\n * We could, of course, solve both of these by adding more code paths at the\n * time the link is inserted. That won't change this normalization code and\n * not sure if it is worth the extra complexity.\n */\nexport function normalizeNode(editor: Editor, entry: NodeEntry<Node>): boolean {\n  if (!Element.isElement(entry[0])) return false\n  if (entry[0].type !== \"anchor\") return false\n  const children = entry[0].children\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    if (!Element.isElement(child) || child.type !== \"anchor\") continue\n    Transforms.unwrapNodes(editor, { at: [...entry[1], i] })\n    return true\n  }\n  return false\n}\n","import { clsx } from \"clsx\"\nimport { useEffect, useRef } from \"react\"\nimport { useSelected } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { useUpload } from \"../../upload-plugin/store\"\nimport { useLayer } from \"../../use-layer\"\nimport { AnchorElement } from \"../index\"\nimport { $Anchor, $Edge } from \"../styles\"\nimport { AnchorDialog } from \"./AnchorDialog\"\nimport { ProgressBar } from \"./ProgressBar\"\n\nexport function Anchor({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<AnchorElement>) {\n  const startEdgeRef = useRef<HTMLSpanElement>(null)\n  const anchorRef = useRef<HTMLAnchorElement>(null)\n  const selected = useSelected()\n  const upload = useUpload(element.href)\n  const dialog = useLayer(\"dialog\")\n\n  /**\n   * TODO:\n   *\n   * Finish implementing the anchor dialog.\n   *\n   * Stopped partway through because the entire document is being re-rendered\n   * on every keypress.\n   */\n\n  useEffect(() => {\n    const anchor = anchorRef.current\n    const startEdge = startEdgeRef.current\n    if (!anchor || !startEdge) return\n    /**\n     * NOTE: Do not use `focused && selected` here because when we click or\n     * focus on the pop up dialogs themselves, this will cause the dialogs to\n     * close.\n     *\n     * TODO: Figure out how to make the dialogs not close when clicking on them.\n     *\n     * It has to support these use cases:\n     *\n     * - Closes when user clicks somewhere in the document outside the link\n     * - Stays open when user clicks on the dialog\n     * - Stays open when user is in an input in the dialog\n     * - Closes when the editor loses focus but stays open when the editor loses\n     *   focus to the anchor dialog or the anchor edit dialog\n     */\n    if (selected) {\n      /**\n       * The setTimeout delay is necessary when first clicking into the browser\n       * and when switching from one link to another. Without it, the dialog\n       * will not open.\n       */\n      setTimeout(() => {\n        dialog.open(() => (\n          <AnchorDialog\n            destAnchor={anchor}\n            destStartEdge={startEdge}\n            element={element}\n          />\n        ))\n      })\n    } else {\n      dialog.close()\n    }\n  }, [selected, element])\n\n  return (\n    <$Anchor\n      className={clsx({ \"--selected\": selected })}\n      href={element.href}\n      target={element.target}\n      {...attributes}\n      ref={anchorRef}\n    >\n      {/* Edge allow Chrome to differentiate in/out of the link */}\n      <$Edge ref={startEdgeRef} contentEditable={false} />\n      {upload?.status === \"progress\" ? (\n        <ProgressBar\n          anchorRef={anchorRef}\n          progress={upload.sentBytes / upload.totalBytes}\n        />\n      ) : null}\n      <span>{children}</span>\n      {/* Edge allow Chrome to differentiate in/out of the link */}\n      <$Edge contentEditable={false} />\n    </$Anchor>\n  )\n}\n","import { Editor } from \"slate\"\n\nimport { Upload } from \"../types\"\nexport * from \"./create-upload-store\"\nexport * from \"./use-upload\"\n\n/**\n * Types related to the `zustand` state-management library which we use to\n * store the state of uploads.\n */\n\nexport type GetUpload = (id: string) => Upload\nexport type SetUpload = (id: string, upload: Upload) => void\n\nexport type UploadStore = {\n  uploads: Record<string, Upload>\n  getUpload: GetUpload\n  setUpload: SetUpload\n}\n\nexport function setUpload(editor: Editor, id: string, upload: Upload) {\n  const store = editor.upload.useUploadStore.getState()\n  store.setUpload(id, upload)\n}\n","import create from \"zustand\"\n\nimport { Upload } from \"../types\"\nimport { UploadStore } from \"./index\"\n\n/**\n * Creates an origin store using `zustand`.\n *\n * The purpose of this is to keep track of uploads and their progress but only\n * storing the key to the lookup in the Element itself.\n *\n * This is necessary so that the Element value stays the same even as the image\n * progress is updating during the upload.\n *\n * We want this because we don't want the progress updates to be part of the\n * document's edit history. Consider that a user executes an undo and it undoes\n * the progress of the upload.\n *\n * Te return value of `createUploadStore` is a React hook.\n *\n * The hook should be referenced as `useUploadStore`\n */\n\nexport const createUploadStore = (\n  { uploads = {} }: { uploads: Record<string, Upload> } = { uploads: {} }\n) => {\n  return create<UploadStore>((set, get) => ({\n    uploads,\n    setUpload(id: string, origin: Upload): void {\n      set((state: UploadStore) => ({\n        uploads: {\n          ...state.uploads,\n          [id]: origin,\n        },\n      }))\n    },\n    getUpload(id: string): Upload {\n      const origin = get().uploads[id]\n      if (origin === undefined) {\n        throw new Error(`Expected origin with id \"${id}\" but could not find it`)\n      }\n      return origin\n    },\n  }))\n}\n","import { useSlateStatic } from \"slate-react\"\n\nimport { Upload } from \"../types\"\n\n/**\n * Takes a `url` and returns the `Upload` associated with it.\n *\n * If it starts with a `#` then it is used as a reference to an Upload in the\n * upload store and returns the `Upload` associated with it.\n *\n * Otherwise, the `url` is an uploaded file and it is returned as such. This\n * would happen if the document is saved and loaded.\n */\n\nexport function useUpload(url: string): Upload {\n  const editor = useSlateStatic()\n  /**\n   * We call this even if it's not always required because it calls `useStore`\n   * which is a React hook which means it needs to be called consistently.\n   */\n  const upload = editor.upload.useUploadStore((state) => state.uploads[url])\n  if (url.includes(\"/\")) {\n    return {\n      status: \"success\",\n      url: url,\n    }\n  } else {\n    return upload\n  }\n}\n","export * from \"./layers\"\nexport * from \"./use-layer\"\n","import { createContext, useState } from \"react\"\n\nimport { Portal } from \"./portal\"\nimport { Layer, LayersContextValue, LayersRecord } from \"./types\"\n\n/**\n * Wrap this around the Component in which you want to have the ability to\n * display one or more layers at once.\n */\nexport const LayersContext = createContext<LayersContextValue>(\n  /**\n   * This is set to an invalid value and then typecast as the correct type.\n   *\n   * This is okay though because in `LayersProvider` we set the value to the\n   * proper type before they are used for the first time.\n   */\n  {} as LayersContextValue\n)\n\nexport const LayerContext = createContext<Layer>({} as Layer)\n\n/**\n * The `Layers` Component should be wrapped around the Component or Components\n * which you want to have layer support.\n *\n * The `useLayer` hook must be called inside a `Layers` Component.\n *\n * It provides these necessary functions:\n *\n * - Makes available the resources necessary to open and close layers.\n *\n * - Renders the currently open layers to the DOM at the top level of the\n *   DOM. We do this to simplify positioning as we can position everything\n *   relative to the full window which is what is returned by\n *   `getBoundingClientRect`\n *\n * NOTE:\n *\n * As a design decision, we wrap many components with the Layer instead of\n * having a Layer per component. This design decision is important because\n * we may want to open multiple layers of the same type and if we open another\n * layer of the same type, we want any other layers to close.\n *\n * For example, consider a Dialog. If we open a differnet Dialog, we want the\n * first one to close. This can only be done when a single component knows\n * about the existence of both.\n */\nexport function Layers({ children }: { children: React.ReactNode }) {\n  const [layers, setLayers] = useState<LayersRecord>({})\n\n  /**\n   * Open a layer of the given type\n   */\n  function openLayer(layer: Layer) {\n    setLayers((layers) => {\n      return {\n        ...layers,\n        [layer.type]: layer,\n      }\n    })\n  }\n\n  /**\n   * Close a layer of the given type\n   */\n  function closeLayer(layerType: string) {\n    setLayers((layers) => {\n      const nextLayers = { ...layers }\n      delete nextLayers[layerType]\n      return nextLayers\n    })\n  }\n\n  /**\n   * - provide the layers context\n   * - render the layers at the top of the DOM using a Portal\n   */\n  return (\n    <LayersContext.Provider\n      value={{ layers, setLayers, openLayer, closeLayer }}\n    >\n      {children}\n      {Object.entries(layers).map(([, layer]) => {\n        return (\n          <Portal key={layer.type}>\n            <LayerContext.Provider value={layer}>\n              <layer.Component />\n            </LayerContext.Provider>\n          </Portal>\n        )\n      })}\n    </LayersContext.Provider>\n  )\n}\n","import { createPortal } from \"react-dom\"\n\n/**\n * Portal to `document.body`\n *\n * NOTE:\n * Consider creating a version of Portal with a Reset in it.\n *\n * The reason is that when showing a portal, it will carry the baggage of\n * any styling from `<html>` and `<body>` element.\n */\nexport function Portal({ children }: { children: React.ReactNode }) {\n  return createPortal(children, document.body)\n}\n","import { FunctionComponent, useContext } from \"react\"\n\nimport { LayersContext } from \"./layers\"\nimport { Layer } from \"./types\"\n\n/**\n * `useLayer` may only be called when it is inside a Component that is itself\n * nested under the `Layers` component. This is necessary because `useLayer`\n * uses a React Context which is set up in the `Layers` component.\n *\n * Using the `useLayer` hook returns a layer object that has an `open` and\n * `close` method. You can use it something like this:\n *\n * ```typescript\n * function MyComponent() {\n *\n *   const tooltip = useLayer('tooltip')\n *\n *   const openTootlip = () => {\n *     tooltip.open(() => <Tooltip title=\"Hey Dudes\" />)\n *   }\n *\n *   return <div\n *     onMouseEnter={openTooltip}\n *     onMouseLeave={tooltip.close}\n *   >Thing that needs a tooltip</div>\n * }\n * ```\n *\n * In this scenario, it opens a `Tooltip` component when the mouse enters the\n * div and closes it when the mouse leave it.\n *\n * This library is simple but flexible enough to be used to handle different\n * kinds of components that pop up in the DOM.\n *\n * - tooltips\n * - dialog boxes positioned where a button is clicked\n * - dialog boxes positioned in the center of a viewport\n * - notifications\n *\n * `useLayer` is designed to handle just the opening and closing of the layers\n * that overlays on top of all the other components at the top of the DOM.\n *\n * It also ensures only one of each kind of layer is open at a time. So when\n * a second tooltip is opened, the first is closed.\n *\n * The positioning of the tooltips, dialogs and notifications, especially when\n * the position is relative to another element like a button that was clicked\n * it the domain of the `useReposition` micro library.\n *\n * These libraries are not tied together in any way (there is nothing\n * opinionated that ties them toegher); however they were designed and built\n * at the same time and work together well to solve all the issues related to\n * popup windows/dialogs/tooltips of any kind.\n */\nexport function useLayer(type: string) {\n  const { openLayer, closeLayer, layers } = useContext(LayersContext)\n\n  /**\n   * Call this method to open a layer that contains the Component at the given\n   * layer type.\n   *\n   * Opening a layer of this type will close any other layers of this type.\n   * For example, if a `tooltip` layer was currently open, opening a new\n   * tooltip would close the previously open one.\n   *\n   * When opening a layer, we pass in a function (that takes no arguments) and\n   * returns our rendered Component something like:\n   *\n   * ```ts\n   * const dialog = useLayer('dialog')\n   *\n   * const openDialog = () => {\n   *   dialog.open(() => <MyDialog title=\"My Title\" />)\n   * }\n   * ```\n   *\n   * If you are getting TypeScript issues, especially when passing props as\n   * properties of some other object, the easiest way to fix these issues are\n   * to assign those values to a `const` first. This can happen when the\n   * values on the object could potentially be `undefined` or change during\n   * a re-render.\n   *\n   * For example, this could give typing issues:\n   *\n   * ```ts\n   * type Item = {\n   *   title?: string\n   * }\n   *\n   * const dialog = useLayer('dialog')\n   *\n   * const openDialog = () => {\n   *   if (item.title === undefined) return\n   *   dialog.open(() => <MyDialog title={item.title} />)\n   * }\n   * ```\n   *\n   * It's a little non-obvious because it looks like we did a check to make\n   * sure that `item.title` is defined. But remember that it could change\n   * during a re-render.\n   *\n   * Here's how to fix this.\n   *\n   * ```ts\n   * type Item = {\n   *   title?: string\n   * }\n   *\n   * const dialog = useLayer('dialog')\n   *\n   * const openDialog = () => {\n   *   if (item.title === undefined) return\n   *   const title = item.title\n   *   dialog.open(() => <MyDialog title={title} />)\n   * }\n   * ```\n   *\n   * Now `title` is of type `string` because we already asserted that\n   * `item.title` was a string. We assigned it to a `const` meaning that it\n   * won't change, even if re-rendered later.\n   */\n  function open(Component: FunctionComponent<Record<string, never>>) {\n    const layer: Layer = { type, Component }\n    openLayer(layer)\n  }\n\n  /**\n   * Call this method to close the current layer of the given layer type.\n   */\n  function close() {\n    closeLayer(type)\n  }\n\n  return {\n    open,\n    close,\n    layer: layers[type],\n    type,\n  }\n}\n","import styled from \"@emotion/styled\"\n\nexport const $Anchor = styled(\"a\")`\n  /**\n   * Link colors\n   */\n  color: var(--link-color, blue);\n  &:hover {\n    color: var(--link-hover-color, blue);\n  }\n  /**\n   * When the cursor is in the anchor and not outside the anchor, we style the\n   * anchor with a very light shade. This is enough to subtly intuit to the user\n   * that when they type, it will appear inside the link. When the shade is\n   * not present, they intuit they are just outside the link.\n   */\n  border-radius: 0.125em;\n  transition: background-color 250ms;\n  &.--selected {\n    background: var(--blue-50);\n  }\n`\n/**\n * This edge piece that are at the edge of the inside of the anchor are visibly\n * designed to be 1px wide. A <span> can't be given a width so we fake this by\n * creating an empty span with 1px of width.\n */\nexport const $Edge = styled(\"span\")`\n  display: inline;\n  padding: 0 1px 0 0;\n`\n\n/**\n * Shows progress bar of an uploading attachment. This part is the outline.\n */\nexport const $ProgressBar = styled(\"span\")`\n  position: fixed;\n  width: 100px;\n  background: var(--shade-50);\n  height: 8px;\n  border-radius: 7px;\n  border: 1px solid var(--shade-400);\n  overflow: hidden;\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n`\n\n/**\n * Show the fill part of the progress bar.\n */\nexport const $ProgressBarFill = styled(\"span\")`\n  position: absolute;\n  left: 0;\n  top: 0;\n  height: 14px;\n  background: var(--blue-400);\n  transition: width 100ms linear;\n`\n","import styled from \"@emotion/styled\"\nimport { useCallback } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { $Panel } from \"../../shared-overlays\"\nimport { useLayer } from \"../../use-layer\"\nimport { useAbsoluteReposition } from \"../../use-reposition\"\nimport { useTooltip } from \"../../use-tooltip\"\nimport { AnchorElement } from \"../index\"\nimport { AnchorEditDialog } from \"./AnchorEditDialog\"\nimport { ExternalLinkIcon, LinkOffIcon, PencilIcon } from \"./icons\"\n\nconst $AnchorDialog = styled($Panel)`\n  position: absolute;\n  display: flex;\n  width: 20em;\n  z-index: 10;\n  padding: 1em;\n  color: var(--shade-400);\n\n  .--icons {\n    display: flex;\n    overflow: hidden;\n    flex: 0 0 6em;\n  }\n\n  .--link {\n    text-decoration: none;\n    display: flex;\n    flex: 0 0 14em;\n    overflow: hidden;\n    color: var(--shade-400);\n    &:hover {\n      color: var(--blue-600);\n    }\n    transition: all 200ms;\n  }\n\n  .--url {\n    margin-left: 0.5em;\n    .--hostname {\n      font-size: 0.875em;\n      width: 14em;\n      line-height: 1.5em;\n      color: var(--blue-600);\n      overflow-wrap: break-word;\n      /* width: 13.5em;\n      white-space: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis; */\n    }\n    .--pathname {\n      margin-top: 0.125em;\n      font-size: 0.75em;\n      width: 16.25em;\n      line-height: 1.5em;\n      overflow-wrap: break-word;\n    }\n    .--tooltip {\n      box-sizing: border-box;\n      position: relative;\n      margin-top: 1em;\n      font-size: 0.875em;\n      width: 14em;\n      line-height: 1.5em;\n      background: var(--shade-200);\n      border-radius: 0.5em;\n      padding: 0.5em 0.75em;\n      color: var(--shade-600);\n      overflow-wrap: break-word;\n    }\n    .--tooltip::before {\n      content: \"\";\n      position: absolute;\n      top: -0.5em; /* Height of the triangle */\n      left: 0.5em; /* Position it on the left side */\n      border-left: 0.5em solid transparent; /* Half the width of the triangle */\n      border-right: 0.5em solid transparent; /* Half the width of the triangle */\n      border-bottom: 0.5em solid var(--shade-200); /* Height and color of the triangle */\n    }\n  }\n\n  .--icon {\n    cursor: pointer;\n    margin-left: 0.5em;\n    &:hover {\n      color: var(--blue-600);\n    }\n  }\n\n  svg {\n    flex: 0 0 auto;\n    width: 1.25em;\n    height: 1.25em;\n    stroke-width: 1.5;\n  }\n`\n\nfunction parseUrl(s: string): { hostname: string; pathname: string } {\n  try {\n    const url = new URL(s)\n    return { hostname: url.hostname, pathname: url.pathname }\n  } catch (e) {\n    return { hostname: \"\", pathname: \"\" }\n  }\n}\n\nexport function AnchorDialog({\n  destAnchor,\n  destStartEdge,\n  element,\n}: {\n  destAnchor: HTMLAnchorElement\n  destStartEdge: HTMLSpanElement\n  element: AnchorElement\n}) {\n  const dialog = useLayer(\"dialog\")\n  const editor = useSlateStatic()\n  const url = parseUrl(element.href)\n  const style = useAbsoluteReposition(\n    { destAnchor, destStartEdge },\n    ({ destAnchor, destStartEdge }) => {\n      return {\n        left: destStartEdge.left,\n        top: destAnchor.top + destAnchor.height,\n      }\n    }\n  )\n\n  const removeTooltip = useTooltip({ title: \"Remove link\" })\n  const editTooltip = useTooltip({ title: \"Edit link\" })\n\n  const removeLink = useCallback(() => {\n    editor.anchor.removeLink({ at: element })\n  }, [editor])\n\n  const openEditDialog = useCallback(() => {\n    /**\n     * Force close the tooltip otherwise it will stay open because the\n     * `onMouseLeave` never gets called. Technically, the mouse never leaves\n     * the icon through a mouse movement. The edit icon simply disappears.\n     */\n    editTooltip.onMouseLeave()\n    dialog.open(() => {\n      return (\n        <AnchorEditDialog\n          destAnchor={destAnchor}\n          destStartEdge={destStartEdge}\n          element={element}\n        />\n      )\n    })\n  }, [destAnchor, destStartEdge, element])\n\n  return (\n    <$AnchorDialog contentEditable={false} style={style}>\n      <a\n        className=\"--link\"\n        href={element.href}\n        target=\"_blank\"\n        rel=\"noreferrer\"\n      >\n        <ExternalLinkIcon />\n        <div className=\"--url\">\n          <div className=\"--hostname\">{url.hostname}</div>\n          {url.pathname === \"\" || url.pathname === \"/\" ? null : (\n            <div className=\"--pathname\">{url.pathname}</div>\n          )}\n          {element.title == null || element.title === \"\" ? null : (\n            <div className=\"--tooltip\">{element.title}</div>\n          )}\n        </div>\n      </a>\n      <span className=\"--icons\">\n        <span\n          className=\"--icon\"\n          onClick={removeLink}\n          onMouseEnter={removeTooltip.onMouseEnter}\n          onMouseLeave={removeTooltip.onMouseLeave}\n        >\n          <LinkOffIcon />\n        </span>\n        <span\n          className=\"--icon\"\n          onMouseEnter={editTooltip.onMouseEnter}\n          onMouseLeave={editTooltip.onMouseLeave}\n          onClick={openEditDialog}\n        >\n          <PencilIcon />\n        </span>\n      </span>\n    </$AnchorDialog>\n  )\n}\n","export * from \"./components\"\nexport * from \"./styles\"\nexport * from \"./types\"\n","export * from \"./CloseMask\"\nexport * from \"./Menu\"\n","import React, { useRef } from \"react\"\n\nimport { $CloseMask } from \"../../styles/$CloseMask\"\n\n/**\n * Add this `CloseMask` before the Component you want this `CloseMask` to be\n * the background for.\n *\n * When users click on the `CloseMask`, it will close the layer.\n */\nexport function CloseMask({ close }: { close: () => void }) {\n  const ref = useRef<HTMLDivElement>(null)\n  return <$CloseMask ref={ref} onClick={close} />\n}\n","import styled from \"@emotion/styled\"\n\nexport const $CloseMask = styled(\"div\")`\n  position: fixed;\n  user-select: none;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow-y: auto;\n  background: rgba(0, 0, 0, 0.01);\n`\n","export * from \"./formatHotkey\"\nexport * from \"./Menu\"\nexport * from \"./MenuItem\"\n\n/**\n * Menu is shared between different components like:\n *\n * - toolbar\n * - table dialogs\n */\n","import { isMac } from \"~/src/sink\"\n\n/**\n * Character Reference\n *\n * Ctrl+P Ctrl+Shift+P Ctrl+Alt+P\n * ⌘P ⇧⌘P ⌥⌘P\n */\n\nexport const key = {\n  cmd: \"\\u2318\",\n  ctrl: \"\\u2303\",\n  shift: \"⇧\",\n  opt: \"⌥\",\n  enter: \"⏎\",\n}\n\nconst MAC_KEYS = {\n  shift: key.shift,\n  opt: key.opt,\n  alt: key.opt,\n  ctrl: key.ctrl,\n  mod: key.cmd,\n  cmd: key.cmd,\n  enter: key.enter,\n  super: `${key.opt}${key.cmd}`,\n}\n\nconst PC_KEYS = {\n  alt: \"ALT\",\n  ctrl: \"CTRL\",\n  opt: \"ALT\",\n  shift: \"SHIFT\",\n  mod: \"CTRL\",\n  cmd: \"CTRL\",\n  enter: key.enter,\n  super: \"CTRL+SHIFT\",\n}\n\nfunction pull<T>(arr: T[], value: T): void {\n  const index: number = arr.findIndex((el: T) => el === value)\n  if (index !== -1) {\n    arr.splice(index, 1)\n  }\n}\n\nfunction formatMac(segments: string[]) {\n  const result = []\n  Object.entries(MAC_KEYS).forEach(([key, symbol]) => {\n    if (segments.includes(key)) {\n      result.push(symbol)\n      pull(segments, key)\n    }\n  })\n  result.push(...segments.map((s) => s.toUpperCase()))\n  return result.join(\"\")\n}\n\nfunction formatPC(segments: string[]) {\n  const result = []\n  Object.entries(PC_KEYS).forEach(([key, symbol]) => {\n    if (segments.includes(key)) {\n      result.push(symbol)\n      pull(segments, key)\n    }\n  })\n  result.push(...segments.map((s) => s.toUpperCase()))\n  return result.join(\"+\")\n}\n\nexport function formatHotkey(shortcut: string) {\n  const segments = shortcut.toLowerCase().split(\"+\")\n  if (isMac()) {\n    return formatMac(segments)\n  } else {\n    return formatPC(segments)\n  }\n}\n","import { useRef } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { useAbsoluteReposition } from \"~/src/use-reposition\"\n\nimport { $Menu, $MenuDivider } from \"../../../toolbar-plugin/styles\"\nimport { MenuItemData } from \"../../types\"\nimport { CloseMask } from \"../CloseMask\"\nimport { MenuItem } from \"./MenuItem\"\n\nexport function Menu({\n  dest,\n  items,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n  items: MenuItemData[]\n}) {\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const style = useAbsoluteReposition({ src: ref, dest }, ({ dest }) => {\n    return { left: dest.left - 8, top: dest.top + dest.height }\n  })\n\n  return (\n    <>\n      <CloseMask close={close} />\n      <$Menu ref={ref} style={style}>\n        {items.map((item, index) => {\n          if (item === \"divider\") {\n            return <$MenuDivider key={index} />\n          } else {\n            return (\n              <MenuItem\n                key={index}\n                editor={editor}\n                item={item}\n                close={close}\n                dest={dest}\n              />\n            )\n          }\n        })}\n      </$Menu>\n    </>\n  )\n}\n","export * from \"./hooks/use-absolute-reposition\"\nexport * from \"./hooks/use-fixed-reposition\"\nexport * from \"./hooks/use-reposition\"\nexport * from \"./hooks/use-throttled-refresh\"\nexport * from \"./position-methods\"\n","import { RefObject } from \"react\"\n\nimport { getAbsoluteRect } from \"../get-methods/get-absolute-rect\"\nimport { getAbsoluteViewport } from \"../get-methods/get-absolute-viewport\"\nimport { MapHTMLElementLikeRecordToRectRecord, Rect } from \"../types\"\nimport { mapHTMLElementLikeRecordToRectRecord } from \"../utils\"\nimport { useReposition } from \"./use-reposition\"\n\n/**\n * For `absolute` positioning.\n *\n * For `fixed` positioning see `useFixedReposition`\n *\n * An all-in-one hook that helps you position elements relative to other\n * elements and to the viewport.\n *\n * It automatically refreshes when the user scrolls or the window is resized.\n *\n * The method takes as its first argument an object where the values can be\n * either an `HTMLElement` or a ref to an `HTMLElement` created using\n * `useRef(null)`.\n *\n * As the second argument, it takes a function that you use to process\n * everything and return a value you can use to position the element. It's\n * typical to return this in the form of a `style` Object but it doesn't have\n * to be.\n *\n * That function you pass in can take these arguments:\n *\n * - The first argument is in the same shape as the object of `HTMLElement` or\n *   `ref` to `HTMLElement`; however, instead, its values are `Rect` or\n *   if the original value was a `ref`, a `Rect | null`. The value can be\n *   `null` because a `ref` can potentially contain no value and hence we can't\n *   find a `Rect` for it.\n * - The second argument is a `Rect` representing the viewport of the `window`.\n * - The third argument is a `refresh` method you can call to force a\n *   refresh. The refresh is throttled in sync with the ot\n */\nexport function useAbsoluteReposition<\n  T extends Record<string, HTMLElement | RefObject<HTMLElement>>,\n  NV\n>(\n  elementLikeRecord: T,\n  fn: (\n    elementRecord: MapHTMLElementLikeRecordToRectRecord<T>,\n    viewport: Rect,\n    refresh: () => void\n  ) => NV\n) {\n  const refresh = useReposition()\n  const rectRecord = mapHTMLElementLikeRecordToRectRecord(\n    elementLikeRecord,\n    (element) => getAbsoluteRect(element)\n  )\n  return fn(rectRecord, getAbsoluteViewport(), refresh)\n}\n","import { Rect } from \"../types\"\nimport { getFixedRect } from \"./get-fixed-rect\"\n\n/**\n * Returns a `Rect` representing the `absolute` positioning coordinates of\n * the `HTMLElement`\n *\n * NOTE: we add `window.scrollY` to get the `absolute` position.\n */\nexport function getAbsoluteRect(domElement: HTMLElement): Rect {\n  const rect = getFixedRect(domElement)\n  const { scrollY } = window\n  return Object.assign(rect, {\n    top: rect.top + scrollY,\n    bottom: rect.bottom + scrollY,\n  })\n}\n","import { Rect } from \"../types\"\n\n/**\n * Returns a `Rect` representing the `fixed` positioning coordinates of\n * the `HTMLElement`\n */\nexport function getFixedRect(domElement: HTMLElement): Rect {\n  const bounds = domElement.getBoundingClientRect()\n  return {\n    top: bounds.top,\n    right: bounds.right,\n    bottom: bounds.bottom,\n    left: bounds.left,\n    width: bounds.width,\n    height: bounds.height,\n  }\n}\n","import { Rect } from \"../types\"\nimport { getFixedViewport } from \"./get-fixed-viewport\"\n\n/**\n * Returns a `Rect` representing the `absolute` positioning coordinates of\n * the window viewport.\n *\n * NOTE: we add `window.scrollY` to get the `absolute` position.\n */\nexport function getAbsoluteViewport(): Rect {\n  const rect = getFixedViewport()\n  return Object.assign(rect, {\n    top: window.scrollY,\n    bottom: window.scrollY + rect.height,\n  })\n}\n","import { Rect } from \"../types\"\n\n/**\n * Returns a `Rect` representing the `fixed` positioning coordinates of\n * the window viewport.\n */\nexport function getFixedViewport(): Rect {\n  /**\n   * Get the width of the viewport not including the scrollbar\n   *\n   * https://stackoverflow.com/a/25298418\n   */\n  const width =\n    document.documentElement.clientWidth || document.body.clientWidth\n  return {\n    top: 0,\n    right: width,\n    bottom: window.innerHeight,\n    left: 0,\n    width: width,\n    height: window.innerHeight,\n  }\n}\n","import mapValues from \"just-map-values\"\nimport { RefObject } from \"react\"\n\nimport { MapHTMLElementLikeRecordToRectRecord, Rect } from \"./types\"\n\n/**\n * Tries to convert an `HTMLElement` to a `Rect` using the supplied\n * `convertElementToRect` method.\n *\n * The input Record can have as its values either an `HTMLElement` or a\n * `RefObject<HTMLElement>`. When it is a `RefObject` then it may or may not\n * refer to an `HTMLElement` so...\n *\n * - If the value is an `HTMLElement` we convert it to a `Rect`\n * - If the value is a `RefObject<HTMLElement>` we convert it to a\n *   `Rect | null` depending on whether the `RefObject` contains the\n *   `HTMLElement`.\n */\nexport function mapHTMLElementLikeRecordToRectRecord<\n  T extends Record<string, HTMLElement | RefObject<HTMLElement>>\n>(\n  elementLikeRecord: T,\n  converElementToRect: (element: HTMLElement) => Rect\n): MapHTMLElementLikeRecordToRectRecord<T> {\n  const rectRecord = mapValues(elementLikeRecord, (value) => {\n    const maybeHTMLElement =\n      value instanceof HTMLElement ? value : value.current\n    const nextValue = maybeHTMLElement\n      ? converElementToRect(maybeHTMLElement)\n      : null\n    return nextValue\n  }) as MapHTMLElementLikeRecordToRectRecord<T>\n  return rectRecord\n}\n","import { useEffect } from \"react\"\n\nimport {\n  useThrottledRefresh,\n  UseThrottledRefreshReturnType,\n} from \"./use-throttled-refresh\"\n\n/**\n * Refreshes the Component whenever the page is resized or the window is\n * scrolled. This is because these are usually the only two events that cause\n * the elements on a page to be repositioned.\n *\n * If there are yet other events that can cause the elements to be repositioned\n * or resized, you can also call the returned `refresh` method. This will\n * update the components while still respected the fact that the updates will\n * be throttled so as not to overload the browser.\n */\nexport function useReposition(): UseThrottledRefreshReturnType {\n  /**\n   * Create a throttled `refresh` method.\n   */\n  const refresh = useThrottledRefresh()\n\n  /**\n   * refresh on page resize or scroll (throttled)\n   */\n  useEffect(() => {\n    refresh()\n    window.addEventListener(\"resize\", refresh)\n    window.addEventListener(\"scroll\", refresh)\n    return () => {\n      window.removeEventListener(\"resize\", refresh)\n      window.removeEventListener(\"scroll\", refresh)\n    }\n  }, [])\n\n  return refresh\n}\n","/**\n * NOTE:\n *\n * We have a preference for `just` packages like `just-throttle` since they\n * tend to be micro, but `just-throttle` has a bug. It does not execute\n * on the trailing edge even when told to do so.\n *\n * We ran a test where we logged the call to `refresh` and when the refresh was\n * executed and there were leftover `refresh` calls without a trailing\n * execution.\n */\nimport throttle from \"lodash.throttle\"\nimport { useState } from \"react\"\n\nexport type UseThrottledRefreshReturnType = ReturnType<typeof throttle> & {\n  counter: number\n}\n\n/**\n * Creates a hook that rerenders a component when the returned `refresh`\n * method is called; however, it throttles the refresh based on the\n * `intervalInMs` argument passed in.\n *\n * This is a useful component used when throttling reposition updates.\n */\nexport function useThrottledRefresh(\n  intervalInMs = 100\n): UseThrottledRefreshReturnType {\n  const [counter, setState] = useState(0)\n\n  const refresh = throttle(\n    () => {\n      setState((counter) => counter + 1)\n    },\n    intervalInMs,\n    { trailing: true }\n  )\n\n  return Object.assign(refresh, { counter })\n}\n","import { RefObject } from \"react\"\n\nimport { getFixedRect } from \"../get-methods/get-fixed-rect\"\nimport { getFixedViewport } from \"../get-methods/get-fixed-viewport\"\nimport { MapHTMLElementLikeRecordToRectRecord, Rect } from \"../types\"\nimport { mapHTMLElementLikeRecordToRectRecord } from \"../utils\"\nimport { useReposition } from \"./use-reposition\"\n\n/**\n * For `fixed` positioning.\n *\n * For `absolute` positioning see `useAbsoluteReposition`\n *\n * An all-in-one hook that helps you position elements relative to other\n * elements and to the viewport.\n *\n * It automatically refreshes when the user scrolls or the window is resized.\n *\n * The method takes as its first argument an object where the values can be\n * either an `HTMLElement` or a ref to an `HTMLElement` created using\n * `useRef(null)`.\n *\n * As the second argument, it takes a function that you use to process\n * everything and return a value you can use to position the element. It's\n * typical to return this in the form of a `style` Object but it doesn't have\n * to be.\n *\n * That function you pass in can take these arguments:\n *\n * - The first argument is in the same shape as the object of `HTMLElement` or\n *   `ref` to `HTMLElement`; however, instead, its values are `Rect` or\n *   if the original value was a `ref`, a `Rect | null`. The value can be\n *   `null` because a `ref` can potentially contain no value and hence we can't\n *   find a `Rect` for it.\n * - The second argument is a `Rect` representing the viewport of the `window`.\n * - The third argument is a `refresh` method you can call to force a\n *   refresh. The refresh is throttled in sync with the ot\n */\nexport function useFixedReposition<\n  T extends Record<string, HTMLElement | RefObject<HTMLElement>>,\n  R\n>(\n  elementLikeRecord: T,\n  fn: (\n    elementRecord: MapHTMLElementLikeRecordToRectRecord<T>,\n    viewport: Rect,\n    refresh: () => void\n  ) => R\n) {\n  const refresh = useReposition()\n  const rectRecord = mapHTMLElementLikeRecordToRectRecord(\n    elementLikeRecord,\n    (element) => getFixedRect(element)\n  )\n  return fn(rectRecord, getFixedViewport(), refresh)\n}\n","import { Rect } from \"../types\"\n\n/**\n * Takes a source Rect of the Element you are trying to position and makes\n * sure it is inside the container Rect.\n *\n * The source Rect can be `null` (e.g. when the `ref` hasn't been set yet) and\n * while it is, the item is positioned far off to the left of the screen.\n *\n * Can specify an optional `margin` as well.\n */\nexport function positionInside(\n  src: Rect | null,\n  container: Rect,\n  pos: { left: number; top: number },\n  { margin = 0 }: { margin?: number } = {}\n) {\n  if (src == null) return { ...pos, left: -1024 }\n  const right = pos.left + src.width\n  if (right <= container.right - margin) return pos\n  return { ...pos, left: container.right - src.width - margin }\n}\n","export * from \"./anchor-dialog-styles\"\nexport * from \"./layout-styles\"\nexport * from \"./menu-styles\"\nexport * from \"./toolbar-styles\"\n","import styled from \"@emotion/styled\"\n\nimport { $Panel } from \"../../shared-overlays/styles/$Panel\"\n\nexport const $AnchorDialog = styled($Panel)`\n  padding: 1em;\n  width: 24em;\n`\nexport const $AnchorDialogInputLine = styled(\"div\")`\n  display: flex;\n  gap: 0.5em;\n`\n\nexport const $AnchorDialogInput = styled(\"input\")`\n  flex: 1 1 auto;\n  padding: 0.5em 0.75em;\n  border-radius: 0.25em;\n  color: var(--shade-700);\n  border: 1px solid var(--shade-300);\n  font-size: 0.9375em;\n  &:focus {\n    outline: 2px solid var(--blue-200);\n  }\n`\n","import styled from \"@emotion/styled\"\n\nimport { SinkReset } from \"~/src/sink/editable\"\n\n/**\n * $Panel is a nice box that goes around a Drop Down menu or a Dialog Box.\n *\n * We don't use $Panel directly and instead we extend it.\n *\n * The $Panel itself extends the `SinkReset` and we do this because the\n * Component appears at the root. So any styling, for example like from\n * Bootstrap or Material UI will affect what's in the Panel.\n */\nexport const $Panel = styled(SinkReset)`\n  position: absolute;\n  z-index: 1000;\n  border: 1px solid var(--table-border-color);\n  border-radius: 0.5em;\n  overflow: clip;\n  filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07))\n    drop-shadow(0 2px 2px rgb(0 0 0 / 0.06));\n  background: white;\n  /**\n   * If you are tempted to add the transitions back in, here's why we left\n   * them off:\n   *\n   * - When we initially unhide the panel (by setting a negative 'left' pos)\n   *   the panel slides in very quickly. So we'd need to fix this first which\n   *   adds complexity.\n   *\n   * - Even if we fixed it, the browser window updates the scrolls and resizes\n   *   in a stepped manner (i.e. like frames in an animation). Keeping the\n   *   smooth animations makes the panel step in sync with the page refreshes\n   *   and so actually looks better.\n   *\n   * In other words, there's a technical issue we'd still need to solve but\n   * even if we did, it looks better this way.\n   */\n  /* transition: left 100ms, top 100ms; */\n`\n","import styled from \"@emotion/styled\"\n\nimport { $Container } from \"../../shared-layout\"\n\nexport const $Editable = styled(\"div\")`\n  padding: 2em;\n`\n\nexport const $OuterContainer = styled($Container)`\n  /**\n   * We use this to make sure the top of the container is rounded even though\n   * the toolbar inside is square. We keep the toolbar square so that as the\n   * toolbar hits the top when scrolling, it can become sticky. We can try to\n   * round the toolbar, but it causes an issue where the part under the\n   * rounded part is still visible (i.e. the edge of the container). We can\n   * then try to put an absolutely positioned background on it with an opaque\n   * color, but that doesn't work unless we know the color of the background\n   * so... ultimately, it's not a good solution.\n   *\n   * NOTE:\n   *\n   * Using \"overflow: hidden;\" will break the \"position: sticky;\" and it will\n   * not work. \"overflow: clip;\" does work though.\n   *\n   * https://stackoverflow.com/a/73051006\n   */\n  overflow-y: clip;\n  display: flex;\n  flex-direction: column;\n`\n","import styled from \"@emotion/styled\"\n\nimport { SinkReset } from \"../sink/editable\"\n\n/**\n * NOTE:\n *\n * This $Container should be extended and the following should be\n * added to it:\n *\n * - padding: We add this separately because if there is a toolbar, there\n *   should be no padding on the container but there should be\n *   padding on the actual editable. If it is the basic layout, we can add\n *   the padding on the $Container but also use the $Container styling\n *   directly on the Editable Component.\n */\nexport const $Container = styled(SinkReset)`\n  border: 1px solid var(--shade-300); /* shade-300 */\n  border-radius: 0.5em;\n  color: rgb(39 39 42); /* shade-800 */\n  line-height: 1.5;\n  /**\n   * !important is required because of role=\"textbox\" I think\n   */\n  outline: 2px solid transparent !important;\n  transition: all 250ms;\n  &.--focused {\n    /**\n     * !important is required because of role=\"textbox\" I think\n     */\n    outline: 2px solid var(--select-editor-color) !important;\n  }\n`\n","import styled from \"@emotion/styled\"\n\nimport { $Panel } from \"../../shared-overlays/styles/$Panel\"\n\n/**\n * Drop Down Menu\n */\nexport const $Menu = styled($Panel)`\n  position: absolute;\n  padding-top: 0.5em;\n  padding-bottom: 0.5em;\n  transition: all 200ms;\n  /**\n   * Prevent clicks from stealing focus from the editor\n   */\n  user-select: none;\n`\n\n/**\n * Individual items in Drop Down Menu\n */\nexport const $MenuItem = styled(\"div\")`\n  display: flex;\n  z-index: 10;\n  padding: 0 1em 0 1.5em;\n  height: 2em;\n  align-items: center;\n  /**\n   * Normally we don't do it this way but since each part of the MenuItem\n   * is tightly related to the display: flex, this seemed the easiest way\n   * to set this up.\n   */\n  .--icon {\n    flex: 0 0;\n    display: block;\n    font-size: 1.25em;\n    height: 1em;\n    padding-right: 0.75em;\n    color: var(--shade-400);\n    svg {\n      position: relative;\n      stroke-width: 1.5px;\n    }\n  }\n  .--title {\n    flex: 1 0;\n    font-size: 0.875em;\n    color: var(--shade-800);\n  }\n  .--hotkey {\n    flex: 0 0;\n    font-size: 0.75em;\n    padding-left: 1.5em;\n    color: var(--shade-500);\n  }\n  background: white;\n  cursor: pointer;\n  &:hover {\n    background: var(--blue-50);\n  }\n`\n\nexport const $MenuDivider = styled(\"div\")`\n  height: 1px;\n  background: var(--shade-200);\n  margin-top: 0.25em;\n  margin-bottom: 0.25em;\n`\n","import styled from \"@emotion/styled\"\n\nexport const $ToolbarContainer = styled(\"div\")`\n  /**\n   * This flex rule applies to the \"display: flex;\" of the parent container.\n   * Ensures the toolbar does not shrink or grow vertically.\n   */\n  flex: 0 0 auto;\n  /**\n   * If \"position: sticky;\" is not working, check the ancestor for \"overflow:\n   * hidden;\" of any kind. This will stop sticky from working. A good workaround\n   * is to use \"overflow: clip;\" instead.\n   *\n   * https://stackoverflow.com/a/73051006\n   */\n  position: sticky;\n  top: 0;\n  z-index: 2;\n  background: var(--shade-50);\n  /* font-size: 0.875em; */\n  font-size: 0.9375em;\n  padding: 0 0.5em;\n  border-bottom: 1px solid var(--shade-300);\n  /**\n   * Prevent clicks from stealing focus from the editor\n   */\n  user-select: none;\n  /**\n   * Extreme attention to detail. When the sticky is ending and the toolbar\n   * is stuck to the bottom of the editor, setting margin-bottom to -1px will\n   * fix the 2px bottom border and make it the proper 1px.\n   */\n  margin-bottom: -1px;\n\n  /**\n   * NOTE: The space in the equation is significant\n   */\n  height: calc(\n    3em + 1px\n  ); // $ToolbarDivider height + border-bottom of 1px above\n  overflow: hidden;\n`\n\nexport const $Toolbar = styled(\"div\")`\n  display: inline-block;\n  height: calc(\n    3em + 1px\n  ); // $ToolbarDivider height + border-bottom of 1px above\n`\n\nexport const $ToolbarDividerContainer = styled(\"div\")`\n  display: inline-block;\n  height: 3em;\n  padding: 0 0.375em;\n`\n\nexport const $ToolbarDivider = styled(\"div\")`\n  display: inline-block;\n  background: var(--shade-300);\n  opacity: 50%;\n  width: 1px;\n  height: 3em;\n`\n\nexport const $ToolbarButton = styled(\"div\")`\n  box-sizing: border-box;\n  position: relative;\n  display: inline-block;\n  vertical-align: top;\n  font-size: 1.25em;\n  margin-top: 0.25em;\n  height: 2em;\n  padding: 0.375em 0.375em;\n  border-radius: 0.25em;\n  text-align: center;\n  color: var(--shade-500);\n  transition: all 100ms;\n  cursor: pointer;\n  border: 1px solid rgba(0, 0, 0, 0);\n  &.--active {\n    color: var(--shade-700);\n    background: rgba(0, 0, 0, 0.05);\n    svg {\n      /* stroke-width: 2px; */\n    }\n  }\n  svg {\n    stroke-width: 1.5px;\n  }\n  &:hover {\n    color: var(--shade-700);\n    background: var(--blue-100);\n    svg {\n      /* stroke-width: 2px; */\n    }\n  }\n\n  &.--more {\n    padding: 0.375em 0.5em;\n  }\n  .--more-icon {\n    position: absolute;\n    bottom: -0.2em;\n    left: 50%;\n    margin-left: -0.25em;\n    opacity: 0.375;\n  }\n`\n","import { useCallback } from \"react\"\nimport { Editor } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { $MenuItem } from \"../../../toolbar-plugin/styles\"\nimport { useLayer } from \"../../../use-layer\"\nimport { MenuItemData } from \"../../types\"\nimport { formatHotkey } from \"./formatHotkey\"\n\nexport function MenuItem({\n  editor,\n  item,\n  close,\n  dest,\n}: {\n  editor: Editor\n  item: Exclude<MenuItemData, \"divider\">\n  close: () => void\n  dest: HTMLElement\n}) {\n  const menuLayer = useLayer(\"menu\")\n\n  const onClick = useCallback(() => {\n    if (item.Component) {\n      const Component = item.Component\n      menuLayer.open(() => <Component dest={dest} close={menuLayer.close} />)\n    } else if (item.action) {\n      item.action(editor)\n      ReactEditor.focus(editor)\n      close()\n    }\n  }, [editor, item])\n  return (\n    <>\n      <$MenuItem onClick={onClick}>\n        <div className=\"--icon\">\n          <item.icon />\n        </div>\n        <div className=\"--title\">{item.title}</div>\n        <div className=\"--hotkey\">\n          {item.hotkey ? formatHotkey(item.hotkey) : undefined}\n        </div>\n      </$MenuItem>\n    </>\n  )\n}\n","export * from \"./$CloseMask\"\nexport * from \"./$Panel\"\n","import { FunctionComponent } from \"react\"\nimport { Editor } from \"slate\"\n\n/**\n * Data for a menu item.\n *\n * Can't be named `MenuItem` because it conflicts with the component.\n */\nexport type MenuItemData =\n  | {\n      /**\n       * Icon to show as a part of the button.\n       */\n      icon: React.FunctionComponent\n      /**\n       * Title to show as a part of the tooltip.\n       */\n      title: string\n      /**\n       * Hotkey to show as a part of the toolip.\n       * This does not create the actual hotkey.\n       */\n      hotkey?: string\n      /**\n       * Method to execute when the button is clicked\n       */\n      action?: (editor: Editor) => void\n      /**\n       * If the button should be shown or not. If the argument is not provided,\n       * the button will be shown.\n       *\n       * NOTE: This only works in top-level items at the moment.\n       */\n      show?: (editor: Editor) => boolean\n      /**\n       * If `true`, the button will display as downward create next to it to\n       * indicate that clicking it will display some more options.\n       * Typically this value is set to true when it has `children` or a\n       * `Component` prop; however, we allow it to be set manually.\n       */\n      more?: boolean\n      children?: MenuItemData[]\n      Component?: FunctionComponent<{ dest: HTMLElement; close: () => void }>\n    }\n  | \"divider\"\n","import { MouseEvent, useCallback } from \"react\"\n\nimport { useLayer } from \"~/src/use-layer\"\n\nimport { Tooltip } from \"./tooltip\"\nimport { Triangle } from \"./triangle\"\n\n/**\n * Takes a title and a hotkey and renders it as a tooltip.\n *\n * You'll notice that hotkey can be a function and the reason is very specific\n * to our needs which is that we don't know what the hotkey should look like\n * until we are in the browser (i.e. not the server) because it checks the user\n * agent to see if we are on a Mac or on Windows.\n *\n * We can defer this request until the tooltip is displayed.\n *\n * The editor currently has no need to display this hotkey shortcuts except in\n * things like tooltips so this isn't a problem for us. Potentially, we may need\n * to figure out a way to render this on the server or figure out a way to\n * render on the server without the hotkey and then fill it in when we are in\n * the browser.\n *\n * If we ever fix this requirement that hotkeys can only be shown in the browser\n * (i.e. we get server side rendering of hotkeys working) then `useTooltip` can\n * be simplified to not take a function.\n */\nexport function useTooltip(\n  {\n    title,\n    hotkey,\n  }: {\n    title: string\n    hotkey?: string | (() => string | undefined)\n  },\n  deps: React.DependencyList = []\n) {\n  const label = useLayer(\"tooltip-label\")\n  const triangle = useLayer(\"tooltip-triangle\")\n\n  /**\n   * On hover over\n   */\n  const onMouseEnter = useCallback((e: MouseEvent<HTMLElement>) => {\n    const dest = e.currentTarget\n    /**\n     * Open tooltip\n     */\n    if (title !== undefined) {\n      label.open(() => (\n        <Tooltip\n          title={title}\n          hotkey={typeof hotkey === \"function\" ? hotkey() : hotkey}\n          dest={dest}\n        />\n      ))\n      triangle.open(() => <Triangle dest={dest} />)\n    }\n  }, deps)\n\n  /**\n   * On hover out\n   */\n  const onMouseLeave = useCallback(() => {\n    label.close()\n    triangle.close()\n  }, deps)\n  return { onMouseEnter, onMouseLeave }\n}\n","import styled from \"@emotion/styled\"\n\nexport function useRect(dest: HTMLElement): DOMRect {\n  return dest.getBoundingClientRect()\n}\n\nconst $Tooltip = styled(\"div\")`\n  position: fixed;\n  z-index: 10;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-size: 16px;\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n    Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n  color: white;\n  font-size: 0.875em;\n  line-height: 1.5em;\n  padding: 0 0.5em;\n  color: var(--shade-300);\n  background: var(--shade-700);\n  border-radius: 0.25em;\n  white-space: nowrap;\n`\n\nconst $Hotkey = styled(\"span\")`\n  margin-left: 0.75em;\n  font-size: 0.875em;\n  font-weight: 500;\n  color: var(--shade-400);\n`\n\nexport function Tooltip({\n  title,\n  hotkey,\n  dest,\n}: {\n  title: string\n  hotkey?: string\n  dest: HTMLElement\n}) {\n  const rect = useRect(dest)\n  return (\n    <$Tooltip\n      style={{\n        left: rect.left,\n        top: `calc(${rect.top}px - 2em)`,\n      }}\n    >\n      {title}\n\n      {hotkey ? <$Hotkey>{hotkey}</$Hotkey> : null}\n    </$Tooltip>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nimport { useRect } from \"./tooltip\"\n\nconst $Triangle = styled(\"span\")`\n  position: fixed;\n  z-index: 10;\n  width: 0;\n  height: 0;\n  border-left: 0.375em solid transparent;\n  border-right: 0.375em solid transparent;\n  border-top: 0.375em solid var(--shade-700);\n`\n\nexport function Triangle({ dest }: { dest: HTMLElement }) {\n  const rect = useRect(dest)\n  return (\n    <$Triangle\n      style={{\n        left: `calc(${rect.left + rect.width / 2}px - 0.375em)`,\n        top: `calc(${rect.top}px - 0.5em)`,\n      }}\n    />\n  )\n}\n","import styled from \"@emotion/styled\"\nimport { useCallback, useRef, useState } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { $Panel } from \"../../shared-overlays\"\nimport {\n  $CancelButton,\n  $FormCaption,\n  $FormGroup,\n  $FormHint,\n  $Input,\n  $PrimaryButton,\n  $Textarea,\n} from \"../../shared-styles\"\nimport { useLayer } from \"../../use-layer\"\nimport { useAbsoluteReposition } from \"../../use-reposition\"\nimport { AnchorElement } from \"../index\"\nimport { AnchorDialog } from \"./AnchorDialog\"\n\nconst $AnchorEditDialog = styled($Panel)`\n  position: absolute;\n  width: 20em;\n  padding: 1em;\n`\n\nexport function AnchorEditDialog({\n  destAnchor,\n  destStartEdge,\n  element,\n}: {\n  destAnchor: HTMLAnchorElement\n  destStartEdge: HTMLSpanElement\n  element: AnchorElement\n}) {\n  const dialog = useLayer(\"dialog\")\n  const style = useAbsoluteReposition(\n    { destAnchor, destStartEdge },\n    ({ destAnchor, destStartEdge }) => {\n      return {\n        left: destStartEdge.left,\n        top: destAnchor.top + destAnchor.height,\n      }\n    }\n  )\n\n  const editor = useSlateStatic()\n\n  const [href, setHref] = useState<string>(element.href)\n  const [title, setTitle] = useState<string>(element.title || \"\")\n\n  const formRef = useRef({ href, title })\n  formRef.current = { href, title }\n\n  const handleHrefChange = useCallback<\n    React.ChangeEventHandler<HTMLInputElement>\n  >((e) => {\n    setHref(e.target.value)\n  }, [])\n\n  const handleTitleChange = useCallback<\n    React.ChangeEventHandler<HTMLInputElement>\n  >((e) => {\n    setTitle(e.target.value)\n  }, [])\n\n  const openAnchorDialog = useCallback(() => {\n    dialog.open(() => (\n      <AnchorDialog\n        destAnchor={destAnchor}\n        destStartEdge={destStartEdge}\n        element={element}\n      />\n    ))\n  }, [destAnchor, destStartEdge, element])\n\n  const handleSubmit = useCallback(() => {\n    const { href, title } = formRef.current\n    editor.anchor.editLink({ href, title }, { at: element })\n    openAnchorDialog()\n  }, [openAnchorDialog])\n\n  return (\n    <$AnchorEditDialog contentEditable={false} style={style}>\n      <$FormGroup>\n        <$FormCaption>URL of link</$FormCaption>\n        <$Textarea as=\"textarea\" value={href} onChange={handleHrefChange} />\n      </$FormGroup>\n      <$FormGroup>\n        <$FormCaption>Tooltip text</$FormCaption>\n        <$Input type=\"text\" value={title} onChange={handleTitleChange} />\n        <$FormHint>Tooltip to display on mouse hover</$FormHint>\n      </$FormGroup>\n      <$FormGroup>\n        <$PrimaryButton onClick={handleSubmit}>Apply Edit</$PrimaryButton>\n      </$FormGroup>\n      <$FormGroup>\n        <$CancelButton onClick={openAnchorDialog}>Cancel</$CancelButton>\n      </$FormGroup>\n    </$AnchorEditDialog>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $FormGroup = styled(\"div\")`\n  margin: 0.5em 0;\n  &:first-of-type {\n    margin-top: 0;\n  }\n  &:last-of-type {\n    margin-bottom: 0;\n  }\n`\n\nexport const $FormCaption = styled(\"div\")`\n  font-size: 0.9375em;\n  margin-bottom: 0.25em;\n  color: var(--shade-700);\n`\n\nexport const $FormHint = styled(\"div\")`\n  font-size: 0.875em;\n  margin-top: 0.25em;\n  color: var(--shade-500);\n`\n\nexport const $Textarea = styled(\"input\")`\n  box-sizing: border-box;\n  width: 100%;\n  height: 6em;\n  padding: 0.5em 0.75em;\n  border-radius: 0.25em;\n  color: var(--shade-700);\n  font-family: inherit;\n  border: 1px solid var(--shade-300);\n  font-size: 0.9375em;\n  &:focus {\n    outline: 2px solid var(--blue-200);\n  }\n`\n\nexport const $Input = styled(\"input\")`\n  box-sizing: border-box;\n  width: 100%;\n  padding: 0.5em 0.75em;\n  border-radius: 0.25em;\n  color: var(--shade-700);\n  border: 1px solid var(--shade-300);\n  font-size: 0.9375em;\n  &:focus {\n    outline: 2px solid var(--blue-200);\n  }\n`\n\nexport const $BaseButton = styled(\"div\")`\n  /* Center vertically and horizontally */\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  padding: 0.25em 0.75em;\n  text-align: center;\n  transition: all 100ms;\n  border-radius: 0.25em;\n  svg {\n    font-size: 1.25em;\n    stroke-width: 2px;\n  }\n`\n\nexport const $PrimaryButton = styled($BaseButton)`\n  color: var(--blue-50);\n  background: var(--blue-500);\n  outline: 0px solid white;\n  &:hover {\n    color: white;\n    background: var(--blue-600);\n    outline: 2px solid var(--blue-200);\n  }\n  svg {\n    color: var(--blue-200);\n  }\n`\n\nexport const $CancelButton = styled($BaseButton)`\n  color: var(--shade-500);\n  background: var(--shade-200);\n  outline: 0px solid white;\n  &:hover {\n    color: var(--shade-600);\n    background: var(--shade-300);\n    outline: 2px solid var(--shade-200);\n  }\n  svg {\n    color: var(--shade-400);\n  }\n`\n","import { SVGProps } from \"react\"\n\nimport { TablerIcon } from \"~/src/sink\"\n\nexport const ExternalLinkIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <path d=\"M12 6H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6M11 13l9-9M15 4h5v5\" />\n  </TablerIcon>\n)\n\nexport const LinkOffIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <path d=\"m9 15 3-3m2-2 1-1M11 6l.463-.536a5 5 0 0 1 7.071 7.072L18 13M3 3l18 18M13 18l-.397.534a5.068 5.068 0 0 1-7.127 0 4.972 4.972 0 0 1 0-7.071L6 11\" />\n  </TablerIcon>\n)\n\nexport const PencilIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <path d=\"M4 20h4L18.5 9.5a1.5 1.5 0 0 0-4-4L4 16v4M13.5 6.5l4 4\" />\n  </TablerIcon>\n)\n","import { RefObject, useRef } from \"react\"\n\nimport { positionInside, useFixedReposition } from \"../../use-reposition\"\nimport { $ProgressBar, $ProgressBarFill } from \"../styles\"\n\nexport function ProgressBar({\n  anchorRef,\n  progress,\n}: {\n  // anchorRef: React.MutableRefObject<null>\n  anchorRef: RefObject<HTMLAnchorElement>\n  progress: number\n}) {\n  const progressRef = useRef(null)\n  const rect = useFixedReposition(\n    { anchor: anchorRef, progress: progressRef },\n    (rects, viewport) => {\n      if (rects.anchor == null || rects.progress == null) return { left: -1000 }\n      return positionInside(rects.progress, viewport, {\n        left: rects.anchor.left,\n        top: rects.anchor.top + rects.anchor.height + 4,\n      })\n    }\n  )\n  return (\n    <$ProgressBar ref={progressRef} style={rect}>\n      <$ProgressBarFill style={{ width: progress * 100 }} />\n    </$ProgressBar>\n  )\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { isSafeDelete } from \"./is-safe-delete\"\n\ntype AtomicDeleteEditor = {\n  atomicDelete: true\n}\n\nexport type AtomicDeletePluginCustomTypes = {\n  Name: \"atomic-delete\"\n  Editor: AtomicDeleteEditor\n}\n\n/**\n * The Atomic Delete plugin protects master/slave related elements from being\n * put into a bad state after a delete.\n *\n * This can happen because Slate's default delete behavior does not take into\n * account the relationship between master/slave elements.\n *\n * Specifically, atomic delete protects against the following situations:\n *\n * - User forward deletes from just before a table. The first cell in the\n *   table is deleted leaving a first row with one less cell than the rest\n *   of the table.\n *\n * - User forward deletes at the end of a code block. Text from outside the\n *   code block is pulled into the code block.\n *\n * - User backward deletes from just after a code block. Text from outside the\n *   code block is pulled into the code block.\n *\n * - User backward deletes at the start of a code block. Text from inside the\n *   code block is pulled outside the code block.\n */\nexport const AtomicDeletePlugin = createPlugin<AtomicDeletePluginCustomTypes>(\n  (editor) => {\n    editor.atomicDelete = true\n    return {\n      name: \"atomic-delete\",\n      editor: {\n        deleteBackward() {\n          if (editor.selection == null) return false\n          const entry = Editor.node(editor, editor.selection)\n          const prevEntry = Editor.previous(editor, { mode: \"lowest\" })\n          if (isSafeDelete(editor, entry, prevEntry)) return false\n          Transforms.move(editor, { unit: \"character\", reverse: true })\n          return true\n        },\n        deleteForward() {\n          if (editor.selection == null) return false\n          const entry = Editor.node(editor, editor.selection)\n          const nextEntry = Editor.next(editor, { mode: \"lowest\" })\n          if (isSafeDelete(editor, entry, nextEntry)) return false\n          Transforms.move(editor, { unit: \"character\" })\n          return true\n        },\n      },\n    }\n  }\n) as TypedPlugin<AtomicDeletePluginCustomTypes>\n","import { Editor, Element, NodeEntry, Path } from \"slate\"\n\nimport { findElementUp } from \"~/src/sink\"\n\nexport function isSafeDelete(\n  editor: Editor,\n  a: NodeEntry | undefined,\n  b: NodeEntry | undefined\n) {\n  if (!a || !b) return true\n  /**\n   * If the current Node and the next Node are the same, short circuit\n   * and leave early. Good for performance.\n   */\n  if (Path.equals(a[1], b[1])) return true\n  const masterEntryA = findElementUp(\n    editor,\n    (el) => Element.isElement(el) && editor.isMaster(el),\n    { at: a[1] }\n  )\n  const masterEntryB = findElementUp(\n    editor,\n    (el) => {\n      return Element.isElement(el) && editor.isMaster(el)\n    },\n    { at: b[1] }\n  )\n  /**\n   * If neither have a master, then don't worry about it.\n   */\n  if (!masterEntryA && !masterEntryB) return true\n  /**\n   * If they both have a master but it's the same master, then don't\n   * worry about it.\n   */\n  if (\n    masterEntryA &&\n    masterEntryB &&\n    Path.equals(masterEntryA[1], masterEntryB[1])\n  )\n    return true\n  return false\n}\n","import React from \"react\"\nimport { Descendant, Element, Node, Transforms } from \"slate\"\n\nimport {\n  createHotkeyHandler,\n  createPlugin,\n  normalizeSiblings,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { $BlockQuote } from \"./styles\"\n\nexport type BlockQuoteEditor = {\n  supportsBlockQuote: true\n  blockQuotePlugin: {\n    indent: () => void\n    outdent: () => void\n  }\n}\n\nexport type BlockQuoteElement = {\n  type: \"block-quote\"\n  children: Descendant[]\n}\n\nexport type BlockQuotePluginCustomTypes = {\n  Name: \"block-quote\"\n  Editor: BlockQuoteEditor\n  Element: BlockQuoteElement\n}\n\nfunction matchBlockQuoteSafe(node: Node) {\n  return (\n    Element.isElement(node) &&\n    /**\n     * TODO:\n     *\n     * This is probably:\n     * Element.isElement(node) && !Element.isInline(node) &&\n     * !Element.isDependant(node)\n     */\n    (node.type === \"paragraph\" ||\n      node.type === \"code-block\" ||\n      node.type === \"table\" ||\n      node.type === \"horizontal-rule\" ||\n      node.type === \"task-list-item\" ||\n      node.type === \"unordered-list-item\" ||\n      node.type === \"ordered-list-item\" ||\n      node.type === \"heading\")\n  )\n}\n\nexport const BlockQuotePlugin = createPlugin<BlockQuotePluginCustomTypes>(\n  (editor) => {\n    editor.supportsBlockQuote = true\n    editor.blockQuotePlugin = {\n      indent: () => {\n        Transforms.wrapNodes(\n          editor,\n          { type: \"block-quote\", children: [] },\n          { match: matchBlockQuoteSafe }\n        )\n      },\n      outdent: () => {\n        Transforms.liftNodes(editor, {\n          match: (node, path) => matchBlockQuoteSafe(node) && path.length > 1,\n        })\n      },\n    }\n    return {\n      name: \"block-quote\",\n      editor: {\n        normalizeNode(entry) {\n          const [node, path] = entry\n          if (!Element.isElement(node)) return false\n          if (node.type !== \"block-quote\") return false\n          return normalizeSiblings<Element>(editor, [node, path], (a, b) => {\n            if (\n              Element.isElement(a[0]) &&\n              Element.isElement(b[0]) &&\n              a[0].type === \"block-quote\" &&\n              b[0].type === \"block-quote\"\n            ) {\n              Transforms.mergeNodes(editor, { at: b[1] })\n            }\n            return true\n          })\n        },\n      },\n      editableProps: {\n        renderElement: ({ element, attributes, children }) => {\n          if (element.type === \"block-quote\") {\n            return <$BlockQuote {...attributes}>{children}</$BlockQuote>\n          }\n        },\n        onKeyDown: createHotkeyHandler({\n          \"super+.\": editor.blockQuotePlugin.indent,\n          \"super+,\": editor.blockQuotePlugin.outdent,\n        }),\n      },\n    }\n  }\n) as TypedPlugin<BlockQuotePluginCustomTypes>\n","import styled from \"@emotion/styled\"\n\nexport const $BlockQuote = styled(\"blockquote\")`\n  position: relative;\n  margin-top: 1em;\n  margin-bottom: 1em;\n  margin-left: 0;\n  border-left: 0.25em solid rgba(0, 0, 0, 0.075);\n  padding-left: 1.5em;\n`\n","import { Editor, Element, Transforms } from \"slate\"\n\nimport {\n  createHotkeyHandler,\n  createPlugin,\n  curryOne,\n  findElementUp,\n  isCollapsed,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { decorate } from \"./decorate\"\nimport { createCodeBlockMethods } from \"./methods\"\nimport { tokenStyles } from \"./prism-theme\"\nimport { CodeBlockPluginCustomTypes } from \"./types\"\nexport * from \"./decorate\"\nexport * from \"./types\"\n\nimport { normalizeNode } from \"./normalizeNode\"\nimport { renderElement } from \"./render-element\"\n\nexport const CodeBlockPlugin = createPlugin<CodeBlockPluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.codeBlock = createCodeBlockMethods(editor)\n\n    function onDelete(): boolean {\n      const { selection } = editor\n      if (!isCollapsed(selection)) return false\n      const codeBlockEntry = findElementUp(editor, \"code-block\")\n      if (codeBlockEntry == null) return false\n      const codeBlockText = Editor.string(editor, codeBlockEntry[1])\n      if (codeBlockText === \"\") {\n        Transforms.removeNodes(editor, { at: codeBlockEntry[1] })\n        return true\n      }\n      return false\n    }\n\n    return createPolicy({\n      name: \"code-block\",\n      editor: {\n        deleteBackward: onDelete,\n        deleteForward: onDelete,\n        isInline(element) {\n          if (\n            element.type === \"code-block\" ||\n            element.type === \"code-block-line\"\n          )\n            return false\n        },\n        isVoid(element) {\n          if (\n            element.type === \"code-block\" ||\n            element.type == \"code-block-line\"\n          )\n            return false\n        },\n        isMaster(element) {\n          if (element.type === \"code-block\") return true\n        },\n        normalizeNode: curryOne(normalizeNode, editor),\n      },\n      editableProps: {\n        decorate,\n        onKeyDown: createHotkeyHandler({\n          \"super+`\": () =>\n            editor.codeBlock.createCodeBlock({ language: \"text\" }),\n          \"mod+a\": () => {\n            /**\n             * When selection is in code-block and the user pressed mod+a,\n             * select the code-block instead of the full document.\n             */\n            const entry = findElementUp(\n              editor,\n              (el) => Element.isElement(el) && el.type === \"code-block\"\n            )\n            if (!entry) return false\n            Transforms.select(editor, entry[1])\n            return true\n          },\n        }),\n        renderElement,\n        renderLeaf: ({ leaf, children }) => {\n          const style = leaf.prismToken\n            ? tokenStyles[leaf.prismToken] || null\n            : null\n          if (style === null) {\n            return children\n          } else {\n            return <span style={style}>{children}</span>\n          }\n        },\n      },\n    })\n  }\n) as TypedPlugin<CodeBlockPluginCustomTypes>\n","import Prism, { languages, tokenize } from \"prismjs\"\nimport { Element, Node, Path, Range } from \"slate\"\n\nimport { CodeBlockElement, CodeBlockLineElement } from \"./types\"\n\n/**\n * Decorate Overview:\n *\n * We decorate the entire `code-block` at once because if we do it by line,\n * code that continues through multiple lines is not higlighted correctly.\n *\n * In order to higlight the entire `code-block` at once, we need to add a\n * newline to the end of each `code-line`. We cannot use `Node.string` on the\n * entire `code-block`.\n *\n * Once we receive the Prism tokens back, we need to create the ranges.\n *\n * The important part is that we track the offsets from the start. With the\n * offsets, we need to map those back to a `path` and `offset` of each\n * `code-line`. We also need to take into consideration that we have added\n * newlines to the end of each line so the algorithm needs to account for that.\n */\n\n/**\n * Takes an array of text lines and returns an array with the offset\n * in characters of the start of each line.\n */\n\nfunction getLineOffsets(lines: string[]) {\n  let offset = 0\n  const lineOffsets: number[] = []\n  for (const line of lines) {\n    lineOffsets.push(offset)\n    offset = offset + line.length\n  }\n  return lineOffsets\n}\n\n/**\n * `decorate` method passed to `Editable`\n */\n\nexport function decorate(\n  nodeEntry: [CodeBlockElement | CodeBlockLineElement, Path]\n): Range[] {\n  const [node, path] = nodeEntry\n\n  if (!Element.isElement(node)) return []\n  if (node.type !== \"code-block\") return []\n\n  const lang: Prism.Grammar | undefined = languages[node.language]\n\n  if (lang === undefined) return []\n\n  /**\n   * To decorate a code-block, we need to look at all the code in a code-block.\n   *\n   * We can't `Node.string` the entire block because it will join lines\n   * together without newlines.\n   *\n   * For this reason, we create an array of `textLines` which is the text of\n   * each codeLine plus a newline on the end of it.\n   *\n   * Then we join all of those together to get the text that was pass into\n   * Prism.\n   *\n   * We need to keep `textLines` around so that we can extract the\n   * `linePositions`\n   */\n\n  const codeLineElements = node.children\n\n  const textLines = codeLineElements.map((node) => `${Node.string(node)}\\n`)\n\n  const text = textLines.join(\"\")\n\n  const lineOffsets: number[] = getLineOffsets(textLines)\n\n  /**\n   * Takes a character offset from the beginning of the `code-block` and\n   * returns the `path` to the `code-line` and the `offset` within the\n   * `code-line` which Slate needs to make the decoration.\n   */\n\n  function getPointFromOffset(offset: number) {\n    for (let i = lineOffsets.length; i >= 0; i--) {\n      const lineOffset = lineOffsets[i]\n      if (lineOffset <= offset) {\n        return {\n          path: [...path, i],\n          offset: offset - lineOffset,\n        }\n      }\n    }\n    throw new Error(\"This shouldn't happen and indicates a bug in the logic\")\n  }\n\n  const ranges: (Range & { prismToken: string })[] = []\n\n  const tokens = tokenize(text, lang)\n\n  /**\n   * Track current character offset from beginning of `textLines` joined\n   * together.\n   */\n\n  let offset = 0\n\n  /**\n   * Tokens are either:\n   *\n   * - string: which means it is not syntax highlighted\n   * - { type: string, content: string, length: number }: the highlight and content\n   */\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      offset += token.length\n    } else {\n      const anchor = getPointFromOffset(offset)\n      const focus = getPointFromOffset(offset + token.length)\n      ranges.push({\n        anchor,\n        focus,\n        prismToken: token.type,\n      })\n      offset += token.length\n    }\n  }\n\n  return ranges\n}\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { createCodeBlock } from \"./createCodeBlock\"\nimport { setCodeBlockLanguage } from \"./setCodeBlockLanguage\"\n\nexport function createCodeBlockMethods(editor: Editor) {\n  return {\n    createCodeBlock: curryOne(createCodeBlock, editor),\n    setCodeBlockLanguage: curryOne(setCodeBlockLanguage, editor),\n  }\n}\n","import { Editor } from \"slate\"\n\nimport { insertRootElement } from \"~/src/sink\"\n\nimport { BuiltInLanguage } from \"../types\"\n\nexport function createCodeBlock(\n  editor: Editor,\n  { language }: { language: BuiltInLanguage }\n) {\n  insertRootElement(editor, {\n    type: \"code-block\",\n    language,\n    children: [{ type: \"code-block-line\", children: [{ text: \"\" }] }],\n  })\n}\n","import { Editor, Element, Transforms } from \"slate\"\n\nimport { BetterAt, findElementUp } from \"~/src/sink\"\n\nimport { BuiltInLanguage } from \"../types\"\n\n/**\n * Set the current CodeBlock's language if the selection is currently in a\n * CodeBlock. Returns true if the language was set, false otherwise.\n */\nexport function setCodeBlockLanguage(\n  editor: Editor,\n  language: BuiltInLanguage,\n  options: { at?: BetterAt } = {}\n): boolean {\n  const entry = findElementUp(\n    editor,\n    (el) => Element.isElement(el) && el.type === \"code-block\",\n    { at: options.at }\n  )\n  if (!entry) return false\n  Transforms.setNodes(editor, { language }, { at: entry[1] })\n  return true\n}\n","/**\n * Styles from\n * https://github.com/PrismJS/prism-themes/blob/master/themes/prism-ghcolors.css\n */\n\nimport { CSSProperties } from \"react\"\n\nconst commentStyle = { color: \"#999988\", fontStyle: \"italic\" }\nconst dimStyle = { opacity: \"0.7\" }\nconst stringStyle = { color: \"#e3116c\" }\nconst operatorStyle = { color: \"#393a34\" }\nconst valueStyle = { color: \"#36acaa\" }\nconst keywordStyle = { color: \"#00a4db\" }\nconst functionStyle = { color: \"#9a050f\" }\nconst tagStyle = { color: \"#00009f\" }\nconst boldStyle = { fontWeight: \"bold\" }\nconst italicStyle = { fontStyle: \"italic\" }\n\ntype TokenStyles = Record<string, CSSProperties>\n\nexport const tokenStyles: TokenStyles = {\n  comment: commentStyle,\n  prolog: commentStyle,\n  doctype: commentStyle,\n  cdata: commentStyle,\n  namespace: dimStyle,\n  string: stringStyle,\n  \"attr-value\": stringStyle,\n  puncutation: operatorStyle,\n  operator: operatorStyle,\n  entity: valueStyle,\n  url: valueStyle,\n  symbol: valueStyle,\n  number: valueStyle,\n  boolean: valueStyle,\n  variable: valueStyle,\n  constant: valueStyle,\n  property: valueStyle,\n  regex: valueStyle,\n  insert: valueStyle,\n  atrule: keywordStyle,\n  keyword: keywordStyle,\n  \"attr-name\": keywordStyle,\n  function: { ...functionStyle, ...boldStyle },\n  delete: functionStyle,\n  tag: tagStyle,\n  selector: tagStyle,\n  important: boldStyle,\n  bold: boldStyle,\n  italic: italicStyle,\n}\n","import { Text } from \"slate\"\n\nimport { createCodeBlockMethods } from \"./methods\"\n\ntype CodeBlockMethods = ReturnType<typeof createCodeBlockMethods>\n\nexport type BuiltInLanguage =\n  | \"text\"\n  | \"html\"\n  | \"svg\"\n  | \"markup\"\n  | \"css\"\n  | \"javascript\"\n  | \"js\"\n  | \"java\"\n  | \"c\"\n  | \"clike\"\n\n/**\n * Maps a number of supported or semi-supported syntax highlighting languages\n * to the built-in Prism languages.\n */\nexport const LanguageMap: Record<string, BuiltInLanguage> = {\n  plain: \"text\",\n  plaintext: \"text\",\n  text: \"text\",\n  txt: \"text\",\n  html: \"markup\",\n  mathml: \"markup\",\n  svg: \"markup\",\n  xml: \"markup\",\n  ssml: \"markup\",\n  atom: \"markup\",\n  rss: \"markup\",\n  css: \"css\",\n  c: \"clike\",\n  clike: \"clike\",\n  \"c#\": \"clike\",\n  \"c++\": \"clike\",\n  java: \"clike\",\n  javascript: \"javascript\",\n  js: \"javascript\",\n}\n\nexport const LanguageCaptionMap: Record<string, string> = {\n  javascript: \"Javascript\",\n  js: \"Javascript\",\n}\n\nexport const LanguageList: BuiltInLanguage[] = [\n  \"text\",\n  \"html\",\n  \"css\",\n  \"svg\",\n  \"javascript\",\n  \"java\",\n  \"c\",\n]\n\nexport type CodeBlockEditor = {\n  codeBlock: CodeBlockMethods\n}\n\n/**\n * The code block element is the root element of a code block.\n */\nexport type CodeBlockElement = {\n  type: \"code-block\"\n  /**\n   * The language of the code block. Can accept any string because Markdown can\n   * accept any string; however, the built-in Prism languages are defined in:\n   * `BuiltInLanguage`\n   */\n  language: string\n  children: CodeBlockLineElement[]\n}\n\nexport type CodeBlockLineElement = {\n  type: \"code-block-line\"\n  children: Text[]\n}\n\nexport type CodeBlockPluginCustomTypes = {\n  Name: \"code-block\"\n  Editor: CodeBlockEditor\n  Element: CodeBlockElement | CodeBlockLineElement\n  Text: { text: string; prismToken?: string }\n}\n","import { Editor, Element, Node, NodeEntry, Transforms } from \"slate\"\n\nexport function normalizeNode(editor: Editor, entry: NodeEntry<Node>): boolean {\n  if (!Element.isElement(entry[0])) return false\n  /**\n   * Code lines should only contain plain text.\n   *\n   * - If they contain void elements like images, remove them\n   * - If they contain non-void elements, unwrap them\n   *\n   * TODO:\n   *\n   * Convert pasted in elements to Markdown code\n   */\n  if (entry[0].type === \"code-block-line\") {\n    for (const [child, path] of Node.children(editor, entry[1])) {\n      if (!Element.isElement(child)) continue\n      if (editor.isVoid(child)) {\n        Transforms.removeNodes(editor, { at: path })\n        return true\n      } else {\n        Transforms.unwrapNodes(editor, { at: path })\n        return true\n      }\n    }\n  }\n  /**\n   * Code blocks should only contain code lines.\n   *\n   * - If they contain void blocks like images, remove them\n   * - If they contain non-void blocks, then convert them to code lines\n   *\n   * TODO:\n   *\n   * Convert pasted in elements to Markdown code\n   */\n  if (entry[0].type === \"code-block\") {\n    for (const [child, path] of Node.children(editor, entry[1])) {\n      if (!Element.isElement(child)) continue\n      if (child.type === \"code-block-line\") continue\n      if (child.type === \"code-block\") {\n        /**\n         * When pasting two or more lines of `code-block-line`, Slate will paste\n         * it as a `code-block` which will create a `code-block` in a\n         * `code-block`. The following code removes the lower `code-block`.\n         */\n        Transforms.unwrapNodes(editor, { at: path })\n        return true\n      } else if (editor.isVoid(child)) {\n        Transforms.removeNodes(editor, { at: path })\n        return true\n      } else {\n        Transforms.removeNodes(editor, { at: path })\n        Transforms.insertNodes(editor, {\n          type: \"code-block-line\",\n          children: [{ text: Node.string(child) }],\n        })\n        return true\n      }\n    }\n  }\n  return false\n}\n","import { ConstrainedRenderElementProps } from \"../../sink\"\nimport { CodeBlockElement, CodeBlockLineElement } from \"../types\"\nimport { CodeBlock } from \"./CodeBlock\"\nimport { CodeBlockLine } from \"./CodeBlockLine\"\n\nexport function renderElement({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<CodeBlockElement | CodeBlockLineElement>) {\n  if (element.type === \"code-block\") {\n    return (\n      <CodeBlock element={element} attributes={attributes}>\n        {children}\n      </CodeBlock>\n    )\n  } else if (element.type === \"code-block-line\") {\n    return (\n      <CodeBlockLine element={element} attributes={attributes}>\n        {children}\n      </CodeBlockLine>\n    )\n  }\n}\n","import { useCallback, useRef } from \"react\"\nimport { useSelected } from \"slate-react\"\n\nimport { Menu, MenuItemData } from \"../../shared-overlays\"\nimport { ConstrainedRenderElementProps } from \"../../sink\"\nimport { useLayer } from \"../../use-layer\"\nimport { ChevronDownIcon } from \"../icons/ChevronDownIcon\"\nimport { $CodeBlock, $CodeBlockLanguage, $CodeBlockScroller } from \"../styles\"\nimport { CodeBlockElement, LanguageList } from \"../types\"\n\nexport function CodeBlock({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<CodeBlockElement>) {\n  const ref = useRef<HTMLDivElement>(null)\n  const selected = useSelected()\n  const dropdown = useLayer(\"code-block-dropdown\")\n  const onClick = useCallback(() => {\n    if (dropdown.layer) dropdown.close()\n    const dest = ref.current\n    if (dest === null) return\n    const items: MenuItemData[] = LanguageList.map((language) => {\n      return {\n        icon: () => <span />,\n        title: language,\n        action: (editor) => {\n          editor.codeBlock.setCodeBlockLanguage(language, { at: element })\n        },\n      }\n    })\n    // Menu\n    dropdown.open(() => (\n      <Menu dest={dest} items={items} close={dropdown.close} />\n    ))\n  }, [element])\n\n  return (\n    <$CodeBlock className={selected ? \"--selected\" : \"\"} {...attributes}>\n      <$CodeBlockLanguage contentEditable={false} onClick={onClick} ref={ref}>\n        <span>{element.language}</span>\n        <ChevronDownIcon />\n      </$CodeBlockLanguage>\n      <$CodeBlockScroller>{children}</$CodeBlockScroller>\n    </$CodeBlock>\n  )\n}\n","import { SVGProps } from \"react\"\n\nimport { TablerIcon } from \"~/src/sink\"\n\nexport const ChevronDownIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <path d=\"m6 9 6 6 6-6\" />\n  </TablerIcon>\n)\n","import styled from \"@emotion/styled\"\n\nexport const $CodeBlock = styled(\"div\")`\n  position: relative;\n  background: var(--code-block-bgcolor);\n  margin: 1em 0;\n  border-radius: 0.5em;\n  border: 1px solid var(--code-block-border-color);\n  /**\n   * DO NOT REMOVE: Code for adding line numbering if enabled. See $CodeBlockLine\n  * for more details.\n   * counter-reset: line;\n   */\n  &.--selected {\n    outline: 2px solid var(--select-color);\n  }\n  /**\n   * NOTE: Required to make the border radius work on the first and last lines.\n   * Otherwise they will be square.\n   */\n  overflow-x: hidden;\n`\n\nexport const $CodeBlockScroller = styled(\"div\")`\n  padding: 2.25em 1em 1.5em 1em;\n  border-radius: 0.5em;\n  overflow-x: auto;\n`\n\nexport const $CodeBlockLanguage = styled(\"span\")`\n  cursor: pointer;\n  position: absolute;\n  top: 0.25em;\n  right: 0.25em;\n  width: 8em;\n  display: flex;\n  font-size: 0.75em;\n  color: var(--shade-700);\n  background: var(--shade-200);\n  padding: 0.25em 0.5em;\n  border-radius: 0.5em;\n  align-items: center;\n  gap: 0.25em;\n  span {\n    text-align: right;\n    flex: 1 1 auto;\n  }\n  svg {\n    flex: 0 0 auto;\n    position: relative;\n  }\n  &:hover {\n    color: var(--shade-800);\n    background: var(--shade-300);\n  }\n`\n\nexport const $CodeBlockLine = styled(\"div\")`\n  white-space: pre;\n  line-height: 1.5em;\n  counter-increment: line;\n  font-family: \"andale mono\", AndaleMono, monospace;\n  font-size: 0.875em;\n  &.--selected {\n    background-color: var(--shade-100);\n  }\n  /*\n    DO NOT REMOVE: Code for adding line numbering.\n    TODO: Make optional in future.\n    */\n  /* &:before {\n    content: counter(line);\n    color: rgba(0, 0, 0, 0.25);\n    border-right: 1px solid rgba(0, 0, 0, 0.05);\n    margin-right: 1em;\n    padding: 0em 1em 0 0;\n    text-align: right;\n    display: inline-block;\n    width: 2em;\n  } */\n`\n","import { useSelected } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"../../sink\"\nimport { $CodeBlockLine } from \"../styles\"\nimport { CodeBlockLineElement } from \"../types\"\n\nexport function CodeBlockLine({\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<CodeBlockLineElement>) {\n  const selected = useSelected()\n  return (\n    <$CodeBlockLine\n      className={selected ? \"--selected\" : \"\"}\n      {...attributes}\n      spellCheck=\"false\"\n    >\n      {children}\n    </$CodeBlockLine>\n  )\n}\n","import { Descendant } from \"slate\"\n\nimport {\n  createHotkeyHandler,\n  createPlugin,\n  curryOne,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { normalizeNode } from \"./normalize-node\"\nimport { Paragraph } from \"./render-element/paragraph\"\n\nexport type CollapsibleParagraphEditor = {\n  collapsibleParagraph: {\n    convertParagraph: () => void\n  }\n}\n\nexport type ParagraphElement = {\n  type: \"paragraph\"\n  __collapsible?: true\n  children: Descendant[]\n}\n\nexport type CollapsibleParagraphPluginCustomTypes = {\n  Name: \"collapsible-paragraph\"\n  Editor: CollapsibleParagraphEditor\n  Element: ParagraphElement\n}\n\nexport const CollapsibleParagraphPlugin =\n  createPlugin<CollapsibleParagraphPluginCustomTypes>((editor) => {\n    editor.convertElement.addConvertElementType(\"paragraph\")\n    editor.collapsibleParagraph = {\n      convertParagraph: () => {\n        editor.convertElement.convertElements<ParagraphElement>(\n          () => false,\n          {\n            type: \"paragraph\",\n          },\n          false\n        )\n      },\n    }\n    if (!editor.normalizeAfterDelete) {\n      throw new Error(\n        `The collapsible-paragraph-plugin has a dependency on the normalize-after-delete plugin. Please add that plugin before this one.`\n      )\n    }\n    return {\n      name: \"collapsible-paragraph\",\n      editor: {\n        normalizeNode: curryOne(normalizeNode, editor),\n      },\n      editableProps: {\n        renderElement: ({ element, attributes, children }) => {\n          switch (element.type) {\n            case \"paragraph\": {\n              return (\n                <Paragraph element={element} attributes={attributes}>\n                  {children}\n                </Paragraph>\n              )\n            }\n          }\n        },\n        onKeyDown: createHotkeyHandler({\n          \"super+0\": editor.collapsibleParagraph.convertParagraph,\n        }),\n      },\n    }\n  }) as TypedPlugin<CollapsibleParagraphPluginCustomTypes>\n","import { Editor, Element, Node, NodeEntry } from \"slate\"\n\nimport { normalizeSiblingParagraphs } from \"./normalize-sibling-paragraphs\"\nimport { normalizeSiblingWalls } from \"./normalize-sibling-walls\"\n\nexport function normalizeNode(editor: Editor, entry: NodeEntry<Node>): boolean {\n  const [node, path] = entry\n  if (!Element.isElement(node)) return false\n  if (normalizeSiblingWalls(editor, [node, path])) return true\n  if (normalizeSiblingParagraphs(editor, [node, path])) return true\n  return false\n}\n","import { Editor, Element, NodeEntry, Transforms } from \"slate\"\n\nimport { normalizeSiblings } from \"~/src/sink\"\n\nimport { ParagraphElement } from \"..\"\n\nfunction isParagraph(node: Element): node is ParagraphElement {\n  return Element.isElement(node) && node.type === \"paragraph\"\n}\n/**\n * If there are two sibling paragraphs next to each other and they are both\n * marked as `__collapsible`, this indicates to us that some kind of wall\n * Element was removed.\n *\n * These two collapsible paragraphs should then be merged into one.\n */\nexport function normalizeSiblingParagraphs(\n  editor: Editor,\n  entry: NodeEntry<Element>\n): boolean {\n  return normalizeSiblings(editor, entry, (a, b) => {\n    if (!isParagraph(a[0]) || !isParagraph(b[0])) return false\n    if (a[0].__collapsible && b[0].__collapsible) {\n      Transforms.removeNodes(editor, { at: a[1] })\n      return true\n    }\n    return false\n  })\n}\n","import { Editor, Element, Node, NodeEntry, Transforms } from \"slate\"\n\nimport { normalizeSiblings } from \"~/src/sink\"\n\nfunction isWall(editor: Editor, node: Node) {\n  if (!Element.isElement(node)) return false\n  return editor.isVoid(node) || editor.isMaster(node)\n}\n/**\n * We want to create collapsible paragraphs in places where we can't easily\n * create them. For example, between two images.\n *\n * Currently, we look for elements that are\n *\n * - `isVoid` like images or\n * - `isMaster` like `table` and `code-block`.\n *\n * If there is nothing between them, we insert a collapsible paragraph.\n */\n\nexport function normalizeSiblingWalls(\n  editor: Editor,\n  entry: NodeEntry<Element>\n): boolean {\n  if (!isWall(editor, entry[0])) return false\n  return normalizeSiblings(editor, entry, (a, b) => {\n    if (!isWall(editor, a[0]) || !isWall(editor, b[0])) return false\n    Transforms.insertNodes(\n      editor,\n      {\n        type: \"paragraph\",\n        __collapsible: true,\n        children: [{ text: \"\" }],\n      },\n      { at: b[1] }\n    )\n    return true\n  })\n}\n","import { clsx } from \"clsx\"\nimport { useSelected } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { ParagraphElement } from \"..\"\nimport { $Paragraph } from \"./styles\"\nimport { getIsEmpty } from \"./utils\"\n\nexport function Paragraph({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<ParagraphElement>) {\n  const selected = useSelected()\n  const isEmpty = getIsEmpty(element)\n  return (\n    <$Paragraph\n      {...attributes}\n      className={clsx({\n        \"--selected\": selected,\n        \"--empty\": isEmpty,\n        \"--collapsible\": !!element.__collapsible,\n      })}\n    >\n      {children}\n    </$Paragraph>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $Paragraph = styled(\"p\")`\n  padding: 0;\n  margin: 1em 0;\n  &:first-child {\n    margin-top: 0;\n  }\n\n  transition: background-color 200ms, margin-top 200ms, padding-top 200ms,\n    margin-bottom 200ms, padding-bottom 200ms, font-size 200ms;\n\n  &.--collapsible&.--empty {\n    font-size: 0.25em; /* font-size is collapsed to 1/4 of regular em */\n    margin: -4em 0; /* margin grows to 3/4 of regular em leaving space */\n    padding: 1em 0; /* this is kind of eye-balling it */\n    border-radius: 1em;\n    &:hover {\n      background: rgba(0, 127, 255, 0.1);\n      cursor: pointer;\n    }\n  }\n  &.--collapsible&.--empty&.--selected {\n    font-size: 1em;\n    padding: 0;\n    margin: 1em 0;\n    &:hover {\n      background: none;\n      cursor: default;\n    }\n    border-radius: 8px;\n  }\n`\n","import { Element, Node } from \"slate\"\n\n/**\n * We check for empty by checking for one node that contains a text that is\n * empty. If there is an inline element, this will introduce at a minimum\n * 3 nodes based on the way Slate normalizes to always have text nodes at\n * the end which is why this check works.\n */\nexport function getIsEmpty(element: Element) {\n  return (\n    element.children.length === 1 &&\n    Node.string(element.children[0]).length === 0\n  )\n}\n","import { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { createConvertElementMethods } from \"./methods\"\n\nexport type ConvertElementEditor = {\n  convertElement: ReturnType<typeof createConvertElementMethods>\n}\n\nexport type ConvertElementPluginCustomTypes = {\n  Name: \"convert-element\"\n  Editor: ConvertElementEditor\n}\n\nexport const ConvertElementPlugin =\n  createPlugin<ConvertElementPluginCustomTypes>((editor) => {\n    editor.convertElement = createConvertElementMethods(editor)\n    return {\n      name: \"convert-element\",\n    }\n  }) as TypedPlugin<ConvertElementPluginCustomTypes>\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { addConvertElementType } from \"./add-convert-element-type\"\nimport { convertElements, CurriedConvertElements } from \"./convert-elements\"\nimport { isConvertElement } from \"./is-convert-element\"\n\nexport function createConvertElementMethods(editor: Editor) {\n  return {\n    convertElementTypes: [] as string[],\n    addConvertElementType: curryOne(addConvertElementType, editor),\n    isConvertibleElement: curryOne(isConvertElement, editor),\n    convertElements: curryOne(\n      convertElements,\n      editor\n    ) as CurriedConvertElements,\n  }\n}\n","import { Editor, Element } from \"slate\"\n\n/**\n * This method lets other plugins register specific elements by their `type`\n * being able to be toggled with a paragraph.\n *\n * In order for an Element to be toggle compatible, generally it should be a\n * non-void block Element whose direct descendants are `Text` or inline elements\n * like:\n *\n * - headings\n * - list items\n */\nexport function addConvertElementType(\n  editor: Editor,\n  type: Element[\"type\"] | Array<Element[\"type\"]>\n): void {\n  if (Array.isArray(type)) {\n    editor.convertElement.convertElementTypes.push(...type)\n  } else {\n    editor.convertElement.convertElementTypes.push(type)\n  }\n}\n","import { Editor, Element } from \"slate\"\n\nimport { rewrapElement, TargetElement } from \"~/src/sink\"\n\n/**\n * A type with generic for `convertElements` (below) to be used with the curry\n * method. TypeScript, unfortunately, cannot automatically curry generics for\n * us so we have to do it manually.\n */\nexport type CurriedConvertElements = <T extends Element = Element>(\n  matchForToggle: (element: Element) => boolean,\n  targetElement: TargetElement<T>,\n  allowToggle: boolean\n) => void\n\n/**\n * The `convertElements` takes a Block Element that has been identified as being\n * convertible and converts it into another type of Element.\n *\n * For example:\n *\n * - headings\n * - list items\n *\n * It also allows for toggling. In this scenario, if all the convertible\n * elements are already in the target state (e.g. we are converting to a heading\n * 2 and all the convertible elemtns are already a heading 2) then the elements\n * will convert back to a `paragraph` element.\n *\n * NOTE:\n *\n * Why is there an unusual signature?\n *\n * This method has a somewhat unusual and not-DRY signature which is in the form\n * of having a `matchForToggle` (which allows us to specify when an Element is\n * already matching the `targetElement`) and also an `allowToggle`; however, we\n * could make `matchForToggle` optional and only `allowToggle` if it is\n * specified.\n *\n * That being said, the signature is set up this way to reduce friction when\n * creating a specific convert function like `convertHeading`. In this scenario,\n * we can have the created `convertHeading` pass through the argument to\n * `allowToggle` and pass it through to this `convertElements` function making\n * that code easier to understand.\n */\nexport function convertElements<T extends Element = Element>(\n  editor: Editor,\n  matchForToggle: (element: Element) => boolean,\n  targetElement: TargetElement<T>,\n  allowToggle: boolean\n): boolean {\n  /**\n   * Find convertible elements\n   */\n  const entries = Array.from(\n    Editor.nodes<Element>(editor, {\n      match: (node) =>\n        Element.isElement(node) &&\n        editor.convertElement.isConvertibleElement(node),\n    })\n  )\n  /**\n   * If there aren't any convertible elements, there's nothing to do\n   */\n  if (entries.length === 0) return false\n\n  /**\n   * If `allowToggle` is `true` and all of the convertible elements match the\n   * `matchForToggle` (for example, if converting to a heading level 2, if all\n   * the matching convertible elements are heading level 2) then we want to\n   * toggle back to a paragraph.\n   */\n  const shouldToggle =\n    allowToggle && entries.every((entry) => matchForToggle(entry[0]))\n\n  if (shouldToggle) {\n    /**\n     * If all of the entries are already the target type, then revert them to\n     * a paragraph\n     */\n    Editor.withoutNormalizing(editor, () => {\n      for (const entry of entries) {\n        rewrapElement(editor, { type: \"paragraph\" }, entry[1])\n      }\n    })\n  } else {\n    /**\n     * If any of the entries aren't the target type, then convert them to the\n     * target type.\n     */\n    Editor.withoutNormalizing(editor, () => {\n      for (const entry of entries) {\n        rewrapElement(editor, targetElement, entry[1])\n      }\n    })\n  }\n  return true\n}\n","import { Editor, Element } from \"slate\"\n\n/**\n * Returns true if the passed in `element` object is an element type that has\n * previously been registered as a convertible element using the\n * `editor.convertElement.addConvertElementType` method.\n */\nexport function isConvertElement(editor: Editor, element: Element): boolean {\n  return editor.convertElement.convertElementTypes.includes(element.type)\n}\n","export * from \"./types\"\n\nimport {\n  createAutocompleteSpaceHandler,\n  createHotkeyHandler,\n  createPlugin,\n  curryOne,\n  curryTwo,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { insertBreak } from \"./insert-break\"\nimport { createHeadingMethods } from \"./methods\"\nimport { $H1, $H2, $H3, $H4, $H5, $H6 } from \"./styles\"\nimport { HeadingPluginCustomTypes } from \"./types\"\n\nexport const HeadingPlugin = createPlugin<HeadingPluginCustomTypes>(\n  (editor) => {\n    editor.convertElement.addConvertElementType(\"heading\")\n    editor.heading = createHeadingMethods(editor)\n    const hotkeyHandler = createHotkeyHandler({\n      \"super+1\": curryTwo(editor.heading.convertHeading, 1, true),\n      \"super+2\": curryTwo(editor.heading.convertHeading, 2, true),\n      \"super+3\": curryTwo(editor.heading.convertHeading, 3, true),\n      \"super+4\": curryTwo(editor.heading.convertHeading, 4, true),\n      \"super+5\": curryTwo(editor.heading.convertHeading, 5, true),\n      \"super+6\": curryTwo(editor.heading.convertHeading, 6, true),\n    })\n    const autocompleteHandler = createAutocompleteSpaceHandler(editor, {\n      \"#\": curryTwo(editor.heading.convertHeading, 1, false),\n      \"##\": curryTwo(editor.heading.convertHeading, 2, false),\n      \"###\": curryTwo(editor.heading.convertHeading, 3, false),\n      \"####\": curryTwo(editor.heading.convertHeading, 4, false),\n      \"#####\": curryTwo(editor.heading.convertHeading, 5, false),\n      \"######\": curryTwo(editor.heading.convertHeading, 6, false),\n    })\n    return {\n      name: \"heading\",\n      editor: {\n        insertBreak: curryOne(insertBreak, editor),\n      },\n      editableProps: {\n        renderElement: ({ element, attributes, children }) => {\n          if (element.type === \"heading\") {\n            switch (element.level) {\n              case 1:\n                return <$H1 {...attributes}>{children}</$H1>\n              case 2:\n                return <$H2 {...attributes}>{children}</$H2>\n              case 3:\n                return <$H3 {...attributes}>{children}</$H3>\n              case 4:\n                return <$H4 {...attributes}>{children}</$H4>\n              case 5:\n                return <$H5 {...attributes}>{children}</$H5>\n              case 6:\n                return <$H6 {...attributes}>{children}</$H6>\n              default:\n                throw new Error(\n                  `Expected element.level to be 1-6 but got ${element.level}`\n                )\n            }\n          }\n        },\n        onKeyDown: (e) => {\n          if (hotkeyHandler(e)) return true\n          if (autocompleteHandler(e)) return true\n          return false\n        },\n      },\n    }\n  }\n) as TypedPlugin<HeadingPluginCustomTypes>\n","import { Descendant } from \"slate\"\n\nimport { createHeadingMethods } from \"./methods\"\n\nexport type HeadingEditor = {\n  heading: ReturnType<typeof createHeadingMethods>\n}\n\nexport type HeadingElement = {\n  type: \"heading\"\n  /**\n   * NOTE:\n   *\n   * Don't extract these into a new type. It's easier to just repeat this and\n   * there's less indirection.\n   */\n  level: 1 | 2 | 3 | 4 | 5 | 6\n  children: Descendant[]\n}\n\nexport type HeadingPluginCustomTypes = {\n  Name: \"heading\"\n  Editor: HeadingEditor\n  Element: HeadingElement\n}\n","import { Editor, Path, Range, Transforms } from \"slate\"\n\nimport { findElementUp } from \"../sink\"\nimport { HeadingElement } from \"./types\"\n\nexport function insertBreak(editor: Editor) {\n  const entry = findElementUp<HeadingElement>(editor, \"heading\")\n  if (!entry) return false\n  if (!editor.selection) return false\n  if (Range.isExpanded(editor.selection)) return false\n  if (!Editor.isEnd(editor, editor.selection.anchor, entry[1])) return false\n  const nextPath = Path.next(entry[1])\n  Transforms.insertNodes(\n    editor,\n    { type: \"paragraph\", children: [{ text: \"\" }] },\n    { at: nextPath }\n  )\n  Transforms.select(editor, {\n    anchor: Editor.start(editor, nextPath),\n    focus: Editor.start(editor, nextPath),\n  })\n  return true\n}\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { HeadingElement } from \"../types\"\n\nfunction convertHeading(\n  editor: Editor,\n  level: 1 | 2 | 3 | 4 | 5 | 6,\n  allowToggle: boolean\n) {\n  editor.convertElement.convertElements<HeadingElement>(\n    (element) => element.type === \"heading\" && element.level == level,\n    { type: \"heading\", level },\n    allowToggle\n  )\n}\n\nexport function createHeadingMethods(editor: Editor) {\n  return {\n    convertHeading: curryOne(convertHeading, editor),\n  }\n}\n","import { css } from \"@emotion/react\"\nimport styled from \"@emotion/styled\"\n\nconst headingStyles = css`\n  margin-top: 1em;\n  &:first-child {\n    margin-top: 0;\n  }\n  font-weight: bold;\n`\n\nexport const $H1 = styled(\"h1\")`\n  ${headingStyles}\n  font-size: 2.25em;\n  letter-spacing: -0.01em;\n`\n\nexport const $H2 = styled(\"h2\")`\n  ${headingStyles}\n  font-size: 1.5em;\n`\n\nexport const $H3 = styled(\"h3\")`\n  ${headingStyles}\n  font-size: 1.25em;\n`\n\nexport const $H4 = styled(\"h4\")`\n  ${headingStyles}\n  font-size: 1em;\n`\n\nexport const $H5 = styled(\"h5\")`\n  ${headingStyles}\n  font-size: 1em;\n`\n\nexport const $H6 = styled(\"h6\")`\n  ${headingStyles}\n  font-size: 1em;\n`\n","import React from \"react\"\n\nimport { createHotkeyHandler, createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { HorizontalRule } from \"./horizontal-rule\"\nimport { createHorizontalRuleMethods } from \"./methods\"\nimport { HorizontalRulePluginCustomTypes } from \"./types\"\nexport * from \"./types\"\n\nexport const HorizontalRulePlugin =\n  createPlugin<HorizontalRulePluginCustomTypes>(\n    (editor, options, { createPolicy }) => {\n      editor.horizontalRule = createHorizontalRuleMethods(editor)\n      return createPolicy({\n        name: \"horizontal-rule\",\n        editor: {\n          isVoid(element) {\n            if (element.type === \"horizontal-rule\") return true\n          },\n        },\n        editableProps: {\n          renderElement: (props) => {\n            if (props.element.type === \"horizontal-rule\") {\n              return <HorizontalRule {...props} />\n            }\n          },\n          onKeyDown: createHotkeyHandler({\n            \"super+-\": editor.horizontalRule.insertHorizontalRule,\n          }),\n        },\n      })\n    }\n  ) as TypedPlugin<HorizontalRulePluginCustomTypes>\n","import { useSelected } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { HorizontalRuleElement } from \".\"\nimport { $HorizontalRule } from \"./styles\"\n\nexport function HorizontalRule({\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<HorizontalRuleElement>) {\n  const selected = useSelected()\n  return (\n    <div {...attributes} draggable>\n      {children}\n      <div contentEditable={false}>\n        <$HorizontalRule className={selected ? \"--selected\" : \"\"} />\n      </div>\n    </div>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $HorizontalRule = styled(\"hr\")`\n  position: relative;\n  height: 1em;\n  /* background-color: var(--hr-color); */\n  margin: 1em 0;\n  &::before {\n    position: absolute;\n    content: \"\";\n    left: 0.125em;\n    right: 0.125em;\n    top: 50%;\n    height: 1px;\n    background-color: var(--hr-color);\n    border-radius: 1px;\n  }\n  border-radius: 0.25em;\n  cursor: pointer;\n  border: none;\n  &:hover {\n    background-color: rgba(0, 127, 255, 0.1);\n    /* &::before {\n      outline: 2px solid var(--hover-color);\n    } */\n  }\n  &.--selected {\n    background: none;\n    &::before {\n      outline: 2px solid var(--select-color, blue);\n    }\n  }\n`\n","import { Editor } from \"slate\"\n\nimport { curryOne, insertRootElement } from \"~/src/sink\"\n\nfunction insertHorizontalRule(editor: Editor) {\n  return insertRootElement(editor, {\n    type: \"horizontal-rule\",\n    children: [{ text: \"\" }],\n  })\n}\n\nexport function createHorizontalRuleMethods(editor: Editor) {\n  return {\n    insertHorizontalRule: curryOne(insertHorizontalRule, editor),\n  }\n}\n","import { createHorizontalRuleMethods } from \"./methods\"\n\ntype HorizontalRuleMethods = ReturnType<typeof createHorizontalRuleMethods>\n\nexport type HorizontalRuleEditor = {\n  horizontalRule: HorizontalRuleMethods\n}\n\nexport type HorizontalRuleElement = {\n  type: \"horizontal-rule\"\n  children: [{ text: \"\" }]\n}\n\nexport type HorizontalRulePluginCustomTypes = {\n  Name: \"horizontal-rule\"\n  Editor: HorizontalRuleEditor\n  Element: HorizontalRuleElement\n}\n","import { Editor, Transforms } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { createPlugin, curryOne, TypedPlugin } from \"~/src/sink\"\n\nimport { createImageMethods } from \"./methods\"\nimport { normalizeNode } from \"./normalize-node\"\nimport { renderElement } from \"./render-element\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImagePluginConfig,\n  ImagePluginCustomTypes,\n} from \"./types\"\nimport { resizeInBounds } from \"./utils\"\n\nconst DEFAULT_OPTIONS: ImagePluginConfig = {\n  maxInitialInlineImageSize: { width: 64, height: 64 },\n  maxInitialImageSize: { width: 320, height: 320 },\n  maxImageSize: { width: 1024, height: 1024 },\n  imageBlockPresets: [\n    /**\n     * Pixel Presets\n     */\n    { name: \"S\", title: \"Small\", type: \"bounds\", width: 160, height: 160 },\n    { name: \"M\", title: \"Medium\", type: \"bounds\", width: 320, height: 320 },\n    { name: \"L\", title: \"Large\", type: \"bounds\", width: 640, height: 640 },\n    /**\n     * Scale Presets\n     */\n    { name: \"⅓\", title: \"1/3 scale\", type: \"scale\", scale: 1 / 3 },\n    { name: \"½\", title: \"1/2 scale\", type: \"scale\", scale: 0.5 },\n    { name: \"Full\", title: \"Full size\", type: \"scale\", scale: 1 },\n  ],\n  imageInlinePresets: [\n    /**\n     * Pixel Presets\n     */\n    {\n      name: \"16\",\n      title: \"16 pixels\",\n      type: \"bounds\",\n      width: 16,\n      height: 16,\n    },\n    {\n      name: \"24\",\n      title: \"24 pixels\",\n      type: \"bounds\",\n      width: 24,\n      height: 24,\n    },\n    {\n      name: \"32\",\n      title: \"32 pixels\",\n      type: \"bounds\",\n      width: 32,\n      height: 32,\n    },\n    /**\n     * Scale Presets\n     */\n    { name: \"⅓\", title: \"1/3 scale\", type: \"scale\", scale: 1 / 3 },\n    { name: \"½\", title: \"1/2 scale\", type: \"scale\", scale: 0.5 },\n    { name: \"Full\", title: \"Full size\", type: \"scale\", scale: 1 },\n  ],\n}\n\nexport const ImagePlugin = //({\n  createPlugin<ImagePluginCustomTypes>(\n    (editor, sinkOptions, { createPolicy }) => {\n      const options: ImagePluginConfig = {\n        ...DEFAULT_OPTIONS,\n        ...sinkOptions.image,\n      }\n      editor.image = {\n        ...createImageMethods(editor),\n        maxInitialInlineImageSize: options.maxInitialInlineImageSize,\n        maxInitialImageSize: options.maxInitialImageSize,\n        maxImageSize: options.maxImageSize,\n        imageBlockPresets: options.imageBlockPresets,\n        imageInlinePresets: options.imageInlinePresets,\n      }\n      editor.upload.onUploadImageFile = (e) => {\n        const { selection } = editor\n        if (e.width <= 64 && e.height <= 64) {\n          Transforms.insertNodes(editor, {\n            type: \"image-inline\",\n            url: e.hashUrl,\n            alt: e.file.name,\n            title: e.file.name,\n            bytes: e.file.size,\n            width: e.width,\n            height: e.height,\n            srcWidth: e.width,\n            srcHeight: e.height,\n            children: [{ text: \"\" }],\n          })\n        } else {\n          const initialSize = resizeInBounds(\n            { width: e.width, height: e.height },\n            options.maxInitialImageSize || options.maxImageSize\n          )\n          Transforms.insertNodes(editor, {\n            type: \"image-block\",\n            url: e.hashUrl,\n            alt: e.file.name,\n            title: e.file.name,\n            bytes: e.file.size,\n            width: initialSize.width,\n            height: initialSize.height,\n            srcWidth: e.width,\n            srcHeight: e.height,\n            children: [{ text: \"\" }],\n          })\n        }\n\n        /**\n         * If there is no selection the element is inserted at the bottom of the\n         * editor. When this happens, the insertion point may not be visible and\n         * so this code scrolls to the bottom of the editor. We don't do this if\n         * there is a selection because if the user made a selection, it is\n         * likely already in view.\n         */\n        if (!selection) {\n          const lastPos = Editor.end(editor, [])\n          Transforms.select(editor, lastPos)\n          ReactEditor.focus(editor)\n        }\n        return true\n      }\n      editor.upload.onUploadImageFileSuccess = (e) => {\n        editor.upload.setElementTimeTraveling<\n          ImageBlockElement | ImageInlineElement\n        >({ url: e.hashUrl }, { url: e.url })\n        return true\n      }\n\n      return createPolicy({\n        name: \"image\",\n        editor: {\n          isVoid: (element) => {\n            if ([\"image-block\", \"image-inline\"].includes(element.type)) {\n              return true\n            }\n          },\n          isInline: (element) => {\n            if (element.type === \"image-inline\") return true\n          },\n          normalizeNode: curryOne(normalizeNode, editor),\n        },\n        editableProps: {\n          renderElement,\n        },\n      })\n    }\n  ) as TypedPlugin<ImagePluginCustomTypes>\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nfunction noop(editor: Editor) {\n  editor\n}\n\nexport function createImageMethods(editor: Editor) {\n  return {\n    noop: curryOne(noop, editor),\n  }\n}\n","import { Editor, Node, NodeEntry } from \"slate\"\n\nexport function normalizeNode(editor: Editor, entry: NodeEntry<Node>): boolean {\n  editor\n  entry\n  return false\n}\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { ImageBlockElement, ImageInlineElement } from \"../types\"\nimport { ImageBlock } from \"./image-block\"\nimport { ImageInline } from \"./image-inline\"\n\nexport function renderElement({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<ImageBlockElement | ImageInlineElement>) {\n  switch (element.type) {\n    case \"image-block\":\n      return (\n        <ImageBlock element={element} attributes={attributes}>\n          {children}\n        </ImageBlock>\n      )\n    case \"image-inline\":\n      return (\n        <ImageInline element={element} attributes={attributes}>\n          {children}\n        </ImageInline>\n      )\n  }\n}\n","import { useSlateStatic } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { $ImageBlock } from \"../styles/image-block-styles\"\nimport { ImageBlockElement } from \"../types\"\nimport { ImageWithControls } from \"./image-with-controls\"\n\nexport function ImageBlock({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<ImageBlockElement>) {\n  const editor = useSlateStatic()\n  return (\n    <div {...attributes}>\n      <$ImageBlock contentEditable={false}>\n        <ImageWithControls\n          element={element}\n          presets={editor.image.imageBlockPresets}\n        />\n      </$ImageBlock>\n      {children}\n    </div>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $ImageBlock = styled(\"div\")`\n  display: block;\n  margin: 1em 0;\n`\n","import { clsx } from \"clsx\"\nimport React, { useState } from \"react\"\nimport { useSelected } from \"slate-react\"\n\nimport { useUpload } from \"~/src/upload-plugin/store\"\n\nimport {\n  $Image,\n  $ImageContainer,\n} from \"../../styles/image-with-controls-styles/image-with-controls-styles\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImageSizePreset,\n} from \"../../types\"\nimport { ImageResizeControl } from \"./image-resize-controls/image-resize-control\"\nimport { ImageSizeStatus } from \"./image-size-status/image-size-status\"\nimport { ImageToolbar } from \"./image-toolbar/image-toolbar\"\n\n/**\n * The `Image` Component is responsible for:\n *\n * - rendering the image\n * - displaying the UI for the image including\n *   - resize controls\n *   - current width/height\n *   - image preset size controls\n *\n * It's outer $ImageContainer is represented as an `inline-block` and is\n * placed inside a `block` element for the `image-block` and a `span` element\n * for `image-inline`.\n */\nexport function ImageWithControls({\n  element,\n  presets,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n  presets: ImageSizePreset[]\n}) {\n  const upload = useUpload(element.url)\n  const selected = useSelected()\n  const [isDragging, setIsDragging] = useState(false)\n  const [size, setSize] = useState(\n    element.srcWidth && element.srcHeight && element.width && element.height\n      ? { width: element.width, height: element.height }\n      : null\n  )\n\n  /**\n   * Creates a `srcSize` object if there is both a srcWidth and a srcHeight.\n   * This also acts as an indicator that the image can be resized. If there is\n   * a `srcSize` present we know that the image can be resized.\n   */\n  const srcSize =\n    element.srcWidth && element.srcHeight\n      ? { width: element.srcWidth, height: element.srcHeight }\n      : null\n\n  /**\n   * Show resize controls if the element is selected, it has a `size` and\n   * it has a `srcSize`\n   */\n  const showControls = selected && size && srcSize\n\n  /**\n   * Add classes for different states.\n   */\n  const className = clsx({\n    \"--selected\": selected,\n    \"--dragging\": isDragging,\n    \"--small\": size && (size.width <= 64 || size.height <= 64),\n    \"--loaded\": upload.status === \"success\",\n  })\n\n  /**\n   * The purpose of the surrounding $ImageContainer is simply to surround the\n   * image tightly so that we can place the other control elements relative\n   * to the image.\n   *\n   * In order to do this, the $ImageContainer must be an `inline-block` or else\n   * space gets added on the inside of the container.\n   *\n   * NOTE:\n   *\n   * Everything inside the $ImageContainer must be safe to insert into a\n   * `<p>` tag which means `<div>` tags are not allowed. Use `<span>` tags\n   * instead, even if they are blocks. This is because we get some invalid\n   * nested warning otherwise as `<div>` tags are not supposed to be children\n   * of `<p>` tags.\n   */\n  return (\n    <$ImageContainer className={className}>\n      <$Image src={upload.url} width={size?.width} height={size?.height} />\n      {showControls ? (\n        <ImageToolbar\n          element={element}\n          size={size}\n          setSize={setSize}\n          srcSize={srcSize}\n          presets={presets}\n        />\n      ) : null}\n      {/**\n       * Show the size status bar only when the user is dragging to resize the\n       * image.\n       */}\n      {isDragging && size ? <ImageSizeStatus size={size} /> : null}\n      {showControls ? (\n        <ImageResizeControl\n          element={element}\n          srcSize={srcSize}\n          isDragging={isDragging}\n          setIsDragging={setIsDragging}\n          size={size}\n          setSize={setSize}\n        />\n      ) : null}\n    </$ImageContainer>\n  )\n}\n","import styled from \"@emotion/styled\"\n\n/**\n * Wrap the image with a container so we can accurately place UI elements\n * around it.\n */\nexport const $ImageContainer = styled(\"span\")`\n  /**\n   * In order for this container to wrap tightly (without space), it needs to be\n   * an \"inline-block\". If it's just an \"inline\" we end up with spacing\n   * artificats related to how spacing is placed around text.\n   */\n  display: inline-block;\n  /**\n   * This wrapper's primary purpose (why we don't use the image by itself) is\n   * so that we can place UI controls for the image in and around the image.\n   */\n  position: relative;\n`\n\nexport const $Image = styled(\"img\")`\n  /**\n   * TODO:\n   *\n   * This is a bit of a hack but is a better experience than not anything.\n   *\n   * Constrains the maximum resize width of an image to 100% of the space\n   * available. This prevents the image from stepping outside its boundaries.\n   *\n   * Problem:\n   *\n   * - The \"height\" is set to \"auto\" which likely conflicts with the height\n   *   provided as an image attribute of \"height\" set by the application.\n   *   Effectively, this means that the \"height\" is ignored which is fine\n   *   except when the image hasn't been loaded yet, I think it's possible\n   *   and perhaps likely that there may be a reflow that happens before/after\n   *   the image is loaded.\n   */\n  max-width: 100%;\n  height: auto;\n\n  /**\n   * Rounded borders are pretty and also help the selection outline look\n   * pretty.\n   */\n  transition: border-radius 250ms;\n  border-radius: 0.5em;\n  .--small > & {\n    border-radius: 1px;\n  }\n  display: block;\n\n  /**\n   * Selection border. We leave a space between the outline and the image so\n   * that an image that is the same color as the selection border will still\n   * look selected.\n   */\n  .--selected > & {\n    outline: 2px solid var(--select-color);\n    outline-offset: 1px;\n  }\n  /**\n   * If the image isn't loaded yet, we want to have some color filling the space\n   * that the image will eventually load into. This helps indicates to the user\n   * the space that the image will fill into.\n   *\n   * Once the image is finished loading, we want to respect transparency so at\n   * that point we hide the background shading.\n   */\n  .--loading > & {\n    background: var(--shade-100);\n  }\n\n  /**\n   * When we change the image via a preset, we want to animate the change;\n   * however, when we are dragging to resize, a transition adds a janky delay\n   * to the resize so we remove the transition during drag resizing.\n   */\n  transition: width 100ms, height 100ms;\n  .--dragging > & {\n    transition: border-radius 250ms;\n  }\n`\n","import { clsx } from \"clsx\"\nimport { Dispatch, SetStateAction, useCallback } from \"react\"\nimport { Editor, Transforms } from \"slate\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { stopEvent } from \"~/src/sink\"\nimport { useResizeBrowser } from \"~/src/use-reposition/hooks\"\n\nimport {\n  $ImageResizeHandle,\n  $ImageResizeInvisibleHandle,\n} from \"../../../styles/image-with-controls-styles/image-resize-handle-styles\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImageSize,\n} from \"../../../types\"\nimport { getEditorWidth, minMax, resizeToWidth } from \"../../../utils\"\n\n/**\n * Helper function finds the `img` inside the current Slate `Element`.\n *\n * The `Element` in the DOM points to the surrounding container, so we search\n * inside of it for the `img` tag which know there is only one of.\n *\n * We then get the client rect from it.\n */\nfunction getImageBoundsFromSlateElement(\n  editor: Editor,\n  element: ImageBlockElement | ImageInlineElement\n): DOMRect {\n  const imageContainerDOMNode = ReactEditor.toDOMNode(editor, element)\n  const imgDOMNode = imageContainerDOMNode.querySelector(\"img\")\n  if (!imgDOMNode)\n    throw new Error(`Image Element could not be found but should exist`)\n  return imgDOMNode.getBoundingClientRect()\n}\n\nexport function ImageResizeControl({\n  element,\n  srcSize,\n  size,\n  setSize,\n  isDragging,\n  setIsDragging,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n  srcSize: ImageSize\n  size: ImageSize\n  setSize: Dispatch<SetStateAction<ImageSize | null>>\n  isDragging: boolean\n  setIsDragging: Dispatch<SetStateAction<boolean>>\n}) {\n  const editor = useSlateStatic()\n\n  /**\n   * Refreshes the rendering of the resize handle if the browser width is\n   * changed. This is useful, for example, if the browser is resized, making\n   * the editable area smaller, which in some cases shoudl cause the resize\n   * handle to indicate that the image can only be resized smaller.\n   */\n  useResizeBrowser()\n\n  /**\n   * Retrieve the inner (usable) width of the editor.\n   */\n  const editorWidth = getEditorWidth(editor)\n\n  /**\n   * Create some convenience constants that we use a lot below\n   */\n  const width = size.width\n  const maxWidth = Math.min(srcSize.width, editorWidth)\n  const minWidth = Math.min(12, srcSize.width)\n\n  /**\n   * Start dragging\n   */\n  const onMouseDown = useCallback(\n    (e: React.MouseEvent) => {\n      stopEvent(e)\n      setIsDragging(true)\n\n      /**\n       * Position of mouse pointer when mouse down is pressed\n       */\n      const startX = e.clientX\n\n      /**\n       * The initial image size for the visual image (i.e. the image we are\n       * seeing on the screen) can vary from the image width as stored in the\n       * Document value.\n       *\n       * This is because if the document image width value is larger than the\n       * screen width, we have constrained the image so that it fits.\n       *\n       * When we start a resize, we want the resize to start at the visual\n       * image width though or the drag may appear broken. For example, if you\n       * start resizing smaller, if the image is larger than the width of the\n       * screen, the resize will take no effect.\n       *\n       * For this reason, we start with the visual screen width.\n       */\n      const bounds = getImageBoundsFromSlateElement(editor, element)\n      const startWidth = bounds.width\n\n      let nextSize = { ...size }\n\n      /**\n       * Watch mouse movement during dragging\n       */\n      const onDocumentMouseMove = (e: MouseEvent) => {\n        const nextWidth = minMax({\n          value: startWidth + e.clientX - startX,\n          min: minWidth,\n          max: maxWidth,\n        })\n        nextSize = resizeToWidth(nextWidth, srcSize)\n\n        setSize(nextSize)\n      }\n\n      /**\n       * Remove dragging event listeners when releasing mouse button\n       */\n      const onDocumentMouseUp = () => {\n        document.removeEventListener(\"mousemove\", onDocumentMouseMove)\n        document.removeEventListener(\"mouseup\", onDocumentMouseUp)\n        const path = ReactEditor.findPath(editor, element)\n        /**\n         * When we save the image to the document, at the moment, we have\n         * decided to save the image at the actual resize width, as stored\n         * in the resize state. This is different than using the visual\n         * image width which is constrained to the width of the screen.\n         *\n         * Not sure if this is the right approach, but it does allow for a\n         * manual workaround if desired where the content is being edited in\n         * a smaller screen than the output window and the user wants to have\n         * the image display at a larger size.\n         *\n         * Note that this is already possible (to save at a larger size than\n         * the screen width) when using presets so it's not entirely out of\n         * character for our editor either.\n         */\n        const size = {\n          width: nextSize.width,\n          height: nextSize.height,\n        }\n        /**\n         * It's not, at the moment, strictly necessary to set the size because\n         * the size is set during mouse move; however, I'm keeping this here\n         * as (a) a sanity check to ensure this is always correct and (b) if\n         * we ever decide to modify the size before saving (see the comment\n         * above when setting size) then we don't end up in a bad state. This\n         * is something that already occurred once during experimenting.\n         */\n        setSize(size)\n        Transforms.setNodes(editor, size, { at: path })\n        setIsDragging(false)\n      }\n\n      /**\n       * Attach event listeners directly to document\n       */\n      document.addEventListener(\"mousemove\", onDocumentMouseMove)\n      document.addEventListener(\"mouseup\", onDocumentMouseUp)\n    },\n    [srcSize.width, srcSize.height, size.width, element]\n  )\n\n  /**\n   * FIXME:\n   *\n   * This can be refactored so that it shares more code with `onMouseDown`\n   * above. They are nearly identical except:\n   *\n   * - the event listeners that are added/removed\n   * - the way way in which clientX is retrieved\n   */\n  const onTouchStart = useCallback(\n    (e: React.TouchEvent) => {\n      stopEvent(e)\n      setIsDragging(true)\n      const startX = e.changedTouches[0].clientX\n      const startWidth = size.width\n\n      let nextSize = { ...size }\n\n      const onDocumentTouchMove = (te: TouchEvent) => {\n        // stopEvent(te)\n        const e = te.changedTouches[0]\n\n        const nextWidth = minMax({\n          value: startWidth + e.clientX - startX,\n          min: minWidth,\n          max: maxWidth,\n        })\n        nextSize = resizeToWidth(nextWidth, srcSize)\n\n        setSize(nextSize)\n      }\n      const onDocumentTouchEnd = () => {\n        document.removeEventListener(\"touchmove\", onDocumentTouchMove)\n        document.removeEventListener(\"touchend\", onDocumentTouchEnd)\n        const path = ReactEditor.findPath(editor, element)\n        Transforms.setNodes(\n          editor,\n          { width: nextSize.width, height: nextSize.height },\n          { at: path }\n        )\n        setIsDragging(false)\n      }\n\n      document.addEventListener(\"touchmove\", onDocumentTouchMove)\n      document.addEventListener(\"touchend\", onDocumentTouchEnd)\n    },\n    [srcSize.width, srcSize.height, size.width, element]\n  )\n\n  /**\n   * Add special classNames to modify appearance of resize controls\n   */\n  const className = clsx({\n    \"--center\": width < maxWidth && width > minWidth,\n    \"--left\": width >= maxWidth && width > minWidth,\n    \"--right\": width <= minWidth && width < maxWidth,\n    \"--dragging\": isDragging,\n    \"--small\": width <= 64 || size.height <= 64,\n  })\n\n  return (\n    <>\n      {/**\n       * The invisible handle is not visible but gives a larger drag handle\n       * target for the mouse and touch events\n       */}\n      <$ImageResizeInvisibleHandle\n        className={className}\n        onMouseDown={onMouseDown}\n        onTouchStart={onTouchStart}\n      >\n        <$ImageResizeHandle>\n          <span className=\"--bar --bar-left\" />\n          <span className=\"--bar --bar-center\" />\n          <span className=\"--bar --bar-right\" />\n        </$ImageResizeHandle>\n      </$ImageResizeInvisibleHandle>\n    </>\n  )\n}\n","export * from \"./use-absolute-reposition\"\nexport * from \"./use-fixed-reposition\"\nexport * from \"./use-reposition\"\nexport * from \"./use-resize-browser\"\nexport * from \"./use-throttled-refresh\"\n","import { useEffect } from \"react\"\n\nimport { useThrottledRefresh } from \"./use-throttled-refresh\"\n\n/**\n * Refreshes the Component whenever the page is resized or the window is\n * scrolled. This is because these are usually the only two events that cause\n * the elements on a page to be repositioned.\n *\n * If there are yet other events that can cause the elements to be repositioned\n * or resized, you can also call the returned `refresh` method. This will\n * update the components while still respected the fact that the updates will\n * be throttled so as not to overload the browser.\n */\nexport function useResizeBrowser() {\n  /**\n   * Create a throttled `refresh` method.\n   */\n  const refresh = useThrottledRefresh()\n\n  /**\n   * refresh on page resize or scroll (throttled)\n   */\n  useEffect(() => {\n    refresh()\n    window.addEventListener(\"resize\", refresh)\n    return () => {\n      window.removeEventListener(\"resize\", refresh)\n    }\n  }, [])\n\n  return refresh\n}\n","import styled from \"@emotion/styled\"\n\nexport const $ImageResizeInvisibleHandle = styled(\"span\")`\n  position: absolute;\n  display: block;\n  /**\n   * Prevent touch dragging from exhibiting a kind of scroll bounce behavior\n   * when we just want the image to resize.\n   */\n  touch-action: none;\n  background: rgba(127, 127, 127, 0.001);\n  top: 0;\n  right: calc(-1em - 2px);\n  width: 2em;\n  bottom: 0;\n  &.--left {\n    cursor: w-resize;\n  }\n  &.--center {\n    cursor: ew-resize;\n  }\n  &.--right {\n    cursor: e-resize;\n  }\n  &.--small {\n    right: calc(-1.25em);\n    /* background: green; */\n    width: 1.25em;\n  }\n`\nexport const $ImageResizeHandle = styled(\"span\")`\n  position: absolute;\n  display: block;\n  background: var(--select-color);\n  top: 50%;\n  margin-top: -1em;\n  width: 1em;\n  height: 2em;\n  outline: 1px solid white;\n  transition: all 250ms;\n  /**\n   * The handle is 3 visible states depending on whether the image is at\n   * maximum size or minimum size.\n   *\n   * There are three indicators that let the user know which directions are\n   * available (left, right or both) that the user can drag:\n   *\n   * - rounded corners on the side that are available to drag towards\n   * - on larger size image, the handle is on the inside, middle or outside\n   *   of the outline\n   * - the cursor pointer indicates the direction available for resizing.\n   */\n  .--center > & {\n    left: 0.5em;\n    border-radius: 0.375em;\n  }\n  .--left > & {\n    border-radius: 0.5em 0 0 0.5em;\n    left: 1px;\n  }\n  .--right > & {\n    border-radius: 0 0.5em 0.5em 0;\n    left: calc(50% - 1px);\n  }\n  .--bar {\n    position: absolute;\n    background: var(--blue-200);\n    width: 1px;\n    top: 0.5em;\n    bottom: 0.5em;\n  }\n  /**\n   * Each of 3 bars is 1px wide and 3px apart\n   */\n  .--bar-left {\n    left: calc(50% - 3.5px);\n  }\n  .--bar-center {\n    left: calc(50% - 0.5px);\n  }\n  .--bar-right {\n    left: calc(50% + 2.5px);\n  }\n  /**\n   * When the image is small, we reduce the size of the handler and place it\n   * outside the image. The reasons we do this:\n   * \n   * - If the handle is not outside the image at small sizes, the handle\n   *   obscures the image too much. At larger sizes, it works okay and the\n   *   inside handle placement makes the available direction of the drags more\n   *   intuitive.\n   *\n   * - Also, at small sizes, a large handle can overwhelm the image. That is,\n   *   the handle can be twice as tall as the image itself which looks poor.\n   *   It's still possible for the handle to be larger than the image at small\n   *   sizes, but this is okay in that we don't want the handle to become so\n   *   small that it is hard to see and hard to click.\n   */\n  .--small > & {\n    /**\n     * We opt to mainly adjust the size of the handle at smaller sizes by\n     * adjusting the font-size. This is more efficient than changing all the\n     * border-sizes because changing the font-size automatically changes the\n     * size of the border, but we don't have to redo the different combinations\n     * border-size and the corner that they need to display on.\n     */\n    font-size: 0.5em;\n    width: 1.5em;\n    left: 0.5em;\n    margin-top: -1em;\n  }\n  /**\n   * Each of 2 bars is 1px wide and 3px apart\n   */\n  .--small > & > .--bar-left {\n    left: calc(50% - 2px);\n  }\n  .--small > & > .--bar-center {\n    display: none;\n  }\n  .--small > & > .--bar-right {\n    left: calc(50% + 1px);\n  }\n`\n","export * from \"./min-max\"\nexport * from \"./resize-utils\"\n","/**\n * A more intuitive of ensuring a value is within a min/max range.\n */\n\nexport function minMax({\n  value,\n  min,\n  max,\n}: {\n  value: number\n  min: number\n  max: number\n}): number {\n  if (!(max >= min)) throw new Error(`Expected max >= min but is not`)\n  return Math.max(min, Math.min(max, value))\n}\n","import { Editor } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { ImageSize, ImageSizePreset } from \"../types\"\n\n/**\n * Takes a src image and resizes it to the exact width while preserving the\n * aspect ratio.\n *\n * NOTE: This is resizing to exact width, and not to inside width.\n */\nexport function resizeToWidth(width: number, srcSize: ImageSize): ImageSize {\n  width = Math.round(width)\n  const aspect = srcSize.width / srcSize.height\n  return { width, height: Math.round(width / aspect) }\n}\n\n/**\n * Takes a src image and resizes it to the exact height while preserving the\n * aspect ratio.\n *\n * NOTE: This is resizing to exact height, and not to inside height.\n */\nexport function resizeToHeight(height: number, srcSize: ImageSize): ImageSize {\n  height = Math.round(height)\n  const aspect = srcSize.width / srcSize.height\n  return { width: Math.round(height * aspect), height }\n}\n\n/**\n * Intuitive way of taking a size and a bounds and shrinking the size within\n * the given bounds if necessary.\n */\nexport function resizeInBounds(size: ImageSize, bounds: ImageSize): ImageSize {\n  const aspect = size.width / size.height\n  const boundsAspect = bounds.width / bounds.height\n  if (aspect >= boundsAspect) {\n    if (size.width > bounds.width) {\n      return resizeToWidth(bounds.width, size)\n    }\n  } else {\n    if (size.height > bounds.width) {\n      return resizeToHeight(bounds.height, size)\n    }\n  }\n  return size\n}\n\n/**\n * Takes an image size and an image resize preset and calculates the size of\n * the image when the preset is applied.\n *\n * Notably, there are two `preset` algorithms.\n *\n * - `bounds` which sets a maximum width/height and we find the maximum image\n *   size that fits within those bounds.\n *\n * - `scale` which multiples the width/height by a given scale. Note that by\n *   convention that scale should be 1 or less.\n */\nexport function resizeInPreset(\n  size: ImageSize,\n  srcSize: ImageSize,\n  preset: ImageSizePreset\n): ImageSize {\n  switch (preset.type) {\n    case \"bounds\":\n      return resizeInBounds(srcSize, preset)\n    case \"scale\":\n      return {\n        width: Math.round(srcSize.width * preset.scale),\n        height: Math.round(srcSize.height * preset.scale),\n      }\n  }\n}\n\n/**\n * Takes an editor object and returns the maximum width that elements inside of\n * the editor can be rendered at without overflowing.\n *\n * We get the `clientWidth` which is the \"box\" without the border but including\n * the padding. We then subtract the padding to get the value we want.\n */\nexport function getEditorWidth(editor: Editor) {\n  const element = ReactEditor.toDOMNode(editor, editor)\n  const computed = getComputedStyle(element)\n  const padding =\n    parseInt(computed.paddingLeft) + parseInt(computed.paddingRight)\n  return element.clientWidth - padding\n}\n","import { $ImageSizeStatus } from \"../../../styles/image-with-controls-styles/image-size-status-styles\"\nimport { ImageSize } from \"../../../types\"\n\nexport function ImageSizeStatus({ size }: { size: ImageSize }) {\n  return (\n    <$ImageSizeStatus>\n      {size.width} &times; {size.height}\n    </$ImageSizeStatus>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $ImageSizeStatus = styled(\"span\")`\n  position: absolute;\n  /**\n   * The status appears with a 1px gap from the outline.\n   *\n   * - 1px for gap from image to outline\n   * - 2px for outline width\n   * - 1px more for the space to the status\n   */\n  bottom: calc(-2em - 4px);\n  left: 0;\n  font-size: 0.625em; /* 10px tiny */\n  line-height: 2em;\n  padding: 0 0.5em;\n  color: var(--shade-100);\n  background: var(--shade-600);\n  outline: 1px solid rgba(255, 255, 255, 0.5);\n  border-radius: 0.5em;\n  white-space: nowrap;\n\n  /* force numbers to be monospaced for better alignment */\n  font-variant-numeric: tabular-nums;\n`\n","import React, { Dispatch, SetStateAction } from \"react\"\n\nimport { $ImageToolbar } from \"../../../styles/image-with-controls-styles/image-toolbar-styles\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImageSize,\n  ImageSizePreset,\n} from \"../../../types\"\nimport { ImagePresetButtonGroup } from \"./image-preset-buttons/image-preset-button-group\"\nimport { ImageTypeButtonGroup } from \"./image-type-buttons/image-type-button-group\"\n\n/**\n * The ImageToolbar appears above an image when the image is selected.\n *\n * It includes:\n *\n * - A set of image resize presets when clicked resizes the image to the preset\n * - Buttons to toggle between a block image and an inline image\n */\nexport function ImageToolbar({\n  element,\n  size,\n  setSize,\n  srcSize,\n  presets,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n  size: ImageSize\n  setSize: Dispatch<SetStateAction<ImageSize | null>>\n  srcSize: ImageSize\n  presets: ImageSizePreset[]\n}) {\n  return (\n    <$ImageToolbar>\n      <ImageTypeButtonGroup element={element} />\n      <ImagePresetButtonGroup\n        element={element}\n        size={size}\n        setSize={setSize}\n        srcSize={srcSize}\n        presets={presets}\n      />\n    </$ImageToolbar>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $ImageToolbar = styled(\"span\")`\n  position: absolute;\n  /**\n   * On top of the image +1 for space inside outline, +2 for outline,\n   * +2 for space outside outline.\n   *\n   * DO NOT MOVE TO BOTTOM:\n   *\n   * This is a reminder not to move the preset to the bottom. Visually, it is\n   * less obtrusive at the bottom; however, an issue is that when switching\n   * between different presets, the preset UI moves up/down making it difficult\n   * to switch between different presets. When kept at the top, the preset\n   * UI doesn't move.\n   */\n  top: calc(-1.5em - 5px);\n  /**\n   * Align left to the outline: +1 for space inside outline, +2 for outline\n   * width\n   */\n  left: -3px;\n  /**\n   * When we're resizing, the controls aren't usable and just add to visual\n   * clutter so we hide it. The transition lets us do it smoothly and less\n   * obtrusively.\n   */\n  transition: opacity 200ms;\n  .--dragging & {\n    opacity: 0;\n  }\n  display: flex;\n  gap: 0.25em;\n`\n","import { Dispatch, SetStateAction } from \"react\"\n\nimport { $ImageButtonGroup } from \"../../../../styles/image-with-controls-styles/image-buttons-styles\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImageSize,\n  ImageSizePreset,\n} from \"../../../../types\"\nimport { ImagePresetButton } from \"./image-preset-button\"\n\nexport function ImagePresetButtonGroup({\n  element,\n  size,\n  setSize,\n  srcSize,\n  presets,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n  size: ImageSize\n  setSize: Dispatch<SetStateAction<ImageSize | null>>\n\n  srcSize: ImageSize\n  presets: ImageSizePreset[]\n}) {\n  return (\n    <$ImageButtonGroup>\n      {presets.map((preset, i) => {\n        return (\n          <ImagePresetButton\n            element={element}\n            key={i}\n            preset={preset}\n            size={size}\n            setSize={setSize}\n            srcSize={srcSize}\n          />\n        )\n      })}\n    </$ImageButtonGroup>\n  )\n}\n","import styled from \"@emotion/styled\"\n\n/**\n * Styling for a collection of buttons in the $ImageButtonsContainer at the top\n * of the image.\n */\nexport const $ImageButtonGroup = styled(\"span\")`\n  /* font-size: 0.75em; */\n  border-radius: 0.5em;\n  display: flex;\n  /**\n   * So that inner Preset design shows within the rounded corners.\n   */\n  overflow: clip;\n  /**\n   * Let's the menu pop a little over other content. Without it, may be able to\n   * see the border of the buttons.\n   */\n  outline: 1px solid white;\n`\n\nexport const $ImageButton = styled(\"span\")`\n  font-size: 0.75em;\n  line-height: 2em;\n  padding: 0 0.625em;\n  &:last-child {\n    border-right: none;\n  }\n  cursor: pointer;\n\n  /**\n   * We don't want it to wrap\n   */\n  white-space: nowrap;\n\n  /**\n   * Preset default colors\n   */\n  color: var(--shade-600);\n  background: var(--shade-200);\n  border-right: 1px solid var(--shade-100);\n  /**\n   * When preset is disabled, it is lighter in color and with elss contrast.\n   */\n  &.--disabled {\n    cursor: default;\n    color: var(--shade-300);\n    background: var(--shade-100);\n    &:hover {\n      color: var(--shade-300);\n      background: var(--shade-100);\n    }\n  }\n  &.--selected {\n    cursor: default;\n    color: var(--blue-700);\n    background: var(--blue-200);\n    &:hover {\n      color: var(--blue-700);\n      background: var(--blue-200);\n    }\n  }\n  /**\n   * On hover, it is dark, and with higher contrast.\n   */\n  &:hover {\n    color: var(--shade-700);\n    background: var(--shade-300);\n  }\n  svg {\n    position: relative;\n    top: 0.25em;\n    font-size: 1.33em;\n    line-height: 1em;\n  }\n`\n","import { clsx } from \"clsx\"\nimport { Dispatch, SetStateAction, useCallback } from \"react\"\nimport { Transforms } from \"slate\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { useTooltip } from \"~/src/use-tooltip\"\n\nimport { $ImageButton } from \"../../../../styles/image-with-controls-styles/image-buttons-styles\"\nimport {\n  ImageBlockElement,\n  ImageInlineElement,\n  ImageSize,\n  ImageSizePreset,\n} from \"../../../../types\"\nimport { resizeInPreset } from \"../../../../utils\"\n\n/**\n * Shows a single preset image sizes as defined by the `Preset` type.\n *\n * If the srcSize is smaller than the preset, clicking the preset would do\n * nothing except show the image at its full size. For this reason, the\n * preset is disabled if the srcSize is smaller than the preset.\n */\nexport function ImagePresetButton({\n  element,\n  preset,\n  size,\n  setSize,\n  srcSize,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n  preset: ImageSizePreset\n  size: ImageSize\n  setSize: Dispatch<SetStateAction<ImageSize | null>>\n  srcSize: ImageSize\n}) {\n  const editor = useSlateStatic()\n  const presetSize = resizeInPreset(size, srcSize, preset)\n  const tooltip = useTooltip({\n    title: preset.title,\n    hotkey: `${presetSize.width}x${presetSize.height}`,\n  })\n\n  const onClick = useCallback(() => {\n    const path = ReactEditor.findPath(editor, element)\n    const nextSize = resizeInPreset(size, srcSize, preset)\n    setSize(nextSize)\n    Transforms.setNodes(editor, nextSize, { at: path })\n  }, [element, preset, size, srcSize])\n\n  const isEnabled =\n    preset.type === \"scale\"\n      ? true\n      : preset.width <= srcSize.width || preset.height <= srcSize.height\n\n  const isDisabled = !isEnabled\n\n  const isSelected =\n    size.width === presetSize.width && size.height === presetSize.height\n\n  const className = clsx({\n    \"--disabled\": isDisabled,\n    \"--selected\": !isDisabled && isSelected,\n  })\n\n  return (\n    <$ImageButton\n      className={className}\n      onClick={isDisabled ? undefined : onClick}\n      onMouseEnter={tooltip.onMouseEnter}\n      onMouseLeave={tooltip.onMouseLeave}\n    >\n      {preset.name}\n    </$ImageButton>\n  )\n}\n","import { $ImageButtonGroup } from \"../../../../styles/image-with-controls-styles/image-buttons-styles\"\nimport { ImageBlockElement, ImageInlineElement } from \"../../../../types\"\nimport { BlockImageTypeButton } from \"./block-image-type-button\"\nimport { InlineImageTypeButton } from \"./inline-image-type-button\"\n\nexport function ImageTypeButtonGroup({\n  element,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n}) {\n  return (\n    <$ImageButtonGroup>\n      <InlineImageTypeButton element={element} />\n      <BlockImageTypeButton element={element} />\n    </$ImageButtonGroup>\n  )\n}\n","import { useCallback } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { useTooltip } from \"~/src/use-tooltip\"\n\nimport { $ImageButton } from \"../../../../styles/image-with-controls-styles/image-buttons-styles\"\nimport { ImageBlockElement, ImageInlineElement } from \"../../../../types\"\nimport { InlineIcon } from \"../../../icons\"\nimport { convertToInlineImage } from \"./convert-to-inline-image\"\n\nexport function BlockImageTypeButton({\n  element,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n}) {\n  const editor = useSlateStatic()\n  const tooltip = useTooltip({\n    title: \"Inline Image\",\n    hotkey: \"In a line with text\",\n  })\n\n  const onClickInline = useCallback(() => {\n    if (element.type !== \"image-block\") return\n    convertToInlineImage(editor, element)\n  }, [editor, element])\n  return (\n    <$ImageButton\n      className={element.type === \"image-inline\" ? \"--selected\" : \"\"}\n      onClick={element.type === \"image-inline\" ? undefined : onClickInline}\n      onMouseEnter={tooltip.onMouseEnter}\n      onMouseLeave={tooltip.onMouseLeave}\n    >\n      <InlineIcon />\n    </$ImageButton>\n  )\n}\n","import { SVGProps } from \"react\"\n\nimport { TablerIcon } from \"~/src/sink\"\n\nexport const ResizeIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <path d=\"m7 8-4 4 4 4M17 8l4 4-4 4M3 12h18\" />\n  </TablerIcon>\n)\n\nexport const BlockIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <rect width={6} height={6} x={4} y={5} rx={1} />\n    <path d=\"M4 15h16M4 19h16\" />\n  </TablerIcon>\n)\n\nexport const InlineIcon = (props: SVGProps<SVGSVGElement>) => (\n  <TablerIcon {...props}>\n    <rect width={6} height={6} x={9} y={5} rx={1} />\n    <path d=\"M4 7h1M4 11h1M19 7h1M19 11h1M4 15h16M4 19h16\" />\n  </TablerIcon>\n)\n","import { Editor, Transforms } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { ImageBlockElement } from \"../../../../types\"\nimport { resizeInPreset } from \"../../../../utils\"\n\nexport function convertToInlineImage(\n  editor: Editor,\n  element: ImageBlockElement\n) {\n  /**\n   * TODO:\n   *\n   * This should be handled or thought about better. Like maybe if these\n   * values don't exist, we still change the type.\n   */\n  if (\n    !element.width ||\n    !element.height ||\n    !element.srcWidth ||\n    !element.srcHeight\n  )\n    return\n  const size = { width: element.width, height: element.height }\n  const srcSize = { width: element.srcWidth, height: element.srcHeight }\n  const path = ReactEditor.findPath(editor, element)\n  Editor.withoutNormalizing(editor, () => {\n    /**\n     * TODO:\n     *\n     * `resizeInPreset` should probably be renamed to something like\n     * `resizeIn` which can be used more generically. Perhaps it takes the\n     * `type`, `width` and `height` as an Interface making it compatible with\n     * a Preset which would extend it.\n     */\n    const nextSize = resizeInPreset(size, srcSize, {\n      name: \"initial-inline-image\",\n      title: \"\",\n      type: \"bounds\",\n      width: 24,\n      height: 24,\n    })\n    Transforms.setNodes(\n      editor,\n      { type: \"image-inline\", ...nextSize },\n      { at: path }\n    )\n    Transforms.wrapNodes(\n      editor,\n      { type: \"paragraph\", children: [] },\n      { at: path }\n    )\n  })\n}\n","import { useCallback } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { useTooltip } from \"~/src/use-tooltip\"\n\nimport { $ImageButton } from \"../../../../styles/image-with-controls-styles/image-buttons-styles\"\nimport { ImageBlockElement, ImageInlineElement } from \"../../../../types\"\nimport { BlockIcon } from \"../../../icons\"\nimport { convertToBlockImage } from \"./convert-to-block-image\"\n\nexport function InlineImageTypeButton({\n  element,\n}: {\n  element: ImageBlockElement | ImageInlineElement\n}) {\n  const editor = useSlateStatic()\n  const tooltip = useTooltip({\n    title: \"Block Image\",\n    hotkey: \"On a line by itself\",\n  })\n\n  const onClickBlock = useCallback(() => {\n    if (element.type !== \"image-inline\") return\n    convertToBlockImage(editor, element)\n  }, [editor, element])\n\n  return (\n    <$ImageButton\n      className={element.type === \"image-block\" ? \"--selected\" : \"\"}\n      onClick={element.type === \"image-block\" ? undefined : onClickBlock}\n      onMouseEnter={tooltip.onMouseEnter}\n      onMouseLeave={tooltip.onMouseLeave}\n    >\n      <BlockIcon />\n    </$ImageButton>\n  )\n}\n","import { Editor, Text, Transforms } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { findElementUp } from \"../../../../../sink\"\nimport { ImageInlineElement } from \"../../../../types\"\nimport { resizeInPreset } from \"../../../../utils\"\n\nexport function convertToBlockImage(\n  editor: Editor,\n  element: ImageInlineElement\n) {\n  /**\n   * TODO:\n   *\n   * This should be handled or thought about better. Like maybe if these\n   * values don't exist, we still change the type.\n   */\n  if (\n    !element.width ||\n    !element.height ||\n    !element.srcWidth ||\n    !element.srcHeight\n  )\n    return\n  const size = { width: element.width, height: element.height }\n  const srcSize = { width: element.srcWidth, height: element.srcHeight }\n  const path = ReactEditor.findPath(editor, element)\n\n  Editor.withoutNormalizing(editor, () => {\n    /**\n     * TODO:\n     *\n     * `resizeInPreset` should probably be renamed to something like\n     * `resizeIn` which can be used more generically. Perhaps it takes the\n     * `type`, `width` and `height` as an Interface making it compatible with\n     * a Preset which would extend it.\n     */\n    const nextSize = resizeInPreset(size, srcSize, {\n      name: \"initial-block-image\",\n      title: \"\",\n      type: \"bounds\",\n      width: 320,\n      height: 320,\n    })\n    /**\n     * Convert the inline image to a block image.\n     *\n     * When we make this change, it causes the normalization rules to change\n     * from the rules of an inline to the rules of a block. Inlines can only\n     * co-exist with Text and other Inline elments. They must also always be\n     * followed by and preceded by a Text nod.\n     *\n     * Some of the code below help to fix the inconsistencies caused by this\n     * change.\n     */\n    Transforms.setNodes(\n      editor,\n      { type: \"image-block\", ...nextSize },\n      { at: path }\n    )\n    /**\n     * Here we find the enclosing parent block for the inline.\n     *\n     * Note that there should always be a parent block for an inline. If there\n     * isn't, something isn't working properly because the Slate normalization\n     * rules require a block parent to an inline.\n     */\n    const parentEntry = findElementUp(\n      editor,\n      (node) => Editor.isBlock(editor, node) && node.type !== \"image-block\"\n    )\n    if (!parentEntry) throw new Error(\"This shouldn't happen\")\n    const [parentElement, parentPath] = parentEntry\n    const siblings = parentElement.children\n    const siblingCount = parentElement.children.length\n    const index = path.slice(-1)[0]\n\n    /**\n     * Before we lift the inline node, we want to remove **empty** Text blocks\n     * at the beginning of the block when the inline node is the second item\n     * and at the end of the block when the inline is the second to last item.\n     *\n     * We do this because Slate adds empty text nodes always at the beginning\n     * and end of a line if the node next to it is an inline. This behavior\n     * works fine in most cases, but when we want to lift the inline element\n     * up, Slate sees that there is content next to it and when the element is\n     * lifted up, the block is split into 3 pieces, including a piece with an\n     * empty Text node.\n     *\n     * From a user expectation point of view though, we don't want these extra\n     * blocks inserted. If the inline image is at the end of the line, we want\n     * it converted to a block image with a block of stuff before it. There is\n     * no use for the extra block at the end with no content in it.\n     */\n    /**\n     * Remove the last sibling if it's empty and next to the inline image\n     */\n    const lastSibling = siblings[siblingCount - 1]\n    if (\n      index === siblingCount - 2 &&\n      Text.isText(lastSibling) &&\n      lastSibling.text === \"\"\n    ) {\n      Transforms.removeNodes(editor, {\n        at: [...parentPath, siblingCount - 1],\n      })\n    }\n    /**\n     * Remove the first sibling if it's empty and next to the inline image\n     */\n    const firstSibling = siblings[0]\n    const removeFirstSibling =\n      index === 1 && Text.isText(firstSibling) && firstSibling.text === \"\"\n    if (removeFirstSibling) {\n      Transforms.removeNodes(editor, { at: [...parentPath, 0] })\n    }\n    /**\n     * Now lift the node, but if the first sibling was removed, we need to account fo rthe fact that the index of the image changed.\n     */\n    Transforms.liftNodes(editor, {\n      at: [...parentPath, removeFirstSibling ? index - 1 : index],\n    })\n  })\n}\n","import { useSlateStatic } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { $ImageInline } from \"../styles/image-inline-styles\"\nimport { ImageInlineElement } from \"../types\"\nimport { ImageWithControls } from \"./image-with-controls\"\n\nexport function ImageInline({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<ImageInlineElement>) {\n  const editor = useSlateStatic()\n  return (\n    <span {...attributes} style={{ display: \"inline-block\" }}>\n      <$ImageInline contentEditable={false}>\n        <ImageWithControls\n          element={element}\n          presets={editor.image.imageInlinePresets}\n        />\n      </$ImageInline>\n      {children}\n    </span>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $ImageInline = styled(\"span\")`\n  display: inline;\n`\n","import { createHotkeyHandler, createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { $InlineCode, $InvisibleSpan } from \"./styles\"\nimport { InlineCodePluginCustomTypes } from \"./types\"\nexport * from \"./styles\"\nexport * from \"./types\"\n\nexport const InlineCodePlugin = createPlugin<InlineCodePluginCustomTypes>(\n  (editor) => {\n    if (!editor.marksPlugin)\n      throw new Error(\n        \"InlineCodePlugin has a dependency on the MarksPlugin but the MarksPlugin has not been added or is added after the InlineCodePlugin\"\n      )\n    editor.inlineCode = {\n      toggleInlineCode: () => editor.marksPlugin.toggleMark(\"code\"),\n    }\n    return {\n      name: \"inline-code\",\n      editableProps: {\n        renderLeaf: ({ leaf, children }) => {\n          if (leaf.code) {\n            return (\n              /**\n               * Disable spellCheck because it's computer code usually.\n               */\n              <$InlineCode spellCheck={false}>\n                {/* These invisible spans are necessary. See comments for $InvisibleSpan. */}\n                <$InvisibleSpan contentEditable={false}>|</$InvisibleSpan>\n                {children}\n                {/* These invisible spans are necessary. See comments for $InvisibleSpan. */}\n                <$InvisibleSpan contentEditable={false}>|</$InvisibleSpan>\n              </$InlineCode>\n            )\n          } else {\n            return children\n          }\n        },\n        onKeyDown: createHotkeyHandler({\n          \"mod+j\": () => editor.inlineCode.toggleInlineCode(),\n        }),\n      },\n    }\n  }\n) as TypedPlugin<InlineCodePluginCustomTypes>\n","import styled from \"@emotion/styled\"\n\nexport const $InlineCode = styled(\"code\")`\n  color: var(--shade-600);\n  background-color: var(--inline-code-bgcolor);\n  border: 1px solid var(--inline-code-border-color);\n  border-radius: 0.25em;\n  padding: 0.1375em 0.125em;\n  /**\n   * Font Stack from\n   * https://qwtel.com/posts/software/the-monospaced-system-ui-css-font-stack/\n   */\n  font-family: ui-monospace, Menlo, Monaco, \"Cascadia Mono\", \"Segoe UI Mono\",\n    \"Roboto Mono\", \"Oxygen Mono\", \"Ubuntu Monospace\", \"Source Code Pro\",\n    \"Fira Mono\", \"Droid Sans Mono\", \"Courier New\", monospace;\n  /**\n   * This font size may seem smaller but any larger (including 0.875) means that\n   * it messes up the line height of the normal text. Not sure why this happens\n   * with the monospace font but seems to happen on both the default 'monospace'\n   * font as well as the font stack above.\n   */\n  font-size: 0.75em;\n  vertical-align: baseline;\n`\n\n/**\n * These invisible spans fix a bug in Chrome which doesn't allow the cursor to\n * sit on both the \"inside\" and \"outside\" of the inline-code span. By placing\n * this 1px wide span just inside of the inline code, we are able to workaround\n * this limitation.\n */\nexport const $InvisibleSpan = styled(\"span\")`\n  display: inline-block;\n  opacity: 0;\n  width: 1px;\n  overflow: hidden;\n`\n","export type InlineCodeEditor = {\n  inlineCode: {\n    toggleInlineCode: () => void\n  }\n}\n\nexport type InlineCodeText = {\n  text: string\n  code?: true\n}\n\nexport type InlineCodePluginCustomTypes = {\n  Name: \"inline-code\"\n  Editor: InlineCodeEditor\n  Text: InlineCodeText\n}\n","import { Editor, Path } from \"slate\"\n\nimport {\n  createHotkeyHandler,\n  createIsElementType,\n  createPlugin,\n  curryOne,\n  findElementUp,\n  isStartOfElement,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { createListMethods } from \"./methods\"\nimport { normalizeNode } from \"./normalize-node\"\nimport { renderElement } from \"./render-element\"\nimport { ListItemElement, ListPluginCustomTypes } from \"./types\"\n\nexport * from \"./types\"\n\nexport const LIST_ITEM_TYPES: ListItemElement[\"type\"][] = [\n  \"unordered-list-item\",\n  \"ordered-list-item\",\n  \"task-list-item\",\n]\n\nexport const isListItem = createIsElementType<ListItemElement>(LIST_ITEM_TYPES)\n\nexport const ListPlugin = createPlugin<ListPluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.convertElement.addConvertElementType(LIST_ITEM_TYPES)\n    const list = (editor.list = createListMethods(editor))\n    const hotkeyHandler = createHotkeyHandler({\n      tab: list.indent,\n      \"shift+tab\": list.outdent,\n      \"super+7\": curryOne(list.convertOrderedList, true),\n      \"super+8\": curryOne(list.convertUnorderedList, true),\n      \"super+9\": curryOne(list.convertTaskList, true),\n    })\n\n    return createPolicy({\n      name: \"list\",\n      editor: {\n        normalizeNode: (entry) => normalizeNode(editor, entry),\n        insertBreak: list.insertBreak,\n        deleteBackward: (unit) => {\n          /**\n           * This handles the logic where if the cursor is at the start of a\n           * list item, and the user presses backspace, then the list item\n           * should be converted to a paragraph if there are no list items\n           * before it. If there is a list item before it, then the normal\n           * delete behavior which would merge the list items together will\n           * occur.\n           */\n          if (unit !== \"character\") return false\n          if (!isStartOfElement(editor, isListItem)) return false\n          const listItem = findElementUp<ListItemElement>(editor, isListItem)\n          if (!listItem) return false\n          const listItemPath = listItem[1]\n          /**\n           * If the current list item is the first element in the document,\n           * convert it to a paragraph.\n           */\n          if (!Path.hasPrevious(listItemPath)) {\n            editor.collapsibleParagraph.convertParagraph()\n            return true\n          }\n          const prevElementPath = Path.previous(listItemPath)\n          const prevElementEntry = Editor.node(editor, prevElementPath)\n          if (isListItem(prevElementEntry[0])) return false\n          /**\n           * If the previous element is not a list item, then convert the\n           * current list item to a paragraph.\n           */\n          editor.collapsibleParagraph.convertParagraph()\n          return true\n        },\n      },\n      editableProps: {\n        renderElement,\n        onKeyDown(e) {\n          if (!Editor.nodes(editor, { match: isListItem })) return false\n          return hotkeyHandler(e)\n        },\n      },\n    })\n  }\n) as TypedPlugin<ListPluginCustomTypes>\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport {\n  convertOrderedList,\n  convertTaskList,\n  convertUnorderedList,\n} from \"./convert-list-item\"\nimport { indent } from \"./indent\"\nimport { insertBreak } from \"./insert-break\"\nimport { outdent } from \"./outdent\"\nimport { toggleTaskListItem } from \"./toggleTaskListItem\"\n\nexport function createListMethods(editor: Editor) {\n  return {\n    indent: curryOne(indent, editor),\n    outdent: curryOne(outdent, editor),\n    convertUnorderedList: curryOne(convertUnorderedList, editor),\n    convertOrderedList: curryOne(convertOrderedList, editor),\n    convertTaskList: curryOne(convertTaskList, editor),\n    insertBreak: curryOne(insertBreak, editor),\n    toggleTaskListItem: curryOne(toggleTaskListItem, editor),\n  }\n}\n","import { Editor } from \"slate\"\n\nimport {\n  OrderedListItemElement,\n  TaskListItemElement,\n  UnorderedListItemElement,\n} from \"..\"\n\nexport function convertOrderedList(editor: Editor, allowToggle: boolean) {\n  return editor.convertElement.convertElements<OrderedListItemElement>(\n    (element) => element.type === \"ordered-list-item\",\n    (element) => {\n      return {\n        type: \"ordered-list-item\",\n        depth: \"depth\" in element ? element.depth : 0,\n      }\n    },\n    allowToggle\n  )\n}\n\nexport function convertTaskList(editor: Editor, allowToggle: boolean) {\n  return editor.convertElement.convertElements<TaskListItemElement>(\n    (element) => element.type === \"task-list-item\",\n    (element) => {\n      return {\n        type: \"task-list-item\",\n        checked: \"checked\" in element ? element.checked : false,\n        depth: \"depth\" in element ? element.depth : 0,\n      }\n    },\n    allowToggle\n  )\n}\n\nexport function convertUnorderedList(editor: Editor, allowToggle: boolean) {\n  return editor.convertElement.convertElements<UnorderedListItemElement>(\n    (element) => element.type === \"unordered-list-item\",\n    (element) => {\n      return {\n        type: \"unordered-list-item\",\n        depth: \"depth\" in element ? element.depth : 0,\n      }\n    },\n    allowToggle\n  )\n}\n","import { Editor } from \"slate\"\n\nimport { setNodesDynamic } from \"~/src/sink\"\n\nimport { isListItem, ListItemElement } from \"..\"\n\nexport function indent(editor: Editor) {\n  return setNodesDynamic<ListItemElement>(\n    editor,\n    (node) => ({ depth: node.depth + 1 }),\n    {\n      match: isListItem,\n    }\n  )\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { findElementUp, rewrapElement } from \"~/src/sink\"\n\nimport { isListItem } from \"..\"\nimport { ListItemElement } from \"../types\"\n\nexport function insertBreak(editor: Editor): boolean {\n  const entry = findElementUp<ListItemElement>(editor, isListItem)\n  if (!entry) return false\n  const [element, path] = entry\n\n  /**\n   * If we're in an empty list\n   */\n  if (Editor.isEmpty(editor, element)) {\n    if (element.depth > 0) {\n      /**\n       * If it's indented, then unindent it\n       */\n      Transforms.setNodes(editor, { depth: element.depth - 1 }, { at: path })\n      return true\n    } else {\n      /**\n       * If it's fully unindented, turn it into a paragraph\n       */\n      rewrapElement(editor, { type: \"paragraph\" }, path)\n      return true\n    }\n  }\n  /**\n   * Otherwise perform default insertBreak transform\n   */\n  Transforms.splitNodes(editor, { always: true })\n  /**\n   * Then find the list item we are now in\n   */\n  const nextEntry = findElementUp<ListItemElement>(editor, isListItem)\n  if (!nextEntry) return true\n  /**\n   * And if it's a checked task list that is checked, we want to uncheck it.\n   * New list items are by default always unchecked.\n   */\n  if (nextEntry[0].type === \"task-list-item\" && nextEntry[0].checked === true) {\n    Transforms.setNodes(editor, { checked: false }, { at: nextEntry[1] })\n  }\n  return true\n}\n","import { Editor } from \"slate\"\n\nimport { setNodesDynamic } from \"~/src/sink\"\n\nimport { isListItem, ListItemElement } from \"..\"\n\nexport function outdent(editor: Editor): boolean {\n  const entries = Array.from(\n    Editor.nodes<ListItemElement>(editor, {\n      match: isListItem,\n    })\n  )\n  /**\n   * Don't allow `shift+tab` if any of the list items are already at a\n   * depth of `0`\n   */\n  for (const entry of entries) {\n    if (entry[0].depth === 0) return true\n  }\n  return setNodesDynamic<ListItemElement>(\n    editor,\n    (node) => ({ depth: Math.max(0, node.depth - 1) }),\n    {\n      match: isListItem,\n    }\n  )\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt, findElementUp } from \"~/src/sink\"\n\nimport { TaskListItemElement } from \"../types\"\n\nexport function toggleTaskListItem(\n  editor: Editor,\n  { at = editor.selection }: { at?: BetterAt } = {}\n) {\n  const taskListItem = findElementUp<TaskListItemElement>(\n    editor,\n    \"task-list-item\",\n    { at }\n  )\n  if (!taskListItem) return false\n  const nextChecked = !taskListItem[0].checked\n  Transforms.setNodes<TaskListItemElement>(\n    editor,\n    { checked: nextChecked },\n    { at: taskListItem[1] }\n  )\n}\n","import { Editor, Node, NodeEntry } from \"slate\"\n\nimport { isListItem } from \"..\"\nimport { normalizeOrderedFirstAtDepth } from \"./normalize-ordered-first-at-depth\"\nexport * from \"./normalize-ordered-first-at-depth\"\n\nexport function normalizeNode(editor: Editor, entry: NodeEntry<Node>): boolean {\n  const [node] = entry\n  /**\n   * Short circuit return if current entry isn't any type of list item element.\n   */\n  if (!isListItem(node)) return false\n  return normalizeOrderedFirstAtDepth(editor, entry)\n}\n","import { Editor, Element, Node, NodeEntry, Transforms } from \"slate\"\n\nimport { createIsElementType, normalizeSiblings } from \"~/src/sink\"\n\nimport { OrderedListItemElement } from \"..\"\n\nconst isOrderedListItem = createIsElementType<OrderedListItemElement>([\n  \"ordered-list-item\",\n])\n\n/**\n * Makes sure that when a list item is deeper than a preceding one, that we\n * reset the counter.\n *\n * How it works:\n *\n * If we have any two list item siblings where the second sibling is an\n * `ordered-list-item`, then the second sibling should have the property\n * `_firstOfType` be `true` if the depth of the second sibling is higher or\n * the previous sibling is not an ordered list item (e.g. a paragraph or a\n * bullet)\n *\n * Why we need it:\n *\n * We need to do this manually because our implementation of lists does not\n * actually nest lists within lists. We took the approach because the cost\n * of actually nesting lists is very high in terms of added complexity. It is\n * much easier to manually reset the counters than it is to implement\n * everything to W3C specifications, especially given that from a UI\n * perspective, users expect lists to behave similar to paragraphs and\n * headings.\n */\n\nexport function normalizeOrderedFirstAtDepth(\n  editor: Editor,\n  entry: NodeEntry<Node>\n): boolean {\n  const [node, path] = entry\n  if (!Element.isElement(node)) return false\n  return normalizeSiblings<Element>(editor, [node, path], (a, b) => {\n    /**\n     * If the second item (the item we are actually looking at) is not an\n     * ordered list item, then we aren't interested.\n     */\n    if (!isOrderedListItem(b[0])) return false\n    /**\n     * The second item is an ordered-list-item. If the item before it is not\n     * or the second item is deeper than the first, then we want to set\n     * `__firstAtDepth` to `true`.\n     */\n    const __firstAtDepth = !isOrderedListItem(a[0]) || b[0].depth > a[0].depth\n    /**\n     * Check if the setting is already correct.\n     */\n    if (b[0].__firstAtDepth !== __firstAtDepth) {\n      Transforms.setNodes(editor, { __firstAtDepth }, { at: b[1] })\n      return true\n    }\n    return false\n  })\n}\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { ListItemElement } from \"../types\"\nimport { OrderedListItem } from \"./ordered-list-item\"\nimport { TaskListItem } from \"./task-list-item\"\nimport { UnorderedListItem } from \"./unordered-list-item\"\n\nexport function renderElement({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<ListItemElement>) {\n  switch (element.type) {\n    case \"ordered-list-item\":\n      return (\n        <OrderedListItem element={element} attributes={attributes}>\n          {children}\n        </OrderedListItem>\n      )\n    case \"unordered-list-item\":\n      return (\n        <UnorderedListItem element={element} attributes={attributes}>\n          {children}\n        </UnorderedListItem>\n      )\n    case \"task-list-item\":\n      return (\n        <TaskListItem element={element} attributes={attributes}>\n          {children}\n        </TaskListItem>\n      )\n  }\n}\n","import { clsx } from \"clsx\"\nimport { useEffect } from \"react\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { normalizeOrderedFirstAtDepth } from \"../normalize-node\"\nimport { OrderedListItemElement as OrderedListItemElement } from \"../types\"\nimport { $OrderedListItem } from \"./styles\"\n\nexport function OrderedListItem({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<OrderedListItemElement>) {\n  const editor = useSlateStatic()\n  useEffect(() => {\n    const path = ReactEditor.findPath(editor, element)\n    normalizeOrderedFirstAtDepth(editor, [element, path])\n  }, [])\n  const style = {\n    \"--list-item-depth\": element.depth,\n    \"--list-item-var\": `list-item-depth-${element.depth}`,\n  } as React.CSSProperties\n  const className = clsx({ \"--first-at-depth\": element.__firstAtDepth })\n  return (\n    <$OrderedListItem {...attributes} className={className} style={style}>\n      {children}\n    </$OrderedListItem>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nimport { isDebug } from \"~/src/sink\"\n\nconst $ListItem = styled(\"li\")`\n  margin-top: 0.5em;\n  margin-bottom: 0.5em;\n  list-style-position: outside;\n  margin-left: calc(2em + var(--list-item-depth) * 2em);\n`\n\nexport const $UnorderedListItem = styled($ListItem)`\n  position: relative;\n  list-style-type: none;\n  .--list-item-icon {\n    position: absolute;\n    top: 0.25em;\n    left: -1.375em;\n    line-height: 1.5em;\n    color: var(--shade-600);\n  }\n`\n\nexport const $OrderedListItem = styled($ListItem)`\n  position: relative;\n  list-style-type: none;\n  counter-increment: var(--list-item-var);\n\n  &.--first-at-depth {\n    counter-reset: var(--list-item-var);\n    /**\n     * if isDebug is true, then show a highlight on list items that are marked\n     * as the first at a given depth.\n     */\n    background: ${isDebug ? \"rgba(0, 255, 0, 0.2)\" : \"inherit\"};\n  }\n\n  &:before {\n    position: absolute;\n    content: counter(var(--list-item-var)) \".\";\n    top: 0;\n    left: -2em;\n    width: 1.5em;\n    text-align: right;\n    color: var(--shade-500);\n    /* force numbers to be monospaced for better alignment */\n    font-variant-numeric: tabular-nums;\n  }\n`\n\nexport const $TaskListItem = styled($ListItem)`\n  position: relative;\n  list-style-type: none;\n  .--list-item-icon {\n    position: absolute;\n    top: 0.25em;\n    left: -1.5em;\n    line-height: 1.5em;\n    color: var(--shade-300);\n    .--checkmark {\n      color: green;\n      stroke-width: 3px;\n    }\n  }\n`\n","import { useCallback } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { TaskListItemElement } from \"../types\"\nimport { CheckedIcon, UncheckedIcon } from \"./list-icons\"\nimport { $TaskListItem } from \"./styles\"\n\nexport function TaskListItem({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<TaskListItemElement>) {\n  const editor = useSlateStatic()\n  const toggle = useCallback(() => {\n    editor.list.toggleTaskListItem({ at: element })\n  }, [editor, element])\n\n  const style = { \"--list-item-depth\": element.depth } as React.CSSProperties\n  return (\n    <$TaskListItem {...attributes} style={style}>\n      <div className=\"--list-item-icon\" contentEditable={false}>\n        {element.checked ? (\n          <CheckedIcon onClick={toggle} style={{ cursor: \"pointer\" }} />\n        ) : (\n          <UncheckedIcon onClick={toggle} style={{ cursor: \"pointer\" }} />\n        )}\n      </div>\n      {children}\n    </$TaskListItem>\n  )\n}\n","import * as React from \"react\"\nimport { SVGProps } from \"react\"\n\n/**\n * https://tabler-icons.io/\n */\nexport const UncheckedIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"1em\"\n    height=\"1em\"\n    strokeWidth={2}\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    viewBox=\"0 0 24 24\"\n    {...props}\n  >\n    <path d=\"M0 0h24v24H0z\" stroke=\"none\" />\n    <rect x={4} y={4} width={16} height={16} rx={2} />\n  </svg>\n)\n\n/**\n * https://tabler-icons.io/\n */\nexport const CheckedIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    className=\"icon icon-tabler icon-tabler-checkbox\"\n    width=\"1em\"\n    height=\"1em\"\n    strokeWidth={2}\n    stroke=\"currentColor\"\n    fill=\"none\"\n    strokeLinecap=\"round\"\n    strokeLinejoin=\"round\"\n    viewBox=\"0 0 24 24\"\n    {...props}\n  >\n    <path d=\"M0 0h24v24H0z\" stroke=\"none\" />\n    <path d=\"m9 11 3 3 8-8\" className=\"--checkmark\" />\n    <path d=\"M20 12v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h9\" />\n  </svg>\n)\n\n/**\n * Modified viewfinder-circle from https://heroicons.com/\n */\nexport const BulletIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 24 24\"\n    fill=\"currentColor\"\n    width=\"1em\"\n    height=\"1em\"\n    {...props}\n  >\n    <path d=\"M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5z\" />\n  </svg>\n)\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { UnorderedListItemElement } from \"../types\"\nimport { BulletIcon } from \"./list-icons\"\nimport { $UnorderedListItem } from \"./styles\"\n\nexport function UnorderedListItem({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<UnorderedListItemElement>) {\n  const style = { \"--list-item-depth\": element.depth } as React.CSSProperties\n  return (\n    <$UnorderedListItem {...attributes} style={style}>\n      <div className=\"--list-item-icon\" contentEditable={false}>\n        <BulletIcon />\n      </div>\n      {children}\n    </$UnorderedListItem>\n  )\n}\n","import { Descendant } from \"slate\"\n\nimport { createListMethods } from \"./methods\"\n\n/**\n * List Editor\n */\n\nexport type ListEditor = {\n  list: ReturnType<typeof createListMethods>\n}\n\n/**\n * Ordered List Item Element\n */\n\nexport type OrderedListItemElement = {\n  type: \"ordered-list-item\"\n  depth: number\n  __firstAtDepth?: boolean // used internally to reset counters\n  children: Descendant[]\n}\n\n/**\n * Unordered List Item Element\n */\n\nexport type UnorderedListItemElement = {\n  type: \"unordered-list-item\"\n  depth: number\n  __firstAtDepth?: boolean // used internally to reset counters\n  children: Descendant[]\n}\n\n/**\n * Checkable Task List Item Element\n */\n\nexport type TaskListItemElement = {\n  type: \"task-list-item\"\n  depth: number\n  __firstAtDepth?: boolean // used internally to reset counters\n  checked: boolean\n  children: Descendant[]\n}\n\n/**\n * Any List Item Element\n */\n\nexport type ListItemElement =\n  | OrderedListItemElement\n  | UnorderedListItemElement\n  | TaskListItemElement\n\n/**\n * List Plugins Custom Types\n */\n\nexport type ListPluginCustomTypes = {\n  Name: \"list\"\n  Editor: ListEditor\n  Element:\n    | OrderedListItemElement\n    | UnorderedListItemElement\n    | TaskListItemElement\n}\n","import { clsx } from \"clsx\"\n\nimport {\n  createHotkeyHandler,\n  createPlugin,\n  curryOne,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { insertText } from \"./editor/insert-text\"\nimport { createMarksMethods } from \"./methods\"\nimport { $MarksSpan } from \"./styles\"\n\nexport type MarksEditor = {\n  /**\n   * IMPORTANT:\n   *\n   * This cannot be named `marks` because it conflicts with the `editor.marks`\n   * built into the BaseEditor.j\n   */\n  marksPlugin: ReturnType<typeof createMarksMethods>\n}\n\nexport type MarksText = {\n  text: string\n  bold?: true\n  italic?: true\n  underline?: true\n  sup?: true\n  sub?: true\n  strike?: true\n}\n\nexport type MarksPluginCustomTypes = {\n  Name: \"marks\"\n  Editor: MarksEditor\n  Text: MarksText\n}\n\nexport const MarksPlugin = createPlugin<MarksPluginCustomTypes>((editor) => {\n  editor.marksPlugin = createMarksMethods(editor)\n  const hotkeyHandler = createHotkeyHandler({\n    \"mod+b\": editor.marksPlugin.toggleBold,\n    \"mod+i\": editor.marksPlugin.toggleItalic,\n    \"mod+u\": editor.marksPlugin.toggleUnderline,\n    \"super+0\": editor.marksPlugin.removeMarks,\n    \"super+b\": editor.marksPlugin.toggleSub,\n    \"super+k\": editor.marksPlugin.toggleStrike,\n    \"super+p\": editor.marksPlugin.toggleSup,\n  })\n  return {\n    name: \"marks\",\n    editor: {\n      insertText: curryOne(insertText, editor),\n    },\n    editableProps: {\n      renderLeaf: ({ leaf, children }) => {\n        return (\n          <$MarksSpan\n            className={clsx({\n              \"--bold\": leaf.bold,\n              \"--italic\": leaf.italic,\n              \"--underline\": leaf.underline,\n              \"--sup\": leaf.sup,\n              \"--sub\": leaf.sub,\n              \"--strike\": leaf.strike,\n            })}\n          >\n            {children}\n          </$MarksSpan>\n        )\n      },\n      onKeyDown: (e) => {\n        if (hotkeyHandler(e)) return true\n        // if (\n        //   autocompleteMarker(editor, e, {\n        //     triggerMarker: \"`\",\n        //     regexp: /([`])(\\S.*?)([`])$/,\n        //     mark: \"code\",\n        //   })\n        // ) {\n        //   return true\n        // }\n        // if (\n        //   autocompleteMarker(editor, e, {\n        //     triggerMarker: \"*\",\n        //     regexp: /([*])(.+?)([*])$/,\n        //     mark: \"italic\",\n        //   })\n        // ) {\n        //   return true\n        // }\n        return false\n      },\n    },\n  }\n}) as TypedPlugin<MarksPluginCustomTypes>\n\n// function autocompleteMarker(\n//   editor: Editor,\n//   e: React.KeyboardEvent<HTMLDivElement>,\n//   {\n//     triggerMarker,\n//     regexp,\n//     mark,\n//   }: { triggerMarker: string; regexp: RegExp; mark: keyof Text }\n// ): boolean {\n//   /**\n//    * Make sure theere is a selection and it's collapsed\n//    */\n//   console.log(\n//     { triggerMarker, mark },\n//     e.key,\n//     e.which,\n//     toKeyCode(\"*\"),\n//     toKeyName(\"*\"),\n//     isHotkey(\"*\", { byKey: true })(e.nativeEvent)\n//   )\n//   if (editor.selection === null) return false\n//   if (Range.isExpanded(editor.selection)) return false\n//   /**\n//    * WHAT I'M WORKING ON:\n//    *\n//    * So, basically, `is-hotkey` doesn't work with an asterisk. We need to find\n//    * an alternate way of testing but it's a little tricky and there are a few\n//    * approaches we can take:\n//    *\n//    * - The first approach is to write our own key checker, but be careful\n//    *   because we want to make sure we aren't interception hotkeys with modifier\n//    *   keys for example. Like CMD+OPTION+8 should not trigger the `*` trigger.\n//    *\n//    * - NOTE: tested and paste does not trigger insertText. The second approach\n//    *   is to tie into `insertText` instead. This may be a more reliable method\n//    *   but we also need to at least think about whether insertText gets\n//    *   triggered during a paste event, for example, and if it does, that would\n//    *   be weird to have that suddenly bold some text.\n//    *\n//    */\n//   // if (isHotkey(triggerMarker, e.nativeEvent)) {\n//   if (isHotkey(triggerMarker, e.nativeEvent)) {\n//     console.log(\"triggered\")\n//     stopEvent(e)\n//     const markerText = triggerMarker\n//     Transforms.insertText(editor, markerText)\n//     const { selection } = editor\n\n//     /**\n//      * Make sure we are in a block that is not void.\n//      */\n//     const blockEntry = findElementUp(\n//       editor,\n//       (node) =>\n//         Element.isElement(node) &&\n//         !Editor.isVoid(editor, node) &&\n//         Editor.isBlock(editor, node)\n//     )\n//     if (blockEntry == null) return true\n\n//     /**\n//      * Grab all the text from the beginning of the block until now\n//      */\n//     const range = {\n//       anchor: Editor.start(editor, blockEntry[1]),\n//       focus: selection.focus,\n//     }\n//     const text = Editor.string(editor, range)\n\n//     /**\n//      * See if the text matches our pattern\n//      */\n//     const match = text.match(regexp)\n//     if (match == null) return true\n//     if (match.length !== 4)\n//       throw new Error(\n//         `Expected the RegExp to have 3 grouped subexpressions but returned ${\n//           match.length - 1\n//         }`\n//       )\n\n//     /**\n//      * Delete the closing markers\n//      */\n//     const closingMarkersRange = getRangeBackwards(\n//       editor,\n//       editor.selection.focus,\n//       match[3].length\n//     )\n//     Transforms.delete(editor, { at: closingMarkersRange })\n\n//     /**\n//      * Delete the opening markers\n//      */\n//     const openingMarkersRange = getRangeBackwards(\n//       editor,\n//       editor.selection.focus,\n//       match[2].length + match[3].length,\n//       match[2].length\n//     )\n//     Transforms.delete(editor, { at: openingMarkersRange })\n\n//     /**\n//      * Create a range that represents the selected text\n//      */\n//     const matchRange = getRangeBackwards(\n//       editor,\n//       editor.selection.focus,\n//       match[2].length\n//     )\n\n//     /**\n//      * Feels like `withoutMerging` should work but if we undo twice after this,\n//      * causes a crash.\n//      *\n//      * This looks like a good solution that isn't in main\n//      * https://github.com/ianstormtaylor/slate/issues/3874\n//      *\n//      * NOTE:\n//      *\n//      * Manually calling `editor.onChange()` won't work\n//      *\n//      * An appropriate starting point for searching more in issues\n//      * https://github.com/ianstormtaylor/slate/issues?q=is%3Aissue+withoutMerging+is%3Aclosed\n//      */\n//     editor.marksPlugin.toggleMark(mark, undefined, { at: matchRange })\n\n//     return true\n//   }\n//   return false\n// }\n\n// function getRangeBackwards(\n//   editor: Editor,\n//   point: Point,\n//   startDistance: number,\n//   endDistance?: number\n// ) {\n//   const startPoint = Editor.before(editor, point, {\n//     unit: \"character\",\n//     distance: startDistance,\n//   })\n//   const endPoint =\n//     endDistance === undefined\n//       ? point\n//       : Editor.before(editor, point, {\n//           unit: \"character\",\n//           distance: endDistance,\n//         })\n//   if (!startPoint)\n//     throw new Error(\n//       `startPoint not found. The distance backward from the point may be invalid.`\n//     )\n//   if (!endPoint)\n//     throw new Error(\n//       `endPoint not found. The distance backward from the point may be invalid.`\n//     )\n//   return {\n//     anchor: startPoint,\n//     focus: endPoint,\n//   }\n// }\n","import { Editor } from \"slate\"\n\nimport { VoidActionReturn } from \"~/src/sink\"\n\nimport { autocompleteMark } from \"./autocomplete-mark\"\n\nexport function insertText(editor: Editor, text: string): VoidActionReturn {\n  return (\n    autocompleteMark(editor, text, {\n      triggerMarker: \"`\",\n      regexp: /([`])([^`]+)([`])$/,\n      mark: \"code\",\n    }) ||\n    autocompleteMark(editor, text, {\n      triggerMarker: \"*\",\n      regexp: /([*][*])([^*]+)([*][*])$/,\n      mark: \"bold\",\n    }) ||\n    autocompleteMark(editor, text, {\n      triggerMarker: \"~\",\n      regexp: /(~~)([^~]+)(~~)$/,\n      mark: \"bold\",\n    }) ||\n    autocompleteMark(editor, text, {\n      triggerMarker: \"*\",\n      regexp: /(?:[^*]|^)([*])([^*]+)([*])$/,\n      mark: \"italic\",\n    }) ||\n    autocompleteMark(editor, text, {\n      triggerMarker: \"~\",\n      regexp: /(?:[^~]|^)(~)([^~]+)(~)$/,\n      mark: \"italic\",\n    })\n  )\n}\n","import { Editor, Range, Text, Transforms } from \"slate\"\n\nimport { VoidActionReturn } from \"~/src/sink\"\n\nimport { getRangeBackwards } from \"./get-range-backwards\"\nimport { getTextBeforePointInBlock } from \"./get-text-before-point-in-block\"\n\nexport function autocompleteMark(\n  editor: Editor,\n  text: string,\n  {\n    triggerMarker,\n    regexp,\n    mark,\n  }: { triggerMarker: string; regexp: RegExp; mark: keyof Text }\n): VoidActionReturn {\n  if (editor.selection === null) return false\n  if (Range.isExpanded(editor.selection)) return false\n  if (text !== triggerMarker) return false\n\n  /**\n   * Grab all the text from the beginning of the block until now\n   */\n  const beforeInsertText = getTextBeforePointInBlock(\n    editor,\n    editor.selection.focus\n  )\n  const beforeText = `${beforeInsertText}${text}`\n  /**\n   * See if the text matches our pattern\n   */\n  const match = beforeText.match(regexp)\n  if (match == null) return false\n  if (match.length !== 4)\n    throw new Error(\n      `Expected the RegExp to have 3 grouped subexpressions but returned ${\n        match.length - 1\n      }`\n    )\n\n  /**\n   * This callback method we are returning gets executed after the text is\n   * inserted by the original `insertText` method.\n   */\n  return () => {\n    /**\n     * We are in the future now (after the insert happened) so we are\n     * revalidating that the selection is not null and that it is collapsed\n     */\n    if (editor.selection === null) return false\n    if (Range.isExpanded(editor.selection)) return false\n\n    /**\n     * Delete the closing markers\n     */\n    const closingMarkersRange = getRangeBackwards(\n      editor,\n      editor.selection.focus,\n      /**\n       * TODO:\n       *\n       * We should be using Slate's internal `getCharacterDistance` to generate\n       * a length but it is not exposed.\n       **/\n      match[3].length\n    )\n    Transforms.delete(editor, { at: closingMarkersRange })\n\n    /**\n     * Delete the opening markers\n     */\n    const openingMarkersRange = getRangeBackwards(\n      editor,\n      editor.selection.focus,\n      /**\n       * TODO:\n       *\n       * We should be using Slate's internal `getCharacterDistance` to generate\n       * a length but it is not exposed.\n       **/\n      match[2].length + match[3].length,\n      match[2].length\n    )\n    Transforms.delete(editor, { at: openingMarkersRange })\n\n    /**\n     * Create a range that represents the selected text\n     */\n    const matchRange = getRangeBackwards(\n      editor,\n      editor.selection.focus,\n      /**\n       * TODO:\n       *\n       * We should be using Slate's internal `getCharacterDistance` to generate\n       * a length but it is not exposed.\n       **/\n      match[2].length\n    )\n\n    /**\n     * Feels like `withoutMerging` should work but if we undo twice after this,\n     * causes a crash.\n     *\n     * This looks like a good solution that isn't in main\n     * https://github.com/ianstormtaylor/slate/issues/3874\n     *\n     * NOTE:\n     *\n     * Manually calling `editor.onChange()` won't work\n     *\n     * An appropriate starting point for searching more in issues\n     * https://github.com/ianstormtaylor/slate/issues?q=is%3Aissue+withoutMerging+is%3Aclosed\n     */\n    editor.marksPlugin.toggleMark(mark, undefined, { at: matchRange })\n\n    /**\n     * Turn off the mark afterewards so that when we close with a marker like\n     * `**` that the bold mark is turned off.\n     */\n    Editor.removeMark(editor, mark)\n  }\n}\n","import { Editor, Point } from \"slate\"\n\n/**\n * This utility function which is designed specifically to its usage in\n * `autocompleteMark` (and hence probably shouldn't be reused) takes a Point and\n * then two distances (second one is optional), measured in `character`, before\n * the Point.\n *\n * It then returns a range before the `startDistance` and the `endDistance`.\n *\n * TODO: BUG:\n *\n * Our `match` returns the distance in `bytes` and not `characters` so we get\n * the wrong offsets, for example, when bolding a Unicode Emoji.\n *\n * We should be using Slate's internal `getCharacterDistance` but it is not\n * exposed.\n */\nexport function getRangeBackwards(\n  editor: Editor,\n  point: Point,\n  startDistance: number,\n  endDistance?: number\n) {\n  const startPoint = Editor.before(editor, point, {\n    unit: \"character\",\n    distance: startDistance,\n  })\n  const endPoint =\n    endDistance === undefined\n      ? point\n      : Editor.before(editor, point, {\n          unit: \"character\",\n          distance: endDistance,\n        })\n  if (!startPoint)\n    throw new Error(\n      `startPoint not found. The distance backward from the point may be invalid.`\n    )\n  if (!endPoint)\n    throw new Error(\n      `endPoint not found. The distance backward from the point may be invalid.`\n    )\n  return {\n    anchor: startPoint,\n    focus: endPoint,\n  }\n}\n","import { Editor, Element, Point } from \"slate\"\n\nimport { findElementUp } from \"~/src/sink\"\n\n/**\n * Takes a Point anywhere in the editor and returns the text text in the current\n * block before that Point in the editor.\n *\n * If the Point happens not to be in a Block or that Block is a Void block (i.e.\n * in which the `children` are not defactor text/inlines) then this function\n * returns `null`\n *\n * For clarity, we return `null` which is more explicit than `undefined`.\n */\nexport function getTextBeforePointInBlock(\n  editor: Editor,\n  point: Point\n): string | null {\n  /**\n   * Make sure we are in a block and that the block is not void.\n   */\n  const blockEntry = findElementUp(\n    editor,\n    (node) =>\n      Element.isElement(node) &&\n      !Editor.isVoid(editor, node) &&\n      Editor.isBlock(editor, node)\n  )\n  if (blockEntry == null) return null\n  const range = {\n    anchor: Editor.start(editor, blockEntry[1]),\n    focus: point,\n  }\n  return Editor.string(editor, range)\n}\n","import { Editor } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { removeMarks } from \"./removeMarks\"\nimport { toggleMark } from \"./toggle-mark\"\n\nexport function createMarksMethods(editor: Editor) {\n  return {\n    removeMarks: curryOne(removeMarks, editor),\n    toggleMark: curryOne(toggleMark, editor),\n    toggleBold: () => toggleMark(editor, \"bold\"),\n    toggleItalic: () => toggleMark(editor, \"italic\"),\n    toggleUnderline: () => toggleMark(editor, \"underline\"),\n    toggleSup: () => toggleMark(editor, \"sup\", \"sub\"),\n    toggleSub: () => toggleMark(editor, \"sub\", \"sup\"),\n    toggleStrike: () => toggleMark(editor, \"strike\"),\n  }\n}\n","import { Editor, Location, Text, Transforms } from \"slate\"\n\n/**\n * Toggles a mark.\n *\n * Certain marks may not be able to co-exist with another mark. For example,\n * superscript and subscript cannot be applied at the same time. In these\n * cases, you can provide a final argument of `unsetKey` that when the mark\n * is toggled on, the `unsetKey` mark is toggled off automatically. When the\n * mark is toggled off, it will ignore the `unsetKey`\n */\n\nexport function removeMarks(\n  editor: Editor,\n  { at = editor.selection }: { at?: Location | null } = {}\n) {\n  if (at == null) return\n  const nodeEntries = [\n    ...Editor.nodes(editor, {\n      match: (n) => Text.isText(n),\n      at,\n    }),\n  ]\n  const setter: Record<string, null> = {}\n  for (const [node] of nodeEntries) {\n    for (const key of Object.keys(node)) {\n      if (key === \"text\") continue\n      setter[key] = null\n    }\n  }\n  Transforms.setNodes(editor, setter, {\n    match: (n) => Text.isText(n),\n    split: true,\n    at,\n  })\n}\n","import { Editor, Location, Text, Transforms } from \"slate\"\n\n/**\n * Toggles a mark.\n *\n * Certain marks may not be able to co-exist with another mark. For example,\n * superscript and subscript cannot be applied at the same time. In these\n * cases, you can provide a final argument of `unsetKey` that when the mark\n * is toggled on, the `unsetKey` mark is toggled off automatically. When the\n * mark is toggled off, it will ignore the `unsetKey`\n */\n\nexport function toggleMark(\n  editor: Editor,\n  markKey: keyof Text,\n  unsetKey?: keyof Text,\n  { at = editor.selection }: { at?: Location | null } = {}\n) {\n  if (at == null) return\n  const [match] = Editor.nodes(editor, {\n    match: (n) => Text.isText(n) && !!n[markKey],\n    at,\n  })\n  Transforms.setNodes(\n    editor,\n    { [markKey]: !match || null },\n    {\n      match: (n) => Text.isText(n),\n      split: true,\n      at,\n    }\n  )\n  if (typeof unsetKey === \"string\") {\n    Transforms.unsetNodes(editor, unsetKey, {\n      match: (n) => Text.isText(n),\n      split: true,\n      at,\n    })\n  }\n}\n","import styled from \"@emotion/styled\"\n\nexport const $MarksSpan = styled(\"span\")`\n  &.--bold {\n    font-weight: bold;\n  }\n  &.--italic {\n    font-style: italic;\n  }\n  &.--underline {\n    text-decoration: underline;\n  }\n  &.--sup {\n    vertical-align: super;\n    font-size: 0.75em;\n  }\n  &.--sub {\n    vertical-align: sub;\n    font-size: 0.75em;\n  }\n  &.--strike {\n    text-decoration: line-through;\n  }\n  /**\n   * Text decorations don't merge automatically so we make a special one\n   * when there is both an underline and a strike through.\n   */\n  &.--underline.--strike {\n    text-decoration: underline line-through;\n  }\n`\n","import { Editor, Point } from \"slate\"\n\nimport { createPlugin, forceNormalizePath, TypedPlugin } from \"~/src/sink\"\n\nexport type NormalizeAfterDeleteEditor = {\n  normalizeAfterDelete: true\n}\n\nexport type NormalizeAfterDeletePluginCustomTypes = {\n  Name: \"normalize-after-delete\"\n  Editor: NormalizeAfterDeleteEditor\n}\n\nfunction forceNormalizeNearestElement(editor: Editor) {\n  if (!editor.selection) return\n  const entry = Editor.parent(editor, editor.selection)\n  forceNormalizePath(editor, entry[1])\n}\n\n/**\n * The purpose of this plugin is to have the Slate normalizer execute when an\n * Element is deleted. When text is deleted, the normalizer executes properly\n * but if an entire element is deleted, Slate behaves as if no normalization\n * is required.\n *\n * This fails us in a few normalization scenarios:\n *\n * - The normalizer needs to run when a sibling (previous or next) changes.\n * - The normalizer needs to run when a child is removed\n *\n * The plugin takes a few steps to make things more efficient. Namely, it only\n * executes a normalization if we are deleting backwards and we are at the\n * start of an element, or deleting forwards and we are at the end of an\n * Element. If neither of these are true, the delete will cause a normalzation\n * on its own because the text will have changed.\n */\nexport const NormalizeAfterDeletePlugin =\n  createPlugin<NormalizeAfterDeletePluginCustomTypes>((editor) => {\n    editor.normalizeAfterDelete = true\n    return {\n      name: \"normalize-after-delete\",\n      editor: {\n        deleteBackward() {\n          if (!editor.selection) return false\n          const entry = Editor.parent(editor, editor.selection)\n          const isStart = Point.equals(\n            Editor.start(editor, entry[1]),\n            editor.selection.anchor\n          )\n          if (!isStart) return false\n          return function () {\n            forceNormalizeNearestElement(editor)\n          }\n        },\n        deleteForward() {\n          if (!editor.selection) return false\n          const entry = Editor.parent(editor, editor.selection)\n          const isEnd = Point.equals(\n            Editor.end(editor, entry[1]),\n            editor.selection.anchor\n          )\n          if (!isEnd) return false\n          return function () {\n            forceNormalizeNearestElement(editor)\n          }\n        },\n      },\n      editableProps: {},\n    }\n  }) as TypedPlugin<NormalizeAfterDeletePluginCustomTypes>\n","import { Element, NodeEntry } from \"slate\"\n\nimport {\n  createHotkeyHandler,\n  createPlugin,\n  findElementUp,\n  isEndOfElement,\n  isStartOfElement,\n  TypedPlugin,\n} from \"~/src/sink\"\n\nimport { deleteFragmentWithProtectedTypes } from \"./delete-fragment\"\nimport { createTableMethods } from \"./methods\"\nimport { normalizeTableIndexes } from \"./normalize/normalize-table\"\nimport { normalizeTableCell } from \"./normalize/normalize-table-cell\"\nimport { renderElement } from \"./render-element\"\nimport {\n  TableCellElement,\n  TableContentElement,\n  TableElement,\n  TableRowElement,\n} from \"./types\"\n\nexport * from \"./types\"\n\nexport type TableEditor = {\n  supportsTable: true\n  tablePlugin: ReturnType<typeof createTableMethods>\n}\n\nexport type TablePluginCustomTypes = {\n  Name: \"table\"\n  Editor: TableEditor\n  Element:\n    | TableElement\n    | TableRowElement\n    | TableCellElement\n    | TableContentElement\n}\n\nexport const TablePlugin = createPlugin<TablePluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.supportsTable = true\n    editor.tablePlugin = createTableMethods(editor)\n    return createPolicy({\n      name: \"table\",\n      editor: {\n        deleteBackward: () => {\n          /**\n           * If we're at start of a cell, disable delete backward because we\n           * don't want the cell to be deleted.\n           */\n          return isStartOfElement(editor, \"table-cell\")\n        },\n        deleteForward: () => {\n          /**\n           * If we're at end of a cell, disable delete forward because we don't\n           * want the cell to be deleted.\n           */\n          return isEndOfElement(editor, \"table-cell\")\n        },\n        deleteFragment: () =>\n          deleteFragmentWithProtectedTypes(editor, [\"table-cell\"]),\n        insertBreak: () => {\n          /**\n           * IF we're anywhere in a table cell, disable insertBreak\n           */\n          const entry = findElementUp(editor, \"table-cell\")\n          return !!entry\n        },\n        isMaster(element) {\n          if (element.type === \"table\") return true\n        },\n        normalizeNode: (entry): boolean => {\n          const [node] = entry\n          if (!Element.isElement(node)) return false\n          switch (node.type) {\n            case \"table\":\n              return normalizeTableIndexes(\n                editor,\n                entry as NodeEntry<TableElement>\n              )\n            case \"table-cell\": {\n              return normalizeTableCell(\n                editor,\n                entry as NodeEntry<TableCellElement>\n              )\n            }\n          }\n          return false\n        },\n      },\n      editableProps: {\n        renderElement,\n        onKeyDown: createHotkeyHandler({\n          /**\n           * navigation\n           */\n          tab: editor.tablePlugin.tabForward,\n          \"shift+tab\": editor.tablePlugin.tabBackward,\n          down: editor.tablePlugin.down,\n          up: editor.tablePlugin.up,\n          /**\n           * selection\n           */\n          \"mod+a\": editor.tablePlugin.selectCell,\n          /**\n           * insert\n           */\n          \"super+t\": () => editor.tablePlugin.insertTable(3, 2),\n          \"mod+shift+enter\": () => editor.tablePlugin.insertRow({ offset: 0 }),\n          \"mod+enter\": () => editor.tablePlugin.insertRow({ offset: 1 }),\n          \"super+[\": () => editor.tablePlugin.insertColumn({ offset: 0 }),\n          \"super+]\": () => editor.tablePlugin.insertColumn({ offset: 1 }),\n          /**\n           * remove\n           */\n          \"super+backspace\": editor.tablePlugin.removeTable,\n          \"mod+backspace\": editor.tablePlugin.removeRow,\n          \"mod+shift+backspace\": editor.tablePlugin.removeColumn,\n        }),\n      },\n    })\n  }\n) as TypedPlugin<TablePluginCustomTypes>\n","import { Editor, Path, Transforms } from \"slate\"\n\nimport { findElementUpPath } from \"~/src/sink\"\n\nimport { getReversedDeleteSafeRanges } from \"./get-reversed-delete-safe-ranges\"\n\n/**\n * This is a special version of deleteFragment that respects elements of the\n * given `protectedTypes` so that they aren't deleted whole and only their\n * children are deleted.\n *\n * This is used in cases like a `table-cell` where we want to protect the\n * shape of the `table`.\n *\n * If the start or end of the deletion range isn't in a protectedType, we don't\n * need to anything special so we let the default delete handle it.\n *\n * If the start or end of the deletion range is in a protectedType but it is\n * the same Element, then the default handler works fine too.\n *\n * In other cases, we break down the full deletion range into multiple ranges.\n * Each range won't go across a protectedType. In effect, this means that we\n * only delete the content of protectedTypes and we do the regular deletes\n * across everything else.\n */\nexport function deleteFragmentWithProtectedTypes(\n  editor: Editor,\n  protectedTypes: string[]\n) {\n  if (editor.selection == null) return false\n  const [start, end] = Editor.edges(editor, editor.selection)\n  const startProtectedPath = findElementUpPath(editor, protectedTypes, {\n    at: start,\n  })\n  const endProtectedPath = findElementUpPath(editor, protectedTypes, {\n    at: end,\n  })\n  /**\n   * If the start or the end of the selection isn't in a protectedType element\n   * then just do a normal delete so we return `false`.\n   */\n  if (!startProtectedPath && !endProtectedPath) {\n    return false\n  }\n\n  /**\n   * If the start and end are in the same protectedType element, then the\n   * default handler works fine so return `false`\n   */\n  if (\n    startProtectedPath &&\n    endProtectedPath &&\n    Path.equals(startProtectedPath, endProtectedPath)\n  ) {\n    return false\n  }\n\n  /**\n   * Breaks the range to delete into chunks of ranges that are safe to delete.\n   * We do this by not allowing a deletion across one of the `protectedTypes`\n   */\n  const reversedRanges = getReversedDeleteSafeRanges(\n    editor,\n    editor.selection,\n    protectedTypes\n  )\n\n  /**\n   * We iterate through the ranges backwards deleting each delete safe range.\n   * At the end, we collapse the originally selected deletion range to the\n   * front.\n   *\n   * NOTE:\n   *\n   * Ideally, we'd actually collapse this to the start or end depending on the\n   * direction of the delete; however, that information is not presently\n   * provided to us. Might be a small improvement in the future that requires\n   * us to update Slate.\n   */\n  Editor.withoutNormalizing(editor, () => {\n    for (const range of reversedRanges) {\n      Transforms.delete(editor, { at: range })\n    }\n    Transforms.collapse(editor, { edge: \"start\" })\n  })\n\n  return true\n}\n","import { BasePoint, Editor, Path, Range } from \"slate\"\n\nimport { findElementUpPath } from \"~/src/sink\"\n\nexport function getReversedDeleteSafeRanges(\n  editor: Editor,\n  deleteRange: Range,\n  protectedTypes: string[]\n): Range[] {\n  /**\n   * Editor.positions returns a bunch of positions which essentially represent\n   * the start and end of Nodes with the exception of the start of the passed\n   * in Range and the end of the passed in Range.\n   */\n  const positions = [...Editor.positions(editor, { at: deleteRange })]\n\n  /**\n   * We create our own set of deleteSafeRanges here\n   */\n  const deleteSafeRanges: Range[] = []\n\n  let startPos: BasePoint, prevPos: BasePoint, startTdPath: Path | undefined\n  startPos = prevPos = positions[0]\n  startTdPath = findElementUpPath(editor, protectedTypes, {\n    at: startPos,\n  })\n\n  for (const pos of positions) {\n    const tdPath = findElementUpPath(editor, protectedTypes, {\n      at: pos,\n    })\n    /**\n     * What we're looking for is that if we search for a protectedType from\n     * this point, and the protectedType is the same as the prvious point we\n     * looked at, then keep going.\n     *\n     * We keep track of the `prevPos` though because when we are in a different\n     * protectedType (or switch to not being in one) then we need the `prevPos`\n     */\n    if (\n      (startTdPath && tdPath && Path.equals(startTdPath, tdPath)) ||\n      (startTdPath == undefined && tdPath == undefined)\n    ) {\n      prevPos = pos\n    } else {\n      /**\n       * Once we see a difference (i.e. a new protectedType or we switch to\n       * being or not being in a protectedType) then we create a Range and\n       * add it to `deleteSafeRanges`.\n       *\n       * We also reset some of our variables that we are tracking.\n       */\n      const range = { anchor: startPos, focus: prevPos }\n      deleteSafeRanges.push(range)\n      startPos = prevPos = pos\n      startTdPath = tdPath\n    }\n  }\n  const range = { anchor: startPos, focus: prevPos }\n  deleteSafeRanges.push(range)\n  deleteSafeRanges.reverse()\n  return deleteSafeRanges\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt, curryOne } from \"~/src/sink\"\n\nimport { getTableInfo } from \"./get-table-info\"\nimport { insertColumn } from \"./insert-column\"\nimport { insertRow } from \"./insert-row\"\nimport { insertTable } from \"./insert-table\"\nimport { down, up } from \"./navigation\"\nimport { removeColumn } from \"./remove-column\"\nimport { removeRow } from \"./remove-row\"\nimport { removeTable } from \"./remove-table\"\nimport { setTableColumnAlign } from \"./setTableColumnAlign\"\nimport { tabBackward, tabForward } from \"./tab\"\n\nexport function createTableMethods(editor: Editor) {\n  return {\n    getTableInfo: curryOne(getTableInfo, editor),\n    insertTable: curryOne(insertTable, editor),\n    insertColumn: curryOne(insertColumn, editor),\n    insertRow: curryOne(insertRow, editor),\n    removeTable: curryOne(removeTable, editor),\n    removeColumn: curryOne(removeColumn, editor),\n    removeRow: curryOne(removeRow, editor),\n    tabForward: curryOne(tabForward, editor),\n    tabBackward: curryOne(tabBackward, editor),\n    selectCell: curryOne(selectCell, editor),\n    down: curryOne(down, editor),\n    up: curryOne(up, editor),\n    setTableColumnAlign: curryOne(setTableColumnAlign, editor),\n  }\n}\n\nfunction selectCell(\n  editor: Editor,\n  { at = editor.selection }: { at?: BetterAt } = {}\n) {\n  const t = getTableInfo(editor, { at })\n  if (t === undefined) return false\n  const { cellPath } = t\n  Transforms.select(editor, cellPath)\n  return true\n}\n","import { Editor, Element, Location, Path } from \"slate\"\n\nimport { findElementUp } from \"~/src/sink\"\n\nimport {\n  TableCellElement,\n  TableColumn,\n  TableElement,\n  TableRowElement,\n} from \"../types\"\n\n/**\n * The TableInfo object that includes quick access information starting from a\n * cell in a table including information about the row and the table.\n *\n * NOTE:\n *\n * This is flat and not nested because it makes destructuring easier, for\n * example, in the table methods.\n */\nexport type TableInfo = {\n  tableElement: TableElement\n  tablePath: Path\n  tableColumns: TableColumn[]\n  rowElement: TableRowElement\n  rowPath: Path\n  rowIndex: number\n  rowCount: number\n  cellElement: TableCellElement\n  cellPath: Path\n  cellIndex: number\n  cellCount: number\n}\n\n/**\n * get table info\n */\n\nexport function getTableInfo(\n  editor: Editor,\n  { at = editor.selection }: { at?: Location | Element | null } = {}\n): TableInfo | undefined {\n  if (at == null) return undefined\n  const cellMatch = findElementUp<TableCellElement>(editor, \"table-cell\", {\n    at,\n  })\n  if (!cellMatch) return undefined\n  const rowMatch = findElementUp<TableRowElement>(editor, \"table-row\", {\n    at,\n  })\n  if (!rowMatch) return undefined\n  const tableMatch = findElementUp<TableElement>(editor, \"table\", { at })\n  if (!tableMatch) return undefined\n  const [tableElement, tablePath] = tableMatch\n  const [rowElement, rowPath] = rowMatch\n  const [cellElement, cellPath] = cellMatch\n  return {\n    tableElement,\n    tablePath,\n    tableColumns: tableElement.columns,\n    rowElement,\n    rowPath,\n    rowIndex: rowPath.slice(-1)[0],\n    rowCount: tableElement.children.length,\n    cellElement,\n    cellPath,\n    cellIndex: cellPath.slice(-1)[0],\n    cellCount: rowElement.children.length,\n  }\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt } from \"~/src/sink\"\n\nimport { getTableInfo } from \"./get-table-info\"\nimport { createCell } from \"./utils\"\n\nexport function insertColumn(\n  editor: Editor,\n  { offset = 0, at = editor.selection }: { offset?: 0 | 1; at?: BetterAt } = {}\n): boolean {\n  const t = getTableInfo(editor, { at })\n  if (t === undefined) return false\n  const { tableElement, tablePath, cellIndex } = t\n  const nextCellIndex = cellIndex + offset\n  Editor.withoutNormalizing(editor, () => {\n    const { columns } = tableElement\n    const nextColumns = [...columns]\n    /**\n     * Insert a Column into `TableElement.columns` which is the same as the\n     * value of the current column. This is the `alignment` of the column.\n     */\n    nextColumns.splice(nextCellIndex, 0, columns[nextCellIndex])\n    Transforms.setNodes(editor, { columns: nextColumns }, { at: tablePath })\n\n    /**\n     * Insert a `TableCell` at the correct spot.\n     */\n    tableElement.children.forEach((rowElement, i) => {\n      Transforms.insertNodes(editor, createCell(nextCellIndex), {\n        at: [...tablePath, i, nextCellIndex],\n      })\n    })\n  })\n  return true\n}\n\n// export function insertColumnLeft(\n//   editor: Editor,\n//   { at }: { at?: MatchAt } = {}\n// ) {\n//   return insertColumn(editor, { at })\n// }\n\n// export function insertColumnRight(\n//   editor: Editor,\n//   { at }: { at?: MatchAt } = {}\n// ) {\n//   return insertColumn(editor, { at, offset: 1 })\n// }\n","import { TableCellElement, TableContentElement } from \"../types\"\n\nexport function createCell(\n  index: number,\n  children: TableContentElement[] = [\n    {\n      type: \"table-content\",\n      children: [{ text: \"\" }],\n    },\n  ]\n): TableCellElement {\n  return {\n    type: \"table-cell\",\n    children,\n  }\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt } from \"~/src/sink\"\n\nimport { TableRowElement } from \"../types\"\nimport { getTableInfo } from \"./get-table-info\"\nimport { createCell } from \"./utils\"\n\nfunction createRow(columnCount: number): TableRowElement {\n  return {\n    type: \"table-row\",\n    children: [...Array(columnCount).keys()].map((index) => createCell(index)),\n  }\n}\n\n/**\n * Used internally for `insertRowAbove` and `insertRowBelow` to do an insert\n * with an offset to improve code reused.\n */\nexport function insertRow(\n  editor: Editor,\n  { at = editor.selection, offset = 0 }: { at?: BetterAt; offset?: 0 | 1 } = {}\n): boolean {\n  const t = getTableInfo(editor, { at })\n  if (!t) return false\n  const nextRowElement = createRow(t.tableElement.columns.length)\n  Transforms.insertNodes(editor, nextRowElement, {\n    at: [...t.tablePath, t.rowIndex + offset],\n  })\n  return true\n}\n\n/**\n * Insert row above current selection\n */\nexport function insertRowAbove(\n  editor: Editor,\n  { at }: { at?: BetterAt } = {}\n): boolean {\n  return insertRow(editor, { at })\n}\n\n/**\n * Insert row below current selection\n */\nexport function insertRowBelow(\n  editor: Editor,\n  { at }: { at?: BetterAt } = {}\n): boolean {\n  return insertRow(editor, { at, offset: 1 })\n}\n","import { Editor, Element, Location, Path, Transforms } from \"slate\"\n\nimport { findElementUp } from \"~/src/sink\"\n\nimport { TableColumn, TableElement, TableRowElement } from \"../types\"\nimport { createCell } from \"./utils\"\n\nfunction createRange(size: number): number[] {\n  return [...Array(size).keys()]\n}\n\nfunction createColumns(columnCount: number): TableColumn[] {\n  return createRange(columnCount).map(() => ({ align: \"left\" }))\n}\n\nfunction createTable(columnCount: number, rowCount: number): TableElement {\n  return {\n    type: \"table\",\n    columns: createColumns(columnCount),\n    children: createRange(rowCount).map(() => createRow(columnCount)),\n  }\n}\n\nfunction createRow(columnCount: number): TableRowElement {\n  return {\n    type: \"table-row\",\n    children: [...Array(columnCount).keys()].map((index) => createCell(index)),\n  }\n}\n\n/**\n * Used internally for `insertRowAbove` and `insertRowBelow` to do an insert\n * with an offset to improve code reused.\n */\nexport function insertTable(\n  editor: Editor,\n  columnCount: number,\n  rowCount: number,\n  { at = editor.selection }: { at?: Location | null } = {}\n): boolean {\n  const table = createTable(columnCount, rowCount)\n  return insertRootElement(editor, table, { at })\n}\n\nexport function insertRootElement(\n  editor: Editor,\n  element: Element,\n  { at = editor.selection }: { at?: Location | null } = {}\n) {\n  if (at == null) return false\n  const entry = findElementUp(\n    editor,\n    (node) => Element.isElement(node) && editor.isMaster(node)\n  )\n  if (entry == null) {\n    const selection = editor.selection\n    Editor.withoutNormalizing(editor, () => {\n      Transforms.insertNodes(editor, element, { at })\n      if (selection) {\n        Transforms.select(editor, selection)\n        Transforms.move(editor)\n      }\n    })\n  } else {\n    const nextPath = Path.next(entry[1])\n    Editor.withoutNormalizing(editor, () => {\n      Transforms.insertNodes(editor, element, { at: nextPath })\n      Transforms.select(editor, Editor.start(editor, nextPath))\n    })\n  }\n  return true\n}\n","import { Editor } from \"slate\"\n\nimport { getTableInfo } from \"../get-table-info\"\nimport { selectElementAbove, selectElementBelow } from \"./select-element\"\nimport { checkIsInElement } from \"./utils\"\n\n/**\n * arrow down\n */\nexport function down(editor: Editor): boolean {\n  const t = getTableInfo(editor)\n  /**\n   * don't handle if we're not in a table\n   */\n  if (!t) return false\n  setTimeout(() => {\n    if (!checkIsInElement(editor, t.cellElement)) {\n      selectElementBelow(editor, t)\n    }\n  })\n  return false\n}\n\n/**\n * arrow up\n */\nexport function up(editor: Editor): boolean {\n  const t = getTableInfo(editor)\n  /**\n   * don't handle if we're not in a table\n   */\n  if (!t) return false\n  setTimeout(() => {\n    if (!checkIsInElement(editor, t.cellElement)) {\n      selectElementAbove(editor, t)\n    }\n  })\n  return false\n}\n","import { Editor, Path } from \"slate\"\n\nimport { selectEndOfElement, selectStartOfElement } from \"~/src/sink\"\n\nimport { TableInfo } from \"../get-table-info\"\n\nexport function selectElementBelow(editor: Editor, t: TableInfo) {\n  const { cellIndex, rowIndex, rowCount, tablePath } = t\n  /**\n   * if we aren't in the last row of a table, move down a row\n   */\n  if (rowIndex < rowCount - 1) {\n    selectStartOfElement(editor, [...tablePath, rowIndex + 1, cellIndex])\n    return true\n  }\n  /**\n   * If we are in the last row of a table, move to the start of the Element\n   * after the table\n   */\n  try {\n    selectStartOfElement(editor, Path.next(tablePath))\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nexport function selectElementAbove(editor: Editor, t: TableInfo) {\n  const { cellIndex, rowIndex, tablePath } = t\n  /**\n   * if we aren't in the first row of a table, move up a row\n   */\n  if (rowIndex > 0) {\n    selectStartOfElement(editor, [...tablePath, rowIndex - 1, cellIndex])\n    return true\n  }\n  /**\n   * If we are in the first row of a table, move to the end of the Element\n   * before the table\n   */\n  try {\n    selectEndOfElement(editor, Path.previous(tablePath))\n    return true\n  } catch (e) {\n    return false\n  }\n}\n","import { Descendant, Editor, Element } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\n/**\n * This is named with `...Unreliable...` because at the beginning of a line\n * (e.g. the second line of a paragraph) the DOMRect returned will be for a\n * position at the end of the previous line.\n *\n * So why have an unreliable version? Because, there actually is no reliable\n * version and the unreliable one works in most cases. It's better than not\n * having an unreliable selection rect.\n *\n * So it's useful, but we need to handle the case where it's on the end of the\n * previous line instead of the beginning of the line.\n *\n * NOTE:\n *\n * Inserting a `span` and removing it does not work. We can kind of getting it\n * to work by inserting a span with some with (like has the letter \"A\") inside.\n * It will then sometimes switch the problem so that the DOMRect return is on\n * the next line instead of the previous; however, makes the cursor move into\n * the wrong position when cursoring down the right side and this is worse than\n * the problem is solves.\n */\nexport function getUnreliableSelectionRect(): DOMRect | null {\n  const s = window.getSelection()\n  if (!s) return null\n  const range = s.getRangeAt(0)\n  return range.getBoundingClientRect()\n}\n\n/**\n * Takes a Slate Element and returns a DOMRect representing the Element as\n * it is in the DOM.\n */\nfunction getElementRect(editor: Editor, element: Descendant) {\n  return ReactEditor.toDOMNode(editor, element).getBoundingClientRect()\n}\n\nexport function checkIsInElement(editor: Editor, element: Element): boolean {\n  /**\n   * Get the unreliable selection rect. If there is no selection, we consider\n   * that the selection is not in the last line which will usually indicates\n   * default behavior.\n   */\n  const selectionRect = getUnreliableSelectionRect()\n  if (!selectionRect) return false\n  const elementRect = getElementRect(editor, element)\n  return (\n    selectionRect.right < elementRect.right &&\n    selectionRect.left > elementRect.left &&\n    selectionRect.bottom < elementRect.bottom &&\n    selectionRect.top > elementRect.top\n  )\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt } from \"~/src/sink\"\n\nimport { getTableInfo } from \"./get-table-info\"\nimport { removeTable } from \"./remove-table\"\n\nexport function removeColumn(\n  editor: Editor,\n  { at = editor.selection }: { at?: BetterAt } = {}\n) {\n  const t = getTableInfo(editor, { at })\n  if (!t) return false\n\n  const { tableElement, tablePath, rowIndex, cellIndex, cellCount } = t\n  if (cellCount === 1) {\n    return removeTable(editor)\n  }\n  Editor.withoutNormalizing(editor, () => {\n    // Set the new `align` value based on the current `td` column (not the position\n    // to insert at)\n    const columns = [...tableElement.columns]\n    columns.splice(cellIndex, 1)\n    Transforms.setNodes(editor, { columns }, { at: tablePath })\n    tableElement.children.forEach((rowElement, rowIndex) => {\n      Transforms.removeNodes(editor, {\n        at: [...tablePath, rowIndex, cellIndex],\n      })\n    })\n    const selection = Editor.start(editor, [\n      ...tablePath,\n      rowIndex,\n      Math.min(cellIndex, cellCount - 2),\n    ])\n    Transforms.select(editor, selection)\n  })\n}\n","import { Editor, Transforms } from \"slate\"\n\nexport function removeTable(editor: Editor): boolean {\n  const t = editor.tablePlugin.getTableInfo()\n  if (t === undefined) return false\n  Transforms.removeNodes(editor, { at: t.tablePath })\n  return true\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { BetterAt } from \"~/src/sink\"\n\nimport { getTableInfo } from \"./get-table-info\"\nimport { removeTable } from \"./remove-table\"\n\nexport function removeRow(\n  editor: Editor,\n  { at = editor.selection }: { at?: BetterAt } = {}\n) {\n  const t = getTableInfo(editor, { at })\n  if (t === undefined) return false\n  if (t.rowCount === 1) {\n    removeTable(editor)\n    return true\n  }\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.removeNodes(editor, { at: t.rowPath })\n    Transforms.select(\n      editor,\n      Editor.start(editor, [\n        ...t.tablePath,\n        Math.min(t.rowIndex, t.rowCount - 2),\n        t.cellIndex,\n      ])\n    )\n  })\n  return true\n}\n","import { Editor, Transforms } from \"slate\"\n\nimport { getTableInfo } from \"./get-table-info\"\n\nexport function setTableColumnAlign(\n  editor: Editor,\n  options: { align: \"left\" | \"center\" | \"right\" }\n) {\n  const t = getTableInfo(editor)\n  if (t === undefined) return false\n  const { tableElement, tablePath, cellIndex } = t\n  const nextColumns = tableElement.columns.slice()\n  nextColumns.splice(cellIndex, 1, { align: options.align })\n  Transforms.setNodes(editor, { columns: nextColumns }, { at: tablePath })\n  return true\n}\n","import { Editor } from \"slate\"\n\nimport { selectStartOfElement } from \"~/src/sink\"\n\nimport { getTableInfo } from \"./get-table-info\"\nimport { insertRowBelow } from \"./insert-row\"\nexport function tabForward(editor: Editor) {\n  const t = getTableInfo(editor)\n  if (!t) return false\n\n  const { cellIndex, cellCount, rowIndex, rowCount, tablePath } = t\n\n  /**\n   * If we aren't in the last cell of the row, then select the next cell\n   */\n  if (cellIndex < cellCount - 1) {\n    selectStartOfElement(editor, [...tablePath, rowIndex, cellIndex + 1])\n    return true\n  }\n\n  /**\n   * If we are in the last cell of the row but we aren't in the last row of\n   * the table, then select the first cell in the next row.\n   */\n  if (rowIndex < rowCount - 1) {\n    selectStartOfElement(editor, [...tablePath, rowIndex + 1, 0])\n    return true\n  }\n\n  /**\n   * If we are in the last cell of the table, insert a new row and then\n   * select the first cell in the new row.\n   */\n  insertRowBelow(editor)\n  selectStartOfElement(editor, [...tablePath, rowIndex + 1, 0])\n\n  return true\n}\n\nexport function tabBackward(editor: Editor) {\n  const t = getTableInfo(editor)\n  if (!t) return false\n\n  const { cellIndex, cellCount, rowIndex, tablePath } = t\n\n  if (cellIndex > 0) {\n    selectStartOfElement(editor, [...tablePath, rowIndex, cellIndex - 1])\n    return true\n  }\n\n  if (rowIndex > 0) {\n    selectStartOfElement(editor, [...tablePath, rowIndex - 1, cellCount - 1])\n    return true\n  }\n}\n","import { Editor, NodeEntry, Transforms } from \"slate\"\n\nimport { TableElement } from \"../types\"\n\nexport function normalizeTableIndexes(\n  editor: Editor,\n  entry: NodeEntry<TableElement>\n): boolean {\n  let isTransformed = false\n  const rowElements = entry[0].children\n  rowElements.forEach((rowElement, y) => {\n    const cellElements = rowElement.children\n    cellElements.forEach((cellElement, x) => {\n      if (cellElement.x !== x || cellElement.y !== y) {\n        Transforms.setNodes(editor, { x, y }, { at: [...entry[1], y, x] })\n        isTransformed = true\n      }\n    })\n  })\n  return isTransformed\n}\n","import { Editor, NodeEntry, Transforms } from \"slate\"\n\nimport { TableCellElement } from \"../types\"\n\nexport function normalizeTableCell(\n  editor: Editor,\n  entry: NodeEntry<TableCellElement>\n): boolean {\n  const [node, path] = entry\n  if (node.children.length === 1 && node.children[0].type === \"table-content\") {\n    return false\n  }\n  Editor.withoutNormalizing(editor, () => {\n    /**\n     * This ensures that the first child node of a `table-cell`\n     * is a `table-content` node. It won't be if a user pastes\n     * in the start of a `table-cell`.\n     *\n     * We want this because our algorithm will merge all following\n     * nodes into this node. If we don't do this, we are merging\n     * into a potentially non `table-content` cell and might end up\n     * with some other `Element` like a `code-block`.\n     *\n     * NOTE:\n     *\n     * In order to make sure this doesn't turn into a noop, we add\n     * some text here. It is arbitrarily an `X`.\n     */\n    Transforms.insertNodes(\n      editor,\n      {\n        type: \"table-content\",\n        children: [{ text: \"X\" }],\n      },\n      { at: [...entry[1], 0] }\n    )\n    /**\n     * We then iterate from the back of the children to the front\n     * and merging left. Because we inserted an extra node, the\n     * for loop looks a little unusual in that `i` starts at\n     * `node.children.length` instead of `node.children.length - 1`.\n     */\n    for (let i = node.children.length; i >= 0; i--) {\n      Transforms.mergeNodes(editor, { at: [...path, i] })\n    }\n    /**\n     * When we're done, we remove the `X`.\n     *\n     * There might be a cleaner way to do this whout adding and\n     * removing the `X` and when we find it, we can improve this\n     * code.\n     *\n     * IMPORTANT:\n     *\n     * Whatever a replacement is, remember that we need to execute\n     * the commands such that it preserves the cursor position.\n     */\n    Transforms.delete(editor, {\n      at: { path: [...path, 0, 0], offset: 0 },\n      unit: \"character\",\n    })\n  })\n  return true\n}\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport {\n  TableCellElement,\n  TableContentElement,\n  TableElement,\n  TableRowElement,\n} from \"../types\"\nimport { Table } from \"./table\"\nimport { TableCell } from \"./table-cell\"\nimport { TableContent } from \"./table-content\"\nimport { TableRow } from \"./table-row\"\n\nexport function renderElement({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<\n  TableElement | TableRowElement | TableCellElement | TableContentElement\n>) {\n  switch (element.type) {\n    case \"table\":\n      return (\n        <Table element={element} attributes={attributes}>\n          {children}\n        </Table>\n      )\n    case \"table-row\":\n      return (\n        <TableRow element={element} attributes={attributes}>\n          {children}\n        </TableRow>\n      )\n    case \"table-cell\":\n      return (\n        <TableCell element={element} attributes={attributes}>\n          {children}\n        </TableCell>\n      )\n    case \"table-content\":\n      return (\n        <TableContent element={element} attributes={attributes}>\n          {children}\n        </TableContent>\n      )\n  }\n}\n","import { useEffect } from \"react\"\nimport { ReactEditor, useSelected, useSlateStatic } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { normalizeTableIndexes } from \"../normalize/normalize-table\"\nimport { TableElement } from \"../types\"\nimport { $Table } from \"./styles\"\nimport { TableContext } from \"./table-context\"\n\nexport function Table({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<TableElement>) {\n  const editor = useSlateStatic()\n  const isSelected = useSelected()\n  /**\n   * The first time we render a table, we make sure it is normalized.\n   * When it comes out of an `initialValue` it's not guaranteed to include\n   * `x` and `y` properties as they are optional.\n   *\n   * This mainly helps us not have to manually add these values when the\n   * `x` and `y` are purely an internal requirement for rendering.\n   */\n  useEffect(() => {\n    const path = ReactEditor.findPath(editor, element)\n    normalizeTableIndexes(editor, [element, path])\n  }, [])\n  return (\n    <TableContext.Provider value={{ isSelected }}>\n      <$Table {...attributes} columns={element.columns}>\n        <tbody>{children}</tbody>\n      </$Table>\n    </TableContext.Provider>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nimport { TableColumn } from \"../../types\"\nexport * from \"./table-menu-styles\"\n\n/**\n * Table\n */\nexport const $Table = styled(\"table\")<{ columns: TableColumn[] }>`\n  border-collapse: collapse;\n  margin: 1em 0;\n  ${({ columns }) =>\n    columns\n      .map(\n        (column, index) =>\n          `td:nth-of-type(${index + 1}) { text-align: ${column.align}; }`\n      )\n      .join(\"\\n\")}\n`\n\n/**\n * Table Row\n */\nexport const $TableRow = styled(\"tr\")`\n  position: relative;\n  &:first-of-type {\n    background: var(--table-head-bgcolor);\n  }\n`\n\n/**\n * Table Cell\n *\n * - `--selected` indicates selected cell\n */\nexport const $TableCell = styled(\"td\")`\n  position: relative;\n  border-width: 1px;\n  border-style: solid;\n  border-color: rgba(0, 0, 0, 0.2) rgba(0, 0, 0, 0.05);\n  border-color: var(--table-row-border-color) var(--table-column-border-color);\n  padding: 0.75em 1em;\n  min-width: 2em;\n  &.--selected {\n    outline: 2px solid var(--select-color, blue);\n  }\n  /**\n   * Stronger borders on the left and right edge\n   */\n  &:first-of-type {\n    border-left-color: var(--table-border-color);\n  }\n  &:last-of-type {\n    border-right-color: var(--table-border-color);\n  }\n`\n\n/**\n * Table Content (inside Table Cell)\n */\nexport const $TableContent = styled(\"div\")`\n  /**\n   * Smaller font inside a table than outside of it\n   */\n  font-size: 0.9375em; /* 15px */\n  /**\n   * Even smaller font and dimmer for the heading row\n   */\n  tr:first-of-type & {\n    color: rgba(0, 0, 0, 0.6);\n    font-size: 0.875em; /* 14px */\n  }\n`\n","import styled from \"@emotion/styled\"\n\n/**\n * Table Menu\n */\n\nconst $BaseMenu = styled(\"div\")`\n  position: absolute;\n  /**\n   * very slightly shaded\n   */\n  background: rgba(0, 0, 0, 0.001);\n\n  /**\n   * hover \n   */\n  &:hover {\n    /**\n     * needs to pop up so that it doesn't jump back and forth with neighbor\n     * below\n     */\n    z-index: 1000;\n    /**\n     * Makes the visible tile get darker on hover over any part of the\n     * menu including the invisible part\n     */\n    .--tile {\n      background: rgba(0, 0, 0, 0.15);\n    }\n  }\n`\n\nexport const $ColumnMenu = styled($BaseMenu)`\n  cursor: pointer;\n  /**\n   * hangs out on top\n   */\n  left: -1px;\n  right: -1px;\n  right: 0;\n  height: 3em;\n  top: -3em;\n`\n\nexport const $RowMenu = styled($BaseMenu)`\n  /**\n   * hangs out on left\n   */\n  top: -1px;\n  bottom: -1px;\n  width: 3em;\n  left: -3em;\n`\n\n/**\n * Menu Tile\n */\n\nconst $MenuTile = styled(\"div\")`\n  position: absolute;\n  background: rgba(0, 0, 0, 0.05);\n  border: 1px solid rgba(0, 0, 0, 0.05);\n  transition: all 200ms;\n  /**\n   * NOTE: One of these should be overridden\n   */\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`\n\n/**\n * The `$RowMenuTile` is the visible part of the `$RowMenu` and is the right\n * half of the `$RowMenu`.\n */\nexport const $ColumnMenuTile = styled($MenuTile)`\n  top: 50%;\n  border-bottom: none;\n  border-right: none;\n  bottom: 1px;\n  td:first-of-type & {\n    border-top-left-radius: 0.5em;\n  }\n  td:last-of-type & {\n    border-top-right-radius: 0.5em;\n    border-right: 1px solid rgba(0, 0, 0, 0.05);\n    right: -1px;\n  }\n  svg {\n    position: absolute;\n    top: 0.1875em;\n    left: 50%;\n    margin-left: -0.5em;\n    color: rgba(0, 0, 0, 0.2);\n  }\n  &:hover svg {\n    color: rgba(0, 0, 0, 0.5);\n  }\n\n  /* border-top-left-radius: 0.5em;\n  border-top-right-radius: 0.5em; */\n`\n\n/**\n * The `$RowMenuTile` is the visible part of the `$RowMenu` and is the right\n * half of the `$RowMenu`.\n */\nexport const $RowMenuTile = styled($MenuTile)`\n  left: 50%;\n  border-right: none;\n  border-bottom: none;\n  right: 1px;\n  tr:first-of-type & {\n    border-top-left-radius: 0.5em;\n  }\n  tr:last-of-type & {\n    border-bottom-left-radius: 0.5em;\n    border-bottom: 1px solid rgba(0, 0, 0, 0.05);\n    bottom: 0;\n  }\n  svg {\n    position: absolute;\n    left: 0.25em;\n    top: 50%;\n    margin-top: -0.5em;\n    color: rgba(0, 0, 0, 0.2);\n  }\n  &:hover svg {\n    color: rgba(0, 0, 0, 0.5);\n  }\n\n  /* border-top-left-radius: 0.5em;\n  border-bottom-left-radius: 0.5em; */\n`\n\n/**\n * Menu Button\n */\n\nconst $MenuButton = styled(\"div\")`\n  position: absolute;\n  font-size: 1.5em;\n  background: white;\n  border-radius: 50%;\n  cursor: pointer;\n  svg {\n    display: block;\n  }\n`\n\nexport const $AddMenuButton = styled($MenuButton)`\n  color: #c0c0c0;\n  &:hover {\n    color: royalblue;\n  }\n`\n\nexport const $RemoveMenuButton = styled($MenuButton)`\n  color: #c0c0c0;\n  &:hover {\n    color: firebrick;\n  }\n`\n","import { createContext } from \"react\"\n\nexport const TableContext = createContext<{ isSelected: boolean }>({\n  isSelected: false,\n})\n","import { useContext } from \"react\"\nimport { useSelected } from \"slate-react\"\n\nimport { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { TableCellElement } from \"../../types\"\nimport { $TableCell } from \"../styles\"\nimport { TableContext } from \"../table-context\"\nimport { ColumnMenu } from \"./column-menu\"\nimport { RowMenu } from \"./row-menu\"\nimport { TableMenu } from \"./table-menu\"\n\nexport function TableCell({\n  element,\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<TableCellElement>) {\n  const tableContext = useContext(TableContext)\n  const selected = useSelected()\n  /**\n   * table has slection and we are in the top left cell\n   */\n  const showTableMenu =\n    tableContext.isSelected && element.x === 0 && element.y === 0\n  /**\n   * table has selection and we are in the left columns\n   */\n  const showRowMenu = tableContext.isSelected && element.x === 0\n  /**\n   * table has selection and we are in the top row\n   */\n  const showColumnMenu = tableContext.isSelected && element.y === 0\n  return (\n    <$TableCell\n      className={selected ? \"--selected\" : \"\"}\n      {...attributes}\n      data-x={element.x}\n      data-y={element.y}\n    >\n      {children}\n      {showTableMenu ? <TableMenu /> : null}\n      {showRowMenu ? <RowMenu cellElement={element} /> : null}\n      {showColumnMenu ? <ColumnMenu cellElement={element} /> : null}\n    </$TableCell>\n  )\n}\n","import React, { useCallback, useRef, useState } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { Menu, MenuItemData } from \"~/src/shared-overlays\"\nimport { useLayer } from \"~/src/use-layer\"\n\nimport {\n  AlignCenter,\n  AlignLeft,\n  AlignRight,\n  BarsIcon,\n  MinusIcon,\n  PlusIcon,\n} from \"../../../icons\"\nimport { TableCellElement } from \"../../../types\"\nimport {\n  $AddMenuButton,\n  $ColumnMenu,\n  $ColumnMenuTile,\n  $RemoveMenuButton,\n} from \"../../styles\"\n\nexport function ColumnMenu({ cellElement }: { cellElement: TableCellElement }) {\n  const editor = useSlateStatic()\n  const menu = useLayer(\"column-menu\")\n  const buttonRef = useRef<HTMLDivElement>(null)\n  const [hover, setHover] = useState(false)\n\n  const onMouseEnter = useCallback(() => {\n    setHover(true)\n  }, [])\n\n  const onMouseLeave = useCallback(() => {\n    setHover(false)\n  }, [])\n\n  const onClick = useCallback(() => {\n    if (menu.layer) menu.close()\n    const dest = buttonRef.current\n    if (dest === null) return\n    const items: MenuItemData[] = [\n      {\n        icon: AlignLeft,\n        title: \"Align Column left\",\n        action: () => {\n          editor.tablePlugin.setTableColumnAlign({ align: \"left\" })\n        },\n      },\n      {\n        icon: AlignCenter,\n        title: \"Align Column Center\",\n        action: () => {\n          editor.tablePlugin.setTableColumnAlign({ align: \"center\" })\n        },\n      },\n      {\n        icon: AlignRight,\n        title: \"Align Column Right\",\n        action: () => {\n          editor.tablePlugin.setTableColumnAlign({ align: \"right\" })\n        },\n      },\n    ]\n    // Menu\n    menu.open(() => <Menu dest={dest} items={items} close={menu.close} />)\n  }, [])\n\n  return (\n    <$ColumnMenu\n      ref={buttonRef}\n      contentEditable={false}\n      onClick={onClick}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      <$ColumnMenuTile className=\"--tile\">\n        <BarsIcon />\n      </$ColumnMenuTile>\n      {hover ? (\n        <>\n          <$RemoveMenuButton\n            style={{\n              top: 0,\n              left: \"50%\",\n              marginLeft: \"-0.5em\",\n            }}\n            onMouseDown={() =>\n              editor.tablePlugin.removeColumn({ at: cellElement })\n            }\n          >\n            <MinusIcon />\n          </$RemoveMenuButton>\n\n          <$AddMenuButton\n            style={{ left: \"-0.5em\", top: 0 }}\n            onMouseDown={() =>\n              editor.tablePlugin.insertColumn({ at: cellElement })\n            }\n          >\n            <PlusIcon />\n          </$AddMenuButton>\n          <$AddMenuButton\n            style={{ right: \"-0.5em\", top: 0 }}\n            onMouseDown={() =>\n              editor.tablePlugin.insertColumn({ at: cellElement, offset: 1 })\n            }\n          >\n            <PlusIcon />\n          </$AddMenuButton>\n        </>\n      ) : null}\n    </$ColumnMenu>\n  )\n}\n","import { SVGProps } from \"react\"\n\nimport { TablerIcon } from \"../sink\"\n\nexport const PlusIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 20 20\"\n    fill=\"currentColor\"\n    width=\"1em\"\n    height=\"1em\"\n    {...props}\n  >\n    <path\n      fillRule=\"evenodd\"\n      d=\"M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zm.75-11.25a.75.75 0 0 0-1.5 0v2.5h-2.5a.75.75 0 0 0 0 1.5h2.5v2.5a.75.75 0 0 0 1.5 0v-2.5h2.5a.75.75 0 0 0 0-1.5h-2.5v-2.5z\"\n      clipRule=\"evenodd\"\n    />\n  </svg>\n)\n\nexport const MinusIcon = (props: SVGProps<SVGSVGElement>) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 20 20\"\n    fill=\"currentColor\"\n    width=\"1em\"\n    height=\"1em\"\n    {...props}\n  >\n    <path\n      fillRule=\"evenodd\"\n      d=\"M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16zM6.75 9.25a.75.75 0 0 0 0 1.5h6.5a.75.75 0 0 0 0-1.5h-6.5z\"\n      clipRule=\"evenodd\"\n    />\n  </svg>\n)\n\nexport const BarsIcon = () => (\n  <TablerIcon>\n    <path d=\"M4 6h16M4 12h16M4 18h16\" />\n  </TablerIcon>\n)\n\nexport const AlignLeft = () => (\n  <TablerIcon>\n    <path d=\"M4 6h16M4 12h10M4 18h14\" />\n  </TablerIcon>\n)\n\nexport const AlignCenter = () => (\n  <TablerIcon>\n    <path d=\"M4 6h16M8 12h8M6 18h12\" />\n  </TablerIcon>\n)\n\nexport const AlignRight = () => (\n  <TablerIcon>\n    <path d=\"M4 6h16M10 12h10M6 18h14\" />\n  </TablerIcon>\n)\n","import React, { useState } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { BarsIcon, MinusIcon, PlusIcon } from \"../../../icons\"\nimport { TableCellElement } from \"../../../types\"\nimport {\n  $AddMenuButton,\n  $RemoveMenuButton,\n  $RowMenu,\n  $RowMenuTile,\n} from \"../../styles\"\n\nexport function RowMenu({ cellElement }: { cellElement: TableCellElement }) {\n  const editor = useSlateStatic()\n  const [hover, setHover] = useState(false)\n\n  return (\n    <$RowMenu\n      contentEditable={false}\n      onMouseEnter={() => setHover(true)}\n      onMouseLeave={() => setHover(false)}\n    >\n      <$RowMenuTile className=\"--tile\">\n        <BarsIcon />\n      </$RowMenuTile>\n      {hover ? (\n        <>\n          <$RemoveMenuButton\n            style={{\n              top: \"50%\",\n              left: \"0.5em\",\n              marginTop: \"-0.5em\",\n            }}\n            onMouseDown={() =>\n              editor.tablePlugin.removeRow({ at: cellElement })\n            }\n          >\n            <MinusIcon />\n          </$RemoveMenuButton>\n          <$AddMenuButton\n            style={{ top: \"-0.5em\", left: \"0.5em\" }}\n            onMouseDown={() =>\n              editor.tablePlugin.insertRow({ at: cellElement })\n            }\n          >\n            <PlusIcon />\n          </$AddMenuButton>\n          <$AddMenuButton\n            style={{ bottom: \"-0.5em\", left: \"0.5em\" }}\n            onMouseDown={() =>\n              editor.tablePlugin.insertRow({ at: cellElement, offset: 1 })\n            }\n          >\n            <PlusIcon />\n          </$AddMenuButton>\n        </>\n      ) : null}\n    </$RowMenu>\n  )\n}\n","import { $TableMenu, $TableMenuTile } from \"./$table-menu\"\n\nexport function TableMenu() {\n  return (\n    <$TableMenu contentEditable={false}>\n      <$TableMenuTile className=\"--table-menu-tile\" />\n    </$TableMenu>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $TableMenu = styled(\"div\")`\n  position: absolute;\n  /**\n   * very slightly shaded\n   */\n  background: rgba(0, 0, 0, 0.001);\n\n  /**\n   * hangs out on left\n   */\n  top: -1.5em;\n  left: -4em;\n  height: 2.5em;\n  width: 2.5em;\n\n  /**\n   * hover \n   */\n  &:hover {\n    /**\n     * needs to pop up so that it doesn't jump back and forth with neighbor\n     * below\n     */\n    z-index: 1000;\n    /**\n     * Makes the visible tile get darker on hover over any part of the\n     * menu including the invisible part\n     */\n    .--row-menu-tile {\n      background: rgba(0, 0, 0, 0.15);\n    }\n  }\n`\n\n/**\n * The `$RowMenuTile` is the visible part of the `$RowMenu` and is the right\n * half of the `$RowMenu`.\n */\nexport const $TableMenuTile = styled(\"div\")`\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 1.5em;\n  height: 1.5em;\n  background: rgba(0, 0, 0, 0.05);\n  border-radius: 50%;\n`\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { TableContentElement } from \"../types\"\nimport { $TableContent } from \"./styles\"\n\nexport function TableContent({\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<TableContentElement>) {\n  return <$TableContent {...attributes}>{children}</$TableContent>\n}\n","import { ConstrainedRenderElementProps } from \"~/src/sink\"\n\nimport { TableRowElement } from \"../types\"\nimport { $TableRow } from \"./styles\"\n\nexport function TableRow({\n  attributes,\n  children,\n}: ConstrainedRenderElementProps<TableRowElement>) {\n  return <$TableRow {...attributes}>{children}</$TableRow>\n}\n","import { Descendant } from \"slate\"\n\n/**\n * Alignment of Table Columns\n */\nexport type TableColumnAlign = \"left\" | \"center\" | \"right\"\n\n/**\n * Table Column values\n */\n\nexport type TableColumn = { align: TableColumnAlign }\n\n/**\n * Table Element\n */\n\nexport type TableElement = {\n  type: \"table\"\n  columns: TableColumn[]\n  children: TableRowElement[]\n}\n\n/**\n * Table Row Element\n */\n\nexport type TableRowElement = {\n  type: \"table-row\"\n  children: TableCellElement[]\n}\n\n/**\n * Table Cell Element\n *\n * The children of a `TdElement` is exactly one `ParagraphElement`.\n *\n * This is a good choice for Slate because copying and pasting a range of\n * elements will split the lowest child element by default. If the child of\n * a `TdElement` is a leaf, then we split the `TdElement` which is never what\n * we want.\n *\n * Instead, by having a lower level element, the `ParagraphElement`, we allow\n * that to be split.\n *\n * But of course, insertion means we have many child elements in the `TdElement`\n * but these are easier to fix using normalization. We can keep iterating\n * through normalizations until we end up with a single Paragraph.\n */\n\nexport type TableCellElement = {\n  type: \"table-cell\"\n  x?: number\n  y?: number\n  children: TableContentElement[]\n}\n\nexport type TableContentElement = {\n  type: \"table-content\"\n  children: Descendant[]\n}\n","import { Global } from \"@emotion/react\"\n\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { globalStyles } from \"./global-styles\"\n\nexport type ThemeEditor = {\n  theme: true\n}\n\nexport type ThemePluginCustomTypes = {\n  Name: \"theme\"\n  Editor: ThemeEditor\n}\n\nexport const ThemePlugin = createPlugin<ThemePluginCustomTypes>((editor) => {\n  editor.theme = true\n  return {\n    name: \"theme\",\n    editor: {},\n    renderEditable: ({ attributes, Editable }) => {\n      return (\n        <>\n          <Global styles={globalStyles} />\n          <Editable {...attributes} />\n        </>\n      )\n    },\n    editableProps: {},\n  }\n}) as TypedPlugin<ThemePluginCustomTypes>\n","import { css } from \"@emotion/react\"\n\nconst blue = `\n--blue-50: rgb(239 246 255);\n--blue-100: rgb(219 234 254);\n--blue-200: rgb(191 219 254);\n--blue-300: rgb(147 197 253);\n--blue-400: rgb(96 165 250);\n--blue-500: rgb(59 130 246);\n--blue-600: rgb(37 99 235);\n--blue-700: rgb(29 78 216);\n--blue-800: rgb(30 64 175);\n--blue-900: rgb(30 58 138);\n`\n\n// ignore because right now we're manually swapping them in/out\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst slateShades = `\n--shade-50: rgb(248 250 252);\n--shade-100: rgb(241 245 249);\n--shade-200: rgb(226 232 240);\n--shade-300: rgb(203 213 225);\n--shade-400: rgb(148 163 184);\n--shade-500: rgb(100 116 139);\n--shade-600: rgb(71 85 105);\n--shade-700: rgb(51 65 85);\n--shade-800: rgb(30 41 59);\n--shade-900: rgb(15 23 42);\n`\n\n// ignore because right now we're manually swapping them in/out\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst grayShades = `\n--shade-50: rgb(249 250 251);\n--shade-100: rgb(243 244 246);\n--shade-200: rgb(229 231 235);\n--shade-300: rgb(209 213 219);\n--shade-400: rgb(156 163 175);\n--shade-500: rgb(107 114 128);\n--shade-600: rgb(75 85 99);\n--shade-700: rgb(55 65 81);\n--shade-800: rgb(31 41 55);\n--shade-900: rgb(17 24 39);\n`\n\n// ignore because right now we're manually swapping them in/out\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst zincShades = `\n--shade-50: rgb(250 250 250);\n--shade-100: rgb(244 244 245);\n--shade-200: rgb(228 228 231);\n--shade-300: rgb(212 212 216);\n--shade-400: rgb(161 161 170);\n--shade-500: rgb(113 113 122);\n--shade-600: rgb(82 82 91);\n--shade-700: rgb(63 63 70);\n--shade-800: rgb(39 39 42);\n--shade-900: rgb(24 24 27);\n`\n\nexport const globalStyles = css`\n  :root {\n    /* Tailwind Colors */\n    ${blue}\n    ${zincShades}\n    /* Select Colors */\n    --select-color: var(--blue-400);\n    --select-editor-color: var(--blue-200);\n    --hover-color: var(--blue-200);\n    /* Link Colors */\n    --link-color: var(--blue-600);\n    --link-hover-color: var(--blue-700);\n    /* Code Block Colors */\n    --code-block-bgcolor: var(--shade-50);\n    --code-block-border-color: var(--shade-300);\n    /* Inline Code Colors */\n    --inline-code-bgcolor: var(--shade-100);\n    --inline-code-border-color: var(--shade-200);\n    /* Table Colors */\n    --table-border-color: var(--shade-300);\n    --table-row-border-color: var(--shade-300);\n    --table-column-border-color: var(--shade-100);\n    --table-head-bgcolor: var(--shade-50);\n    --table-menu-bgcolor: var(--shade-100);\n    --table-menu-hover-bgcolor: var(--shade-200);\n    /* Horizontal Rule Colors */\n    --hr-color: var(--shade-300);\n  }\n`\n","import { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { renderEditable } from \"./render-editable\"\n\nexport type ToolbarEditor = {\n  toolbar: {\n    height?: string | number\n    minHeight?: string | number\n    maxHeight?: string | number\n    showUploadButtons?: boolean\n  }\n}\n\nexport type ToolbarOptions = {\n  toolbar: {\n    height?: string | number\n    minHeight?: string | number\n    maxHeight?: string | number\n    showUploadButtons?: boolean\n  }\n}\n\nexport type ToolbarPluginCustomTypes = {\n  Name: \"toolbar\"\n  Editor: ToolbarEditor\n  Options: ToolbarOptions\n}\n\nexport const ToolbarPlugin = createPlugin<ToolbarPluginCustomTypes>(\n  (editor, options) => {\n    editor.toolbar = {\n      height: options.toolbar?.height,\n      minHeight: options.toolbar?.minHeight,\n      maxHeight: options.toolbar?.maxHeight,\n      showUploadButtons: options.toolbar?.showUploadButtons ?? true,\n    }\n    return {\n      name: \"toolbar\",\n      editor: {},\n      renderEditable,\n      editableProps: {},\n    }\n  }\n) as TypedPlugin<ToolbarPluginCustomTypes>\n","import { clsx } from \"clsx\"\nimport { useCallback, useRef } from \"react\"\nimport { Editor, Transforms } from \"slate\"\nimport { ReactEditor, useFocused, useSlateStatic } from \"slate-react\"\n\nimport { RenderEditableProps } from \"~/src/sink\"\nimport { Layers } from \"~/src/use-layer\"\n\nimport { Toolbar } from \"../components\"\nimport { $Editable, $OuterContainer } from \"../styles\"\n\nexport function renderEditable({ attributes, Editable }: RenderEditableProps) {\n  const outerContainerRef = useRef<HTMLDivElement>(null)\n\n  const editor = useSlateStatic()\n  const focused = useFocused()\n\n  /**\n   * When the user clicks inside the outer container but outside of the content\n   * or the toolbar, we want the user to see the cursor inside the editable\n   * region.\n   */\n  const onClickOuterContainer = useCallback(\n    (e: React.MouseEvent<HTMLDivElement>) => {\n      /**\n       * If the user clicked on the toolbar, we don't want to do anything.\n       *\n       * If the user clicked on the content, we don't want to do anything\n       * because focus and selection will be handled by Slate.\n       */\n      if (e.target !== e.currentTarget) return\n      /**\n       * Select the last position in the editor\n       */\n      Transforms.select(editor, Editor.end(editor, []))\n      ReactEditor.focus(editor)\n    },\n    [editor]\n  )\n  /**\n   * The Toolbar works by rendering an $OuterContainer which is the border\n   * around the entire editor.\n   *\n   * Inside the $OuterContainer, we have our actual Toolbar and the\n   * actual Editable.\n   *\n   * TODO:\n   *\n   * We currently add `Layers` around everything in the Toolbar plugin but\n   * we should consider adding this somewhere else because the layers inside\n   * the Editor (like in the image toolbar) won't work unless we are using the\n   * toolbar plugin.\n   *\n   * Conceivably, we could have a version of the editor without the Toolbar.\n   *\n   * We could consider adding a Layers plugin and make it a dependency of some\n   * other thing or we could just add it outside of everything as part of\n   * Sink itself since probably every version of the editor will require at\n   * least one layer somewhere.\n   */\n  return (\n    <Layers>\n      <$OuterContainer\n        ref={outerContainerRef}\n        className={clsx({ \"--focused\": focused })}\n        style={{\n          height: editor.toolbar.height,\n          minHeight: editor.toolbar.minHeight,\n          maxHeight: editor.toolbar.maxHeight,\n        }}\n        onClick={onClickOuterContainer}\n      >\n        <Toolbar />\n        <Editable\n          as={$Editable}\n          {...attributes}\n          style={{ overflowY: \"auto\" }}\n        />\n      </$OuterContainer>\n    </Layers>\n  )\n}\n","export * from \"../../shared-overlays/components/CloseMask\"\nexport * from \"../../shared-overlays/components/Menu/Menu\"\nexport * from \"../../use-tooltip/tooltip\"\nexport * from \"./dialog/table-dialog\"\nexport * from \"./toolbar/toolbar\"\nexport * from \"./toolbar/toolbar-button\"\n","import { clsx } from \"clsx\"\nimport { useCallback, useRef, useState } from \"react\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { CloseMask } from \"~/src/shared-overlays\"\nimport { useAbsoluteReposition } from \"~/src/use-reposition\"\n\nimport {\n  $TableDialog,\n  $TableDialogGrid,\n  $TableDialogGridCell,\n} from \"../../styles/table-styles\"\n\nfunction createRange(size: number): number[] {\n  return [...Array(size).keys()]\n}\n\nexport function TableDialog({\n  dest,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n}) {\n  const [hover, setHover] = useState({ x: 0, y: 0 })\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const style = useAbsoluteReposition({ src: ref, dest }, ({ dest }) => {\n    return { left: dest.left - 8, top: dest.top + dest.height }\n  })\n  const rows = createRange(5).map((i) => i + 1)\n  const cols = createRange(5).map((i) => i + 1)\n\n  const hoverCell = useCallback(\n    (x: number, y: number) => {\n      setHover({ x, y })\n    },\n    [setHover]\n  )\n\n  const createTable = useCallback(\n    (x: number, y: number) => {\n      editor.tablePlugin.insertTable(x, y)\n      ReactEditor.focus(editor)\n      close()\n    },\n    [editor]\n  )\n\n  return (\n    <>\n      <CloseMask close={close} />\n      <$TableDialog ref={ref} style={style}>\n        <$TableDialogGrid onMouseLeave={() => hoverCell(0, 0)}>\n          {rows.map((y) => {\n            return cols.map((x) => {\n              const selected = x <= hover.x && y <= hover.y\n              return (\n                <$TableDialogGridCell\n                  className={clsx({ \"--selected\": selected })}\n                  key={`${x},${y}`}\n                  onMouseEnter={() => hoverCell(x, y)}\n                  onClick={() => createTable(x, y)}\n                />\n              )\n            })\n          })}\n        </$TableDialogGrid>\n      </$TableDialog>\n    </>\n  )\n}\n","import styled from \"@emotion/styled\"\n\nimport { $Panel } from \"../../shared-overlays\"\n\nexport const $TableDialog = styled($Panel)`\n  padding: 0.5em;\n`\nexport const $TableDialogGrid = styled(\"div\")`\n  display: grid;\n  grid-template-columns: repeat(5, 1.75em);\n  grid-template-rows: 1.5em;\n  /* grid-gap: 1px; */\n`\nexport const $TableDialogGridCell = styled(\"div\")`\n  background: var(--shade-100);\n  height: 1.5em;\n  border-radius: 0.125em;\n  border-right: 1px solid white;\n  border-top: 1px solid white;\n  cursor: pointer;\n  &.--selected {\n    background: var(--blue-100);\n  }\n`\n","import throttle from \"lodash.throttle\"\nimport { useEffect, useRef, useState } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { MenuItemData } from \"../../../shared-overlays/types\"\nimport { initialItems, itemSets } from \"../../items\"\nimport {\n  $Toolbar,\n  $ToolbarContainer,\n  $ToolbarDivider,\n  $ToolbarDividerContainer,\n} from \"../../styles\"\nimport { ToolbarButton } from \"./toolbar-button\"\n\n/**\n * Render a toolbar item which is either a button or a divider.\n */\nfunction ToolbarItem({ item }: { item: MenuItemData }) {\n  const editor = useSlateStatic()\n  if (item === \"divider\") {\n    return (\n      <$ToolbarDividerContainer data-item-type=\"divider\">\n        <$ToolbarDivider />\n      </$ToolbarDividerContainer>\n    )\n  }\n  const show = item.show === undefined ? true : item.show(editor)\n  if (!show) return null\n  return <ToolbarButton item={item} />\n}\n\n/**\n * Returns the width of the toolbar, the width of a button, and the width of a\n * divider.\n */\nfunction getWidths(toolbar: HTMLDivElement) {\n  const button = toolbar.querySelector<HTMLDivElement>(\n    \"[data-item-type=button]\"\n  )\n  const divider = toolbar.querySelector<HTMLDivElement>(\n    \"[data-item-type=divider]\"\n  )\n  if (!button || !divider) throw new Error(\"Button or divider not found\")\n  return {\n    toolbar: toolbar.offsetWidth,\n    button: button.offsetWidth,\n    divider: divider.offsetWidth,\n  }\n}\n\n/**\n * Takes an array of items representing a set of toolbar buttons and items and\n * returns the width of the set in pixels\n */\nfunction measureItemSetWidth(\n  items: MenuItemData[],\n  buttonWidth: number,\n  dividerWidth: number\n): number {\n  let width = 0\n  for (const item of items) {\n    width += item === \"divider\" ? dividerWidth : buttonWidth\n  }\n  return width\n}\n\nexport function Toolbar() {\n  const ref = useRef<HTMLDivElement>(null)\n  const [items, setItems] = useState<MenuItemData[]>(initialItems)\n  useEffect(() => {\n    const refresh = throttle(\n      () => {\n        const toolbar = ref.current\n        if (!toolbar) throw new Error(\"Toolbar not found\")\n        const widths = getWidths(toolbar)\n        /**\n         * Iterate through the item sets and find the first one that fits within\n         * the toolbar width. If none fit, use the last item set.\n         */\n        for (let i = 0; i < itemSets.length - 1; i++) {\n          const itemSetWidth = measureItemSetWidth(\n            itemSets[i],\n            widths.button,\n            widths.divider\n          )\n          if (itemSetWidth < widths.toolbar) {\n            setItems(itemSets[i])\n            return\n          }\n        }\n        setItems(itemSets[itemSets.length - 1])\n      },\n      100,\n      { trailing: true }\n    )\n    refresh()\n    window.addEventListener(\"resize\", refresh)\n    return () => {\n      window.removeEventListener(\"resize\", refresh)\n    }\n  }, [])\n  return (\n    <$ToolbarContainer ref={ref}>\n      <$Toolbar>\n        {items.map((item, index) => (\n          <ToolbarItem\n            key={typeof item === \"string\" ? index : item.title}\n            item={item}\n          />\n        ))}\n      </$Toolbar>\n    </$ToolbarContainer>\n  )\n}\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport { blockDropdownItem } from \"./block-items\"\nimport { compactDialogItems, expandedDialogItems } from \"./dialogItems\"\nimport { dropdownItems } from \"./dropdownItems\"\nimport { linkItem } from \"./linkItem\"\nimport { compactMarkItems, expandedMarkItems } from \"./mark-items\"\n\n/**\n * A collection of `Item` objects that describe either\n *\n * - A Button in the toolbar\n * - A Menu Item in a drop down of the toolbar\n *\n * An `Item` is described in the same way whether it is a button or a menu\n * item making them interchangeable.\n */\n\nexport const largeItems: MenuItemData[] = [\n  blockDropdownItem,\n  \"divider\",\n  ...expandedMarkItems,\n  \"divider\",\n  linkItem,\n  ...dropdownItems,\n  \"divider\",\n  ...expandedDialogItems,\n]\n\nexport const mediumItems: MenuItemData[] = [\n  blockDropdownItem,\n  \"divider\",\n  ...expandedMarkItems,\n  \"divider\",\n  linkItem,\n  ...dropdownItems,\n  \"divider\",\n  ...compactDialogItems,\n]\n\nexport const smallItems: MenuItemData[] = [\n  blockDropdownItem,\n  \"divider\",\n  ...compactMarkItems,\n  \"divider\",\n  linkItem,\n  ...dropdownItems,\n  \"divider\",\n  ...compactDialogItems,\n]\n\nexport const initialItems: MenuItemData[] = [blockDropdownItem, \"divider\"]\n\nexport const items = mediumItems\n\nexport const itemSets: MenuItemData[][] = [largeItems, mediumItems, smallItems]\n","import { MenuItemData } from \"~/src/shared-overlays/types\"\n\nimport * as Icon from \"../icons\"\n\nconst blockItems: MenuItemData[] = [\n  {\n    icon: Icon.H1,\n    title: \"Heading 1\",\n    hotkey: \"super+1\",\n    action: (editor) => editor.heading.convertHeading(1, false),\n  },\n  {\n    icon: Icon.H2,\n    title: \"Heading 2\",\n    hotkey: \"super+2\",\n    action: (editor) => editor.heading.convertHeading(2, false),\n  },\n  {\n    icon: Icon.H3,\n    title: \"Heading 3\",\n    hotkey: \"super+3\",\n    action: (editor) => editor.heading.convertHeading(3, false),\n  },\n  {\n    icon: Icon.H4,\n    title: \"Heading 4\",\n    hotkey: \"super+4\",\n    action: (editor) => editor.heading.convertHeading(4, false),\n  },\n  {\n    icon: Icon.H5,\n    title: \"Heading 5\",\n    hotkey: \"super+5\",\n    action: (editor) => editor.heading.convertHeading(5, false),\n  },\n  {\n    icon: Icon.H6,\n    title: \"Heading 6\",\n    hotkey: \"super+6\",\n    action: (editor) => editor.heading.convertHeading(1, false),\n  },\n  \"divider\",\n  {\n    icon: Icon.Paragraph,\n    title: \"Paragraph\",\n    hotkey: \"super+0\",\n    action: (editor) => {\n      editor.collapsibleParagraph.convertParagraph()\n    },\n  },\n]\n\nexport const blockDropdownItem: MenuItemData = {\n  icon: Icon.H,\n  title: \"Paragraph Style\",\n  more: true,\n  children: blockItems,\n}\n","import { TablerIcon } from \"../sink\"\n\nexport const H = () => (\n  <TablerIcon>\n    <path d=\"M7 12h10M7 5v14M17 5v14M15 19h4M15 5h4M5 19h4M5 5h4\" />\n  </TablerIcon>\n)\n\nexport const More = () => (\n  <TablerIcon className=\"--more-icon\" width=\"0.5em\" viewBox=\"0 0 12 24\">\n    <path d=\"m2 12 4 4 4-4\" />\n  </TablerIcon>\n)\n\nexport const LinkPlus = () => (\n  <TablerIcon width=\"0.5em\" viewBox=\"6 0 12 24\">\n    <path d=\"M9 12h6M12 9v6\" />\n  </TablerIcon>\n)\n\nexport const H1 = () => (\n  <TablerIcon>\n    <path d=\"M19 18v-8l-2 2M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const H2 = () => (\n  <TablerIcon>\n    <path d=\"M17 12a2 2 0 1 1 4 0c0 .591-.417 1.318-.816 1.858L17 18.001h4M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const H3 = () => (\n  <TablerIcon>\n    <path d=\"M19 14a2 2 0 1 0-2-2M17 16a2 2 0 1 0 2-2M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const H4 = () => (\n  <TablerIcon>\n    <path d=\"M20 18v-8l-4 6h5M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const H5 = () => (\n  <TablerIcon>\n    <path d=\"M17 18h2a2 2 0 1 0 0-4h-2v-4h4M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const H6 = () => (\n  <TablerIcon>\n    <path d=\"M19 14a2 2 0 1 0 0 4 2 2 0 0 0 0-4z\" />\n    <path d=\"M21 12a2 2 0 1 0-4 0v4M4 6v12M12 6v12M11 18h2M3 18h2M4 12h8M3 6h2M11 6h2\" />\n  </TablerIcon>\n)\n\nexport const Paragraph = () => (\n  <TablerIcon>\n    <path d=\"M7 20V4h5.5a4 4 0 0 1 0 9H7\" />\n  </TablerIcon>\n)\n\nexport const Bold = () => (\n  <TablerIcon>\n    {/* <path d=\"M0 0h24v24H0z\" stroke=\"none\" /> */}\n    <path d=\"M7 5h6a3.5 3.5 0 0 1 0 7H7zM13 12h1a3.5 3.5 0 0 1 0 7H7v-7\" />\n  </TablerIcon>\n)\n\nexport const Italic = () => (\n  <TablerIcon>\n    <path d=\"M11 5h6M7 19h6M14 5l-4 14\" />\n  </TablerIcon>\n)\n\nexport const Style = () => (\n  <TablerIcon>\n    <path d=\"M4 20h3M14 20h7M6.9 15h6.9M10.2 6.3 16 20M5 20l6-16h2l7 16\" />\n  </TablerIcon>\n)\n\nexport const Link = () => (\n  <TablerIcon>\n    <path d=\"M10 14a3.5 3.5 0 0 0 5 0l4-4a3.5 3.5 0 0 0-5-5l-.5.5\" />\n    <path d=\"M14 10a3.5 3.5 0 0 0-5 0l-4 4a3.5 3.5 0 0 0 5 5l.5-.5\" />\n  </TablerIcon>\n)\n\n/**\n * Block Quote\n */\n\nexport const Blockquote = () => (\n  <TablerIcon>\n    <path d=\"M6 15h15M21 19H6M15 11h6M21 7h-6M9 9h1a1 1 0 1 1-1 1V7.5a2 2 0 0 1 2-2M3 9h1a1 1 0 1 1-1 1V7.5a2 2 0 0 1 2-2\" />\n  </TablerIcon>\n)\n\nexport const Quote = () => (\n  <TablerIcon>\n    <path d=\"M10 11H6a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v6c0 2.667-1.333 4.333-4 5M19 11h-4a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v6c0 2.667-1.333 4.333-4 5\" />\n  </TablerIcon>\n)\n\nexport const QuoteOff = () => (\n  <TablerIcon>\n    <path d=\"M10 11H6a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1m4 4v3c0 2.667-1.333 4.333-4 5M19 11h-4m-1-1V7a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v6c0 .66-.082 1.26-.245 1.798m-1.653 2.29c-.571.4-1.272.704-2.102.912M3 3l18 18\" />\n  </TablerIcon>\n)\n\n/**\n * List\n */\n\nexport const BulletList = () => (\n  <TablerIcon>\n    <path d=\"M9 6h11M9 12h11M9 18h11M5 6v.01M5 12v.01M5 18v.01\" />\n  </TablerIcon>\n)\n\n/**\n * Table\n */\n\nexport const Table = () => (\n  <TablerIcon>\n    <rect x={4} y={4} width={16} height={16} rx={2} />\n    <path d=\"M4 10h16M10 4v16\" />\n  </TablerIcon>\n)\n\n/**\n * Code\n */\n\nexport const Code = () => (\n  <TablerIcon>\n    <path d=\"m7 8-4 4 4 4M17 8l4 4-4 4M14 4l-4 16\" />\n  </TablerIcon>\n)\n\n/**\n * Media and Files\n */\n\nexport const Image = () => (\n  <TablerIcon>\n    <path d=\"M15 8h.01\" />\n    <rect x={4} y={4} width={16} height={16} rx={3} />\n    <path d=\"m4 15 4-4a3 5 0 0 1 3 0l5 5\" />\n    <path d=\"m14 14 1-1a3 5 0 0 1 3 0l2 2\" />\n  </TablerIcon>\n)\n\nexport const Attachment = () => (\n  <TablerIcon>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M14 3v4a1 1 0 0 0 1 1h4\" />\n    <path d=\"M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2zM12 11v6M9 14h6\" />\n  </TablerIcon>\n)\n\nexport const FileUpload = () => (\n  <TablerIcon>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M14 3v4a1 1 0 0 0 1 1h4\" />\n    <path d=\"M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2zM12 11v6\" />\n    <path d=\"M9.5 13.5 12 11l2.5 2.5\" />\n  </TablerIcon>\n)\n\nexport const PhotoUp = () => (\n  <TablerIcon>\n    <path stroke=\"none\" d=\"M0 0h24v24H0z\" />\n    <path d=\"M15 8h.01M12.5 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v6.5\" />\n    <path d=\"m3 16 5-5c.928-.893 2.072-.893 3 0l3.5 3.5\" />\n    <path d=\"m14 14 1-1c.679-.653 1.473-.829 2.214-.526M19 22v-6M22 19l-3-3-3 3\" />\n  </TablerIcon>\n)\n\n/**\n * Text Styles\n */\n\nexport const Plus = () => (\n  <TablerIcon>\n    <path d=\"M12 5v14M5 12h14\" />\n  </TablerIcon>\n)\nexport const Superscript = () => (\n  <TablerIcon>\n    <path d=\"m5 7 8 10m-8 0 8-10M21 11h-4l3.5-4A1.73 1.73 0 0 0 17 5\" />\n  </TablerIcon>\n)\n\nexport const Subscript = () => (\n  <TablerIcon>\n    <path d=\"m5 7 8 10m-8 0 8-10M21 20h-4l3.5-4a1.73 1.73 0 0 0-3.5-2\" />\n  </TablerIcon>\n)\n\nexport const Strikethrough = () => (\n  <TablerIcon>\n    <path d=\"M5 12h14M16 6.5A4 2 0 0 0 12 5h-1a3.5 3.5 0 0 0 0 7h2a3.5 3.5 0 0 1 0 7h-1.5a4 2 0 0 1-4-1.5\" />\n  </TablerIcon>\n)\n\nexport const RemoveStyles = () => (\n  <TablerIcon>\n    <path d=\"m14 6 7 7-2 2M10 10l-4.172 4.172a2.828 2.828 0 1 0 4 4L14 14\" />\n    <path d=\"m16 12 4.414-4.414a2 2 0 0 0 0-2.829l-1.171-1.171a2 2 0 0 0-2.829 0L12 8M4 20l1.768-1.768M3 3l18 18\" />\n  </TablerIcon>\n)\n\nexport const ListCheck = () => (\n  <TablerIcon>\n    <path d=\"m9 11 3 3 8-8\" />\n    <path d=\"M20 12v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h9\" />\n  </TablerIcon>\n)\n\nexport const ListNumbers = () => (\n  <TablerIcon>\n    <path d=\"M11 6h9M11 12h9M12 18h8M4 16a2 2 0 1 1 4 0c0 .591-.5 1-1 1.5L4 20h4M6 10V4L4 6\" />\n  </TablerIcon>\n)\n\nexport const Emoji = () => (\n  <TablerIcon>\n    <circle cx={12} cy={12} r={9} />\n    <path d=\"M9 10h.01M15 10h.01M9.5 15a3.5 3.5 0 0 0 5 0\" />\n  </TablerIcon>\n)\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport { TableDialog } from \"../components\"\nimport { EmojiDialog } from \"../components/dialog/emoji-dialog\"\nimport { AttachmentDialog, ImageDialog } from \"../components/dialog/file-dialog\"\nimport * as Icon from \"../icons\"\n\nexport const dialogItems: MenuItemData[] = [\n  {\n    icon: Icon.Table,\n    title: \"Insert Table\",\n    more: true,\n    Component: TableDialog,\n  },\n  {\n    icon: Icon.Image,\n    title: \"Insert Image\",\n    more: true,\n    Component: ImageDialog,\n    show: (editor) => editor.toolbar.showUploadButtons ?? false,\n  },\n  {\n    icon: Icon.Attachment,\n    title: \"Insert Attachment\",\n    more: true,\n    Component: AttachmentDialog,\n    show: (editor) => editor.toolbar.showUploadButtons ?? false,\n  },\n  {\n    icon: Icon.Emoji,\n    title: \"Insert Emoji\",\n    more: true,\n    Component: EmojiDialog,\n  },\n]\n\nexport const expandedDialogItems: MenuItemData[] = dialogItems\n\nexport const compactDialogItems: MenuItemData[] = [\n  {\n    icon: Icon.Plus,\n    title: \"Insert\",\n    more: true,\n    children: dialogItems,\n  },\n]\n","import data from \"@emoji-mart/data\"\nimport Picker from \"@emoji-mart/react\"\nimport styled from \"@emotion/styled\"\nimport { useCallback, useRef } from \"react\"\nimport { Transforms } from \"slate\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { $Panel, CloseMask } from \"~/src/shared-overlays\"\nimport { positionInside, useAbsoluteReposition } from \"~/src/use-reposition\"\n\nexport function EmojiDialog({\n  dest,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n}) {\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const style = useAbsoluteReposition(\n    { src: ref, dest },\n    ({ src, dest }, viewport) => {\n      return positionInside(\n        src,\n        viewport,\n        {\n          left: dest.left,\n          top: dest.top + dest.height,\n        },\n        { margin: 16 }\n      )\n    }\n  )\n\n  const onEmojiSelect = useCallback(\n    (e: { native: string }) => {\n      Transforms.insertText(editor, e.native)\n      ReactEditor.focus(editor)\n      close()\n    },\n    [editor]\n  )\n\n  return (\n    <>\n      <CloseMask close={close} />\n      <$EmojiDialog ref={ref} style={style}>\n        <Picker data={data} onEmojiSelect={onEmojiSelect} autoFocus={true} />\n      </$EmojiDialog>\n    </>\n  )\n}\n\nexport const $EmojiDialog = styled($Panel)``\n","import { useRef } from \"react\"\nimport { useSlateStatic } from \"slate-react\"\n\nimport { CloseMask } from \"~/src/shared-overlays\"\nimport { stopEvent } from \"~/src/sink\"\nimport { positionInside, useAbsoluteReposition } from \"~/src/use-reposition\"\n\nimport * as Icon from \"../../icons\"\nimport { $DialogButton, $DialogHint } from \"../../styles/dialog-shared-styles\"\nimport { $FileDialog } from \"../../styles/file-dialog-styles\"\n\nexport function FileDialog({\n  dest,\n  close,\n  icon,\n  buttonCaption,\n  buttonHint,\n}: {\n  dest: HTMLElement\n  close: () => void\n  icon: React.ReactNode\n  buttonCaption: string\n  buttonHint: string\n}) {\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const style = useAbsoluteReposition(\n    { src: ref, dest },\n    ({ src, dest }, viewport) => {\n      return positionInside(\n        src,\n        viewport,\n        {\n          left: dest.left - 16,\n          top: dest.top + dest.height,\n        },\n        { margin: 16 }\n      )\n    }\n  )\n\n  async function onChange(e: React.ChangeEvent<HTMLInputElement>) {\n    if (e.target.files == null || e.target.files.length === 0) return\n    stopEvent(e)\n    const { files } = e.target\n    for (const file of files) {\n      editor.upload.upload(file)\n    }\n    close()\n  }\n\n  return (\n    <>\n      <CloseMask close={close} />\n      <$FileDialog ref={ref} style={style}>\n        <label>\n          <input\n            type=\"file\"\n            multiple\n            style={{ display: \"none\" }}\n            onChange={onChange}\n          />\n          <$DialogButton>\n            {icon}\n\n            <span style={{ marginLeft: \"0.5em\" }}>{buttonCaption}</span>\n          </$DialogButton>\n        </label>\n        <$DialogHint>{buttonHint}</$DialogHint>\n      </$FileDialog>\n    </>\n  )\n}\n\nexport function AttachmentDialog({\n  dest,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n}) {\n  return (\n    <FileDialog\n      dest={dest}\n      close={close}\n      icon={<Icon.FileUpload />}\n      buttonCaption=\"Select files...\"\n      buttonHint=\"Select files to insert as attachments\"\n    />\n  )\n}\n\nexport function ImageDialog({\n  dest,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n}) {\n  return (\n    <FileDialog\n      dest={dest}\n      close={close}\n      icon={<Icon.PhotoUp />}\n      buttonCaption=\"Select images...\"\n      buttonHint=\"Select image files to upload and insert into the editor\"\n    />\n  )\n}\n","import styled from \"@emotion/styled\"\n\nexport const $DialogButton = styled(\"div\")`\n  /* Center vertically and horizontally */\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  /* font-size: 1.25em; */\n  padding: 0.25em 0.75em;\n  text-align: center;\n  color: var(--blue-100);\n  color: white;\n  background: var(--blue-500);\n  transition: all 100ms;\n  &:hover {\n    color: var(--blue-50);\n    background: var(--blue-600);\n    outline: 2px solid var(--blue-200);\n  }\n  border-radius: 0.25em;\n  svg {\n    color: var(--blue-200);\n    font-size: 1.25em;\n    stroke-width: 2px;\n  }\n`\n\nexport const $DialogHint = styled(\"div\")`\n  font-size: 0.875em;\n  margin-top: 0.5em;\n  color: var(--shade-500);\n  line-height: 1.375;\n`\n","import styled from \"@emotion/styled\"\n\nimport { $Panel } from \"../../shared-overlays/styles/$Panel\"\n\nexport const $FileDialog = styled($Panel)`\n  padding: 1em;\n  width: 18em;\n`\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport * as Icon from \"../icons\"\nimport { codeBlockItems } from \"./codeBlockItems\"\nimport { listItems } from \"./list-items\"\nimport { quoteItems } from \"./quote-items\"\n\nexport const dropdownItems: MenuItemData[] = [\n  {\n    icon: Icon.BulletList,\n    title: \"Lists\",\n    more: true,\n    children: listItems,\n  },\n  {\n    icon: Icon.Blockquote,\n    title: \"Block Quote\",\n    more: true,\n    children: quoteItems,\n  },\n  {\n    icon: Icon.Code,\n    title: \"Code Block\",\n    more: true,\n    children: codeBlockItems,\n  },\n]\n","import { Editor } from \"slate\"\n\nimport { MenuItemData } from \"~/src/shared-overlays\"\n\nimport { BuiltInLanguage } from \"../../code-block-plugin\"\nimport * as Icon from \"../icons\"\n\nfunction codeBlockAction(language: BuiltInLanguage) {\n  return (editor: Editor) =>\n    editor.codeBlock.setCodeBlockLanguage(language) ||\n    editor.codeBlock.createCodeBlock({ language })\n}\n\nexport const codeBlockItems: MenuItemData[] = [\n  {\n    icon: Icon.BulletList,\n    title: \"Plain text\",\n    action: codeBlockAction(\"text\"),\n  },\n  \"divider\",\n  {\n    icon: Icon.BulletList,\n    title: \"HTML\",\n    action: codeBlockAction(\"html\"),\n  },\n  {\n    icon: Icon.BulletList,\n    title: \"SVG\",\n    action: codeBlockAction(\"svg\"),\n  },\n  {\n    icon: Icon.BulletList,\n    title: \"CSS\",\n    action: codeBlockAction(\"css\"),\n  },\n  \"divider\",\n  {\n    icon: Icon.BulletList,\n    title: \"Javascript\",\n    action: codeBlockAction(\"javascript\"),\n  },\n  {\n    icon: Icon.BulletList,\n    title: \"C Like (C, C#, C++, Java)\",\n    action: codeBlockAction(\"clike\"),\n  },\n]\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport * as Icon from \"../icons\"\n\nexport const listItems: MenuItemData[] = [\n  {\n    icon: Icon.BulletList,\n    title: \"Bullet List\",\n    hotkey: \"super+8\",\n    action: (editor) => editor.list.convertUnorderedList(false),\n  },\n  {\n    icon: Icon.ListNumbers,\n    title: \"Numbered List\",\n    hotkey: \"super+7\",\n    action: (editor) => editor.list.convertOrderedList(false),\n  },\n  {\n    icon: Icon.ListCheck,\n    title: \"Checklist\",\n    hotkey: \"super+9\",\n    action: (editor) => editor.list.convertTaskList(false),\n  },\n]\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport * as Icon from \"../icons\"\n\nexport const quoteItems: MenuItemData[] = [\n  {\n    icon: Icon.Quote,\n    title: \"Add Block Quote\",\n    hotkey: \"super+.\",\n    action: (editor) => editor.blockQuotePlugin.indent(),\n  },\n  {\n    icon: Icon.QuoteOff,\n    title: \"Remove Block Quote\",\n    hotkey: \"super+,\",\n    action: (editor) => editor.blockQuotePlugin.outdent(),\n  },\n]\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport { AnchorDialog } from \"../components/dialog/anchor-dialog\"\nimport * as Icon from \"../icons\"\n\nexport const linkItem: MenuItemData = {\n  icon: Icon.Link,\n  title: \"Insert Link\",\n  more: true,\n  hotkey: \"mod+k\",\n  Component: AnchorDialog,\n}\n","import { isHotkey } from \"is-hotkey\"\nimport {\n  ChangeEvent,\n  KeyboardEvent,\n  useCallback,\n  useRef,\n  useState,\n} from \"react\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { positionInside, useAbsoluteReposition } from \"~/src/use-reposition\"\n\nimport { CloseMask } from \"../../../shared-overlays/components/CloseMask\"\nimport * as Icon from \"../../icons\"\nimport {\n  $AnchorDialog,\n  $AnchorDialogInput,\n  $AnchorDialogInputLine,\n} from \"../../styles\"\nimport { $DialogButton, $DialogHint } from \"../../styles/dialog-shared-styles\"\n\nconst isEnter = isHotkey(\"enter\")\n\nexport function AnchorDialog({\n  dest,\n  close,\n}: {\n  dest: HTMLElement\n  close: () => void\n}) {\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const style = useAbsoluteReposition(\n    { src: ref, dest },\n    ({ src, dest }, viewport) => {\n      return positionInside(\n        src,\n        viewport,\n        {\n          left: dest.left - 12,\n          top: dest.top + dest.height,\n        },\n        { margin: 16 }\n      )\n    }\n  )\n\n  const [url, setUrl] = useState(\"\")\n\n  const insertLink = () => {\n    editor.anchor.insertLink(url, url, { select: true })\n    ReactEditor.focus(editor)\n    close()\n  }\n\n  const onChangeInput = useCallback(\n    (e: ChangeEvent<HTMLInputElement>) => {\n      setUrl(e.currentTarget.value)\n    },\n    [setUrl]\n  )\n\n  const onKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {\n    if (!isEnter(e)) return\n    e.preventDefault()\n    e.stopPropagation()\n    insertLink()\n  }\n\n  return (\n    <>\n      <CloseMask close={close} />\n      <$AnchorDialog ref={ref} style={style}>\n        <$AnchorDialogInputLine>\n          <$AnchorDialogInput\n            type=\"text\"\n            value={url}\n            autoFocus\n            onChange={onChangeInput}\n            onKeyDown={onKeyDown}\n          />\n          <$DialogButton onClick={insertLink}>\n            <Icon.Link />\n            <Icon.LinkPlus />\n          </$DialogButton>\n        </$AnchorDialogInputLine>\n        <$DialogHint>Enter URL of link</$DialogHint>\n      </$AnchorDialog>\n    </>\n  )\n}\n","import { MenuItemData } from \"~/src/shared-overlays\"\n\nimport * as Icon from \"../icons\"\n\nconst primaryMarkItems: MenuItemData[] = [\n  {\n    icon: Icon.Bold,\n    title: \"Bold\",\n    hotkey: \"mod+b\",\n    action: (editor) => editor.marksPlugin.toggleBold(),\n  },\n  {\n    icon: Icon.Italic,\n    title: \"Italic\",\n    hotkey: \"mod+i\",\n    action: (editor) => editor.marksPlugin.toggleItalic(),\n  },\n]\n\nconst secondaryMarkItems: MenuItemData[] = [\n  {\n    icon: Icon.Superscript,\n    title: \"Superscript\",\n    hotkey: \"super+p\",\n    action: (editor) => editor.marksPlugin.toggleSup(),\n  },\n  {\n    icon: Icon.Subscript,\n    title: \"Subscript\",\n    hotkey: \"super+b\",\n    action: (editor) => editor.marksPlugin.toggleSub(),\n  },\n  \"divider\",\n  {\n    icon: Icon.Strikethrough,\n    title: \"Strikethrough\",\n    hotkey: \"super+k\",\n    action: (editor) => editor.marksPlugin.toggleStrike(),\n  },\n  \"divider\",\n  {\n    icon: Icon.Code,\n    title: \"Inline Code\",\n    hotkey: \"mod+j\",\n    action: (editor) => editor.inlineCode.toggleInlineCode(),\n  },\n  \"divider\",\n  {\n    icon: Icon.RemoveStyles,\n    title: \"Remove Styles\",\n    hotkey: \"super+0\",\n    /**\n     * TODO: Enable remove styles\n     */\n    action: (editor) => editor.marksPlugin.removeMarks(),\n  },\n]\n\nexport const expandedMarkItems: MenuItemData[] = [\n  ...primaryMarkItems,\n  {\n    icon: Icon.Style,\n    title: \"Text Style\",\n    more: true,\n    children: secondaryMarkItems,\n  },\n]\n\nexport const compactMarkItems: MenuItemData[] = [\n  {\n    icon: Icon.Style,\n    title: \"Text Style\",\n    more: true,\n    children: [...primaryMarkItems, \"divider\", ...secondaryMarkItems],\n  },\n]\n","import { clsx } from \"clsx\"\nimport { MouseEvent, useCallback, useRef } from \"react\"\nimport { ReactEditor, useSlateStatic } from \"slate-react\"\n\nimport { formatHotkey, Menu, MenuItemData } from \"~/src/shared-overlays\"\nimport { useLayer } from \"~/src/use-layer\"\nimport { useTooltip } from \"~/src/use-tooltip\"\n\nimport * as Icon from \"../../icons\"\nimport { $ToolbarButton } from \"../../styles\"\n\nexport function ToolbarButton({\n  active,\n  item,\n}: {\n  active?: boolean\n  item: Exclude<MenuItemData, \"divider\">\n}) {\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLDivElement>(null)\n  const tooltip = useTooltip({\n    title: item.title,\n    hotkey: () => (item.hotkey ? formatHotkey(item.hotkey) : undefined),\n  })\n  const menuLayer = useLayer(\"menu\")\n\n  const openMenu = useCallback(() => {\n    const dest = ref.current\n    const items = item.children\n    const Component = item.Component\n    if (!dest) return\n    if (items) {\n      menuLayer.open(() => (\n        <Menu dest={dest} items={items} close={menuLayer.close} />\n      ))\n    } else if (Component) {\n      menuLayer.open(() => <Component dest={dest} close={menuLayer.close} />)\n    }\n  }, [item])\n\n  const onClick = useCallback(() => {\n    if (item.action) {\n      item.action(editor)\n      ReactEditor.focus(editor)\n      return\n    }\n    if (menuLayer.layer) {\n      menuLayer.close()\n    } else {\n      openMenu()\n    }\n  }, [menuLayer.layer, item])\n\n  /**\n   * On hover\n   */\n  const onMouseEnter = useCallback(\n    (e: MouseEvent<HTMLElement>) => {\n      tooltip.onMouseEnter(e)\n      /**\n       * If any `menu` is already open, then we open up the currently hovered\n       * `menu` automatically. This replicates behavior in menus in windowing\n       * systems.\n       */\n      if (menuLayer.layer) openMenu()\n    },\n    [menuLayer.layer]\n  )\n\n  return (\n    <$ToolbarButton\n      data-item-type=\"button\"\n      ref={ref}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={tooltip.onMouseLeave}\n      onClick={onClick}\n      className={clsx({ \"--active\": active, \"--more\": item.more })}\n    >\n      <item.icon />\n      {item.more ? <Icon.More /> : null}\n    </$ToolbarButton>\n  )\n}\n","import { Editor, Element, Node, Path, Transforms } from \"slate\"\n\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\ntype TrailingBlockPluginCustomType = {\n  Name: \"trailing-block\"\n  Editor: { allowTrailingBlock: true }\n}\n\nexport const TrailingBlockPlugin = createPlugin<TrailingBlockPluginCustomType>(\n  (editor) => {\n    editor.allowTrailingBlock = true\n    return {\n      name: \"trailing-block\",\n      editor: {\n        normalizeNode: (entry) => {\n          if (!Editor.isEditor(entry[0])) return false\n          const lastPath = [editor.children.length - 1]\n          /**\n           * We expect the last node of the Editor to be an `Element` because\n           * the children of an `Editor` are `Element` objects.\n           */\n          const lastElement = Node.child(\n            editor,\n            editor.children.length - 1\n          ) as Element\n          /**\n           * We need to add a trailing block when it is not easy for us to\n           * start typing at the end of the document. This happens in these\n           * conditions:\n           *\n           * - The last Element is a `void` block that we can't type into\n           * - The last Element is an Element that contains child elements\n           *   like a `table` or a nested `list`.\n           */\n          if (\n            Editor.hasBlocks(editor, lastElement) ||\n            Editor.isVoid(editor, lastElement)\n          ) {\n            Transforms.insertNodes(\n              editor,\n              { type: \"paragraph\", children: [{ text: \"\" }] },\n              {\n                at: Path.next(lastPath),\n              }\n            )\n          }\n          return true\n        },\n      },\n    }\n  }\n) as TypedPlugin<TrailingBlockPluginCustomType>\n","import { Client, createClient } from \"@portive/client\"\n\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { createUploadMethods } from \"./methods\"\nimport { createUploadStore } from \"./store\"\n\ntype UploadMethods = ReturnType<typeof createUploadMethods>\n\ntype UploadFileEvent = { hashUrl: string; file: File }\ntype UploadImageFileEvent = UploadFileEvent & { width: number; height: number }\n\ntype UploadFileSuccessEvent = UploadFileEvent & { url: string }\ntype UploadImageFileSuccessEvent = UploadImageFileEvent & { url: string }\n\nexport type UploadEditor = {\n  upload: UploadMethods & {\n    client?: Client\n    onUploadImageFile: (e: UploadImageFileEvent) => boolean\n    onUploadFile: (e: UploadFileEvent) => boolean\n    onUploadImageFileSuccess: (e: UploadImageFileSuccessEvent) => boolean\n    onUploadFileSuccess: (e: UploadFileSuccessEvent) => boolean\n    useUploadStore: ReturnType<typeof createUploadStore>\n  }\n}\n\nexport type UploadOptions = { upload?: { authToken?: string } }\n\nexport type UploadPluginCustomTypes = {\n  Name: \"upload\"\n  Editor: UploadEditor\n  Options: UploadOptions\n}\n\nexport const UploadPlugin = //({ authToken }: { authToken?: string }) =>\n  createPlugin<UploadPluginCustomTypes>((editor, options) => {\n    const authToken = options.upload?.authToken\n    if (!authToken) {\n      console.warn(`No authToken provided. Uploads are disabled.`)\n    }\n    const client = authToken ? createClient({ authToken }) : undefined\n    editor.upload = {\n      client,\n      onUploadImageFile: () => {\n        console.log(\"called onUploadImageFile\")\n        return false\n      },\n      onUploadFile: () => {\n        console.log(\"called onUploadFile\")\n        return false\n      },\n      onUploadImageFileSuccess: () => {\n        console.log(\"called onUploadImageFileSuccess\")\n        return false\n      },\n      onUploadFileSuccess: () => {\n        console.log(\"called onUploadFileSuccess\")\n        return false\n      },\n      useUploadStore: createUploadStore(),\n      ...createUploadMethods(editor),\n    }\n\n    const editableProps = authToken\n      ? {\n          onPaste(e: React.ClipboardEvent) {\n            const files = e.nativeEvent.clipboardData?.files\n            if (!files || files.length === 0) return false\n            for (const file of files) {\n              editor.upload.upload(file)\n            }\n            return true\n          },\n          onDrop(e: React.DragEvent) {\n            const files = e.nativeEvent.dataTransfer?.files\n            if (!files || files.length === 0) return false\n            for (const file of files) {\n              editor.upload.upload(file)\n            }\n            return true\n          },\n        }\n      : {}\n    return {\n      name: \"upload\",\n      editor: {},\n      editableProps,\n    }\n  }) as TypedPlugin<UploadPluginCustomTypes>\n","import { Editor, Element } from \"slate\"\nimport { RequireExactlyOne } from \"type-fest\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { setElementTimeTraveling } from \"./setElementTimeTraveling\"\nimport { upload } from \"./upload\"\n\nexport function createUploadMethods(editor: Editor) {\n  return {\n    upload: curryOne(upload, editor),\n    setElementTimeTraveling: <T extends Element, K extends keyof T = keyof T>(\n      prev: RequireExactlyOne<T, K>,\n      next: RequireExactlyOne<T, K>\n    ) => setElementTimeTraveling(editor, prev, next),\n  }\n}\n","import {\n  BaseOperation,\n  Editor,\n  Element,\n  SetNodeOperation,\n  Transforms,\n} from \"slate\"\nimport { History } from \"slate-history\"\nimport { RequireExactlyOne } from \"type-fest\"\n\n/**\n * Extract the last operatioon from Slate's undo history. It is the last\n * operation in the last batch of the undo history.\n */\nfunction extractLastOp(history: History): BaseOperation {\n  const lastBatch = history.undos[history.undos.length - 1]\n  return lastBatch.operations[lastBatch.operations.length - 1]\n}\n\n/**\n * Extracts the most recent `set_node` operation from Slate's undo history.\n */\nfunction extractSetNodeOp(history: History): SetNodeOperation {\n  const lastOp = extractLastOp(history)\n  if (lastOp.type !== \"set_node\")\n    throw new Error(`Expected set_node operation, got ${lastOp.type}.`)\n  return lastOp\n}\n\n/**\n * This function updates an element in the editor in a way that makes Slate\n * think that the element was always the updated value.\n *\n * It does this by modifying the undo history:\n *\n * - modifies the initial `insert_node` operation\n * - modifies any `remove_node` operations so it reverts to the updated value\n * - modifies any `set_node` operations so it reverts to the updated value\n */\nexport function setElementTimeTraveling<\n  T extends Element,\n  K extends keyof T = keyof T\n>(\n  editor: Editor,\n  prev: RequireExactlyOne<T, K>,\n  next: RequireExactlyOne<T, K>\n) {\n  const keys = Object.keys(prev) as Array<K>\n  const key = keys[0]\n  const prevValue = prev[key] as unknown as T[K]\n\n  /**\n   * Modify the initial `insert_node` operation so that Slate thinks the\n   * value we updated the node to is the value it originally inserted.\n   *\n   * Also modify any `remove_node` operations so that when we undo them,\n   * they undo to the value we updated the node to.\n   *\n   * We do these together here as a performance optimization.\n   */\n  const { undos } = editor.history\n  for (const undo of undos) {\n    for (const op of undo.operations) {\n      if (\n        (op.type === \"insert_node\" || op.type === \"remove_node\") &&\n        (op.node as T)[key] === prevValue\n      ) {\n        op.node = { ...op.node, ...next }\n      }\n    }\n  }\n\n  const nodeEntries = [\n    ...Editor.nodes(editor, {\n      mode: \"all\",\n      at: [],\n      match: (n) =>\n        Element.isElement(n) &&\n        /**\n         * We can typecast here because when we know `n.type` is the same as\n         * `el.type`, we know that `n` is of type `T`.\n         */\n        (n as T)[key] === prevValue,\n    }),\n  ]\n\n  /**\n   * We need to search through `children` to find all instances of the node\n   * that we want to update. Note that the user could have copy and pasted or\n   * cut and pasted so there may be multiple instances of the Element.\n   */\n  for (const nodeEntry of nodeEntries) {\n    Transforms.setNodes(editor, next, { at: nodeEntry[1] })\n    const lastSetNodeOp = extractSetNodeOp(editor.history)\n    lastSetNodeOp.properties = next\n  }\n}\n\n/**\n * This is the return type of `insertTimeTravelingElement`\n */\nexport type TimeTravelingElement<T extends Element> = {\n  setNode: (partial: Partial<T>) => void\n  insertedElement: T\n}\n","import { uploadFile } from \"@portive/client\"\nimport { nanoid } from \"nanoid\"\nimport { Editor } from \"slate\"\n\nimport { setUpload } from \"../store\"\n\n/**\n * Initiate the upload process with a file.\n */\nexport function upload(editor: Editor, file: File) {\n  const { client } = editor.upload\n  if (client === undefined)\n    /**\n     * NOTE: This indicates a logic error. When `authToken` is not defined, all\n     * code that uses the upload function should be disabled.\n     */\n    throw new Error(\n      `Expected editor.upload.client to be defined if upload is being called`\n    )\n  /**\n   * Before an upload is completed, we give the file what we call a hash URL\n   * which is identified by starting with a `#` and followed by a unique id\n   * that can be used to find the current state of the file upload from start\n   * to completed upload.\n   */\n  const hashUrl = `$${nanoid()}`\n  const objectUrl = URL.createObjectURL(file)\n  uploadFile({\n    client,\n    file,\n    onBeforeFetch: ({ clientFile }) => {\n      setUpload(editor, hashUrl, {\n        status: \"progress\",\n        url: objectUrl,\n        sentBytes: 0,\n        totalBytes: clientFile.bytes,\n      })\n      /**\n       * If it's an image, we try to handle it with `onUploadImageFile`.\n       */\n      if (clientFile.type === \"image\") {\n        if (\n          editor.upload.onUploadImageFile({\n            hashUrl,\n            file,\n            width: clientFile.width,\n            height: clientFile.height,\n          })\n        )\n          return true\n      }\n      /**\n       * If it's not an image or `onUploadImageFile` doesn't handle it, then\n       * we allow the more general `onUploadFile` to handle it.\n       */\n      if (editor.upload.onUploadFile({ hashUrl, file })) return true\n      return false\n    },\n    onProgress: ({ sentBytes, totalBytes }) => {\n      setUpload(editor, hashUrl, {\n        status: \"progress\",\n        url: objectUrl,\n        sentBytes,\n        totalBytes,\n      })\n    },\n    onError: (e) => {\n      setUpload(editor, hashUrl, {\n        status: \"error\",\n        url: objectUrl,\n        message: e.message,\n      })\n    },\n    onSuccess: (e) => {\n      setUpload(editor, hashUrl, {\n        status: \"success\",\n        url: e.hostedFile.url,\n      })\n      if (e.hostedFile.type === \"image\") {\n        if (\n          editor.upload.onUploadImageFileSuccess({\n            hashUrl,\n            file,\n            width: e.hostedFile.width,\n            height: e.hostedFile.height,\n            url: e.hostedFile.url,\n          })\n        )\n          return true\n      }\n      editor.upload.onUploadFileSuccess({\n        hashUrl,\n        file,\n        url: e.hostedFile.url,\n      })\n    },\n  })\n  return false\n}\n","import { Editor, Transforms } from \"slate\"\nimport { ReactEditor } from \"slate-react\"\n\nimport { AnchorElement } from \"~/src/anchor-plugin\"\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nimport { UploadEditor } from \"../upload-plugin\"\n\nexport type AttachmentEditor = {\n  attachment: {}\n}\n\nexport type AttachmentPluginCustomTypes = {\n  Name: \"attachment\"\n  Editor: AttachmentEditor & UploadEditor\n}\n\nexport const AttachmentPlugin = createPlugin<AttachmentPluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.attachment = {}\n    editor.upload.onUploadFile = ({ hashUrl, file }) => {\n      const { selection } = editor\n      Transforms.insertText(editor, `🔗 `)\n      Transforms.insertNodes(editor, {\n        type: \"anchor\",\n        href: hashUrl,\n        children: [{ text: file.name }],\n      })\n      /**\n       * If there is no selection the element is inserted at the bottom of the\n       * editor. When this happens, the insertion point may not be visible and\n       * so this code scrolls to the bottom of the editor. We don't do this if\n       * there is a selection because if the user made a selection, it is\n       * likely already in view.\n       */\n      if (!selection) {\n        const lastPos = Editor.end(editor, [])\n        Transforms.select(editor, lastPos)\n        ReactEditor.focus(editor)\n      }\n      /**\n       * Moves the cursor just outside of the inserted Anchor element.\n       */\n      Transforms.move(editor, { distance: 1, unit: \"offset\" })\n      return true\n    }\n\n    editor.upload.onUploadFileSuccess = (e) => {\n      editor.upload.setElementTimeTraveling<AnchorElement>(\n        { href: e.hashUrl },\n        { href: e.url }\n      )\n      return true\n    }\n\n    return createPolicy({\n      name: \"attachment\",\n    })\n  }\n) as TypedPlugin<AttachmentPluginCustomTypes>\n","import { createPlugin, stopEvent, TypedPlugin } from \"~/src/sink\"\n\nimport { createPasteMarkdownMethods } from \"./methods\"\n\ntype PasteMarkdownMethods = ReturnType<typeof createPasteMarkdownMethods>\n\nexport type PasteMarkdownEditor = {\n  pasteMarkdown: PasteMarkdownMethods\n}\n\nexport type PasteMarkdownPluginCustomTypes = {\n  Name: \"paste-markdown\"\n  Editor: PasteMarkdownEditor\n}\n\nexport const PasteMarkdownPlugin = createPlugin<PasteMarkdownPluginCustomTypes>(\n  (editor) => {\n    editor.pasteMarkdown = createPasteMarkdownMethods(editor)\n    return {\n      name: \"paste-markdown\",\n      editor: {},\n      editableProps: {\n        onPaste(e) {\n          const { types } = e.clipboardData\n          if (types.length !== 1 || types[0] !== \"text/plain\") {\n            return false\n          }\n          const markdown = e.clipboardData.getData(\"text/plain\")\n          editor.pasteMarkdown.pasteMarkdown(markdown)\n          stopEvent(e)\n          return true\n        },\n      },\n    }\n  }\n) as TypedPlugin<PasteMarkdownPluginCustomTypes>\n","import { Editor, Transforms } from \"slate\"\n\nimport { curryOne } from \"~/src/sink\"\n\nimport { parse } from \"../../convert\"\n\nfunction pasteMarkdown(editor: Editor, markdown: string) {\n  const fragment = parse(markdown)\n  Transforms.insertNodes(editor, fragment)\n}\n\nexport function createPasteMarkdownMethods(editor: Editor) {\n  return {\n    pasteMarkdown: curryOne(pasteMarkdown, editor),\n  }\n}\n","import { RenderPlaceholderProps } from \"slate-react\"\n\nimport { createPlugin, TypedPlugin } from \"~/src/sink\"\n\nexport type PlaceholderEditor = {\n  placeholder: {}\n}\n\nexport type PlaceholderPluginCustomTypes = {\n  Name: \"placeholder\"\n  Editor: PlaceholderEditor\n}\n\n/**\n * To have the placeholder work properly, it cannot have `width: 100%` and\n * `max-width: 100%` set or it creates horizontal scrollbars.\n *\n * The default `renderPlaceholder` adds these styles so we override them.\n */\nfunction renderPlaceholder(props: RenderPlaceholderProps) {\n  const nextAttributes: RenderPlaceholderProps[\"attributes\"] = {\n    ...props.attributes,\n    style: {\n      ...props.attributes.style,\n      width: undefined,\n      maxWidth: undefined,\n    },\n  }\n  return <span {...nextAttributes}>{props.children}</span>\n}\n\nexport const PlaceholderPlugin = createPlugin<PlaceholderPluginCustomTypes>(\n  (editor, options, { createPolicy }) => {\n    editor.placeholder = {}\n    return createPolicy({\n      name: \"placeholder\",\n      editableProps: {\n        renderPlaceholder,\n      },\n    })\n  }\n) as TypedPlugin<PlaceholderPluginCustomTypes>\n","import { useState } from \"react\"\nimport { createEditor, Editor, Transforms } from \"slate\"\nimport { withHistory } from \"slate-history\"\nimport { ReactEditor, withReact } from \"slate-react\"\n\nimport { parse, serialize } from \"../convert\"\nimport { Element } from \"./plugins\"\nimport { withSink } from \"./SinkEditable\"\nimport { WysimarkEditor } from \"./types\"\n\nexport function useEditor({\n  authToken,\n  height,\n  minHeight,\n  maxHeight,\n}: {\n  authToken?: string\n  height?: string | number\n  minHeight?: string | number\n  maxHeight?: string | number\n}): Editor & ReactEditor & WysimarkEditor {\n  const [editor] = useState(() => {\n    const editor = createEditor()\n    const nextEditor = withSink(withReact(withHistory(editor)), {\n      upload: { authToken },\n      image: {},\n      toolbar: {\n        height,\n        minHeight,\n        maxHeight,\n        /**\n         * If `authToken` is provided then show upload buttons.\n         */\n        showUploadButtons: !!authToken,\n      },\n    })\n    nextEditor.convertElement.addConvertElementType(\"paragraph\")\n    editor.wysimark = {\n      //   initialMarkdown,\n      //   initialValue: parse(initialMarkdown),\n    }\n    editor.getMarkdown = () => {\n      return serialize(editor.children as Element[])\n    }\n    editor.setMarkdown = (markdown: string) => {\n      const documentValue = parse(markdown)\n      editor.children = documentValue\n      editor.selection = null\n      Transforms.select(editor, Editor.start(editor, [0]))\n    }\n    return nextEditor\n  })\n\n  return editor\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,OAAO,WAAW;AAHlB;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAOA,WAAO,UAAU,SAASA,UAAU,KAAK;AACvC,aAAO,OAAO,QAAQ,IAAI,eAAe,QACvC,OAAO,IAAI,YAAY,aAAa,cAAc,IAAI,YAAY,SAAS,GAAG;AAAA,IAClF;AAAA;AAAA;;;ACVA;AAAA;AAAA;AAAA;AAEA,QAAI,SAAS,OAAO,UAAU;AAC9B,QAAI,QAAQ,OAAO,UAAU;AAC7B,QAAI,iBAAiB,OAAO;AAC5B,QAAI,OAAO,OAAO;AAElB,QAAI,UAAU,SAASC,SAAQ,KAAK;AACnC,UAAI,OAAO,MAAM,YAAY,YAAY;AACxC,eAAO,MAAM,QAAQ,GAAG;AAAA,MACzB;AAEA,aAAO,MAAM,KAAK,GAAG,MAAM;AAAA,IAC5B;AAEA,QAAIC,iBAAgB,SAASA,eAAc,KAAK;AAC/C,UAAI,CAAC,OAAO,MAAM,KAAK,GAAG,MAAM,mBAAmB;AAClD,eAAO;AAAA,MACR;AAEA,UAAI,oBAAoB,OAAO,KAAK,KAAK,aAAa;AACtD,UAAI,mBAAmB,IAAI,eAAe,IAAI,YAAY,aAAa,OAAO,KAAK,IAAI,YAAY,WAAW,eAAe;AAE7H,UAAI,IAAI,eAAe,CAAC,qBAAqB,CAAC,kBAAkB;AAC/D,eAAO;AAAA,MACR;AAIA,UAAIC;AACJ,WAAKA,QAAO,KAAK;AAAA,MAAO;AAExB,aAAO,OAAOA,SAAQ,eAAe,OAAO,KAAK,KAAKA,IAAG;AAAA,IAC1D;AAGA,QAAI,cAAc,SAASC,aAAY,QAAQ,SAAS;AACvD,UAAI,kBAAkB,QAAQ,SAAS,aAAa;AACnD,uBAAe,QAAQ,QAAQ,MAAM;AAAA,UACpC,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,OAAO,QAAQ;AAAA,UACf,UAAU;AAAA,QACX,CAAC;AAAA,MACF,OAAO;AACN,eAAO,QAAQ,IAAI,IAAI,QAAQ;AAAA,MAChC;AAAA,IACD;AAGA,QAAI,cAAc,SAASC,aAAY,KAAK,MAAM;AACjD,UAAI,SAAS,aAAa;AACzB,YAAI,CAAC,OAAO,KAAK,KAAK,IAAI,GAAG;AAC5B,iBAAO;AAAA,QACR,WAAW,MAAM;AAGhB,iBAAO,KAAK,KAAK,IAAI,EAAE;AAAA,QACxB;AAAA,MACD;AAEA,aAAO,IAAI,IAAI;AAAA,IAChB;AAEA,WAAO,UAAU,SAASC,UAAS;AAClC,UAAI,SAAS,MAAM,KAAK,MAAM,aAAa;AAC3C,UAAI,SAAS,UAAU,CAAC;AACxB,UAAI,IAAI;AACR,UAAI,SAAS,UAAU;AACvB,UAAI,OAAO;AAGX,UAAI,OAAO,WAAW,WAAW;AAChC,eAAO;AACP,iBAAS,UAAU,CAAC,KAAK,CAAC;AAE1B,YAAI;AAAA,MACL;AACA,UAAI,UAAU,QAAS,OAAO,WAAW,YAAY,OAAO,WAAW,YAAa;AACnF,iBAAS,CAAC;AAAA,MACX;AAEA,aAAO,IAAI,QAAQ,EAAE,GAAG;AACvB,kBAAU,UAAU,CAAC;AAErB,YAAI,WAAW,MAAM;AAEpB,eAAK,QAAQ,SAAS;AACrB,kBAAM,YAAY,QAAQ,IAAI;AAC9B,mBAAO,YAAY,SAAS,IAAI;AAGhC,gBAAI,WAAW,MAAM;AAEpB,kBAAI,QAAQ,SAASJ,eAAc,IAAI,MAAM,cAAc,QAAQ,IAAI,KAAK;AAC3E,oBAAI,aAAa;AAChB,gCAAc;AACd,0BAAQ,OAAO,QAAQ,GAAG,IAAI,MAAM,CAAC;AAAA,gBACtC,OAAO;AACN,0BAAQ,OAAOA,eAAc,GAAG,IAAI,MAAM,CAAC;AAAA,gBAC5C;AAGA,4BAAY,QAAQ,EAAE,MAAY,UAAUI,QAAO,MAAM,OAAO,IAAI,EAAE,CAAC;AAAA,cAGxE,WAAW,OAAO,SAAS,aAAa;AACvC,4BAAY,QAAQ,EAAE,MAAY,UAAU,KAAK,CAAC;AAAA,cACnD;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAGA,aAAO;AAAA,IACR;AAAA;AAAA;;;ACpHA;;;ACAA;AAAA;AAAA,EACE;AAAA,EAEA,eAAAC;AAAA,EACA;AAAA,EACA,UAAAC;AAAA,EACA,YAAAC;AAAA,OACK;AACP,SAAS,kBAAkB;;;ACR3B;AAAA,OAAOC,eAAc;AACrB,SAAS,eAAAC,eAAa,UAAAC,gBAAc;AACpC,SAAqB,UAAAC,UAAiB,cAAAC,oBAAkB;AACxD,SAAS,eAAAC,eAA8B,SAAAC,cAAa;;;ACHpD;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAsBO,SAAS,OAAOC,OAAM,OAAO,QAAQ,OAAO;AACjD,QAAM,MAAMA,MAAK;AACjB,MAAI,aAAa;AAEjB,MAAI;AAGJ,MAAI,QAAQ,GAAG;AACb,YAAQ,CAAC,QAAQ,MAAM,IAAI,MAAM;AAAA,EACnC,OAAO;AACL,YAAQ,QAAQ,MAAM,MAAM;AAAA,EAC9B;AACA,WAAS,SAAS,IAAI,SAAS;AAG/B,MAAI,MAAM,SAAS,KAAO;AACxB,iBAAa,MAAM,KAAK,KAAK;AAC7B,eAAW,QAAQ,OAAO,MAAM;AAEhC,IAAAA,MAAK,OAAO,GAAG,UAAU;AAAA,EAC3B,OAAO;AAEL,QAAI;AAAQ,MAAAA,MAAK,OAAO,OAAO,MAAM;AAGrC,WAAO,aAAa,MAAM,QAAQ;AAChC,mBAAa,MAAM,MAAM,YAAY,aAAa,GAAK;AACvD,iBAAW,QAAQ,OAAO,CAAC;AAE3B,MAAAA,MAAK,OAAO,GAAG,UAAU;AACzB,oBAAc;AACd,eAAS;AAAA,IACX;AAAA,EACF;AACF;AAkBO,SAAS,KAAKA,OAAM,OAAO;AAChC,MAAIA,MAAK,SAAS,GAAG;AACnB,WAAOA,OAAMA,MAAK,QAAQ,GAAG,KAAK;AAClC,WAAOA;AAAA,EACT;AACA,SAAO;AACT;;;ADvEA,IAAM,iBAAiB,CAAC,EAAE;AAUnB,SAAS,kBAAkB,YAAY;AAE5C,QAAMC,OAAM,CAAC;AACb,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQ,WAAW,QAAQ;AAClC,oBAAgBD,MAAK,WAAWC,MAAK,CAAC;AAAA,EACxC;AAEA,SAAOD;AACT;AAWA,SAAS,gBAAgBA,MAAKE,YAAW;AAEvC,MAAI;AAEJ,OAAK,QAAQA,YAAW;AACtB,UAAM,QAAQ,eAAe,KAAKF,MAAK,IAAI,IAAIA,KAAI,IAAI,IAAI;AAE3D,UAAM,OAAO,UAAUA,KAAI,IAAI,IAAI,CAAC;AAEpC,UAAM,QAAQE,WAAU,IAAI;AAE5B,QAAIC;AAEJ,QAAI,OAAO;AACT,WAAKA,SAAQ,OAAO;AAClB,YAAI,CAAC,eAAe,KAAK,MAAMA,KAAI;AAAG,eAAKA,KAAI,IAAI,CAAC;AACpD,cAAM,QAAQ,MAAMA,KAAI;AACxB;AAAA;AAAA,UAEE,KAAKA,KAAI;AAAA,UACT,MAAM,QAAQ,KAAK,IAAI,QAAQ,QAAQ,CAAC,KAAK,IAAI,CAAC;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAUA,SAAS,WAAW,UAAUC,OAAM;AAClC,MAAIH,SAAQ;AAEZ,QAAM,SAAS,CAAC;AAEhB,SAAO,EAAEA,SAAQG,MAAK,QAAQ;AAE5B;AAAC,KAACA,MAAKH,MAAK,EAAE,QAAQ,UAAU,WAAW,QAAQ,KAAKG,MAAKH,MAAK,CAAC;AAAA,EACrE;AAEA,SAAO,UAAU,GAAG,GAAG,MAAM;AAC/B;;;AEtFA;;;ACAA;;;ACAA;;;ACAA;AAUO,IAAM,0BACX;;;ADYK,IAAM,aAAa,WAAW,UAAU;AAcxC,IAAM,oBAAoB,WAAW,YAAY;AAuBjD,IAAM,aAAa,WAAW,qBAAqB;AAanD,SAAS,aAAaI,OAAM;AACjC;AAAA;AAAA;AAAA,IAGEA,UAAS,SAASA,QAAO,MAAMA,UAAS;AAAA;AAE5C;AAaO,IAAM,aAAa,WAAW,IAAI;AAoBlC,IAAM,gBAAgB,WAAW,YAAY;AAe7C,IAAM,mBAAmB,WAAW,gBAAgB;AAiBpD,SAAS,mBAAmBA,OAAM;AACvC,SAAOA,UAAS,QAAQA,QAAO;AACjC;AAWO,SAAS,0BAA0BA,OAAM;AAC9C,SAAOA,UAAS,SAASA,QAAO,KAAKA,UAAS;AAChD;AAiBO,SAAS,cAAcA,OAAM;AAClC,SAAOA,UAAS,MAAMA,UAAS,MAAMA,UAAS;AAChD;AAuBO,IAAM,qBAAqB,WAAW,uBAAuB;AAsB7D,IAAM,oBAAoB,WAAW,IAAI;AAQhD,SAAS,WAAW,OAAO;AACzB,SAAO;AAUP,WAAS,MAAMA,OAAM;AACnB,WAAOA,UAAS,QAAQ,MAAM,KAAK,OAAO,aAAaA,KAAI,CAAC;AAAA,EAC9D;AACF;;;ADlOA,IAAM,YAAY;AAAA,EAChB,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,SAAS;AAAA,EACb,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,OAAO;AAAA,EACX,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,QAAQ;AAAA,EACZ,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,sBAAsB;AAAA,EAC1B,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,cAAc;AAAA,EAClB,UAAU;AAAA,EACV,UAAU;AACZ;AACA,IAAM,mBAAmB;AAAA,EACvB,UAAU;AAAA,EACV,UAAU;AACZ;AACA,IAAM,gBAAgB;AAAA,EACpB,UAAU;AAAA,EACV,UAAU;AACZ;AAGA,IAAM,OAAO,CAAC;AAUP,IAAM,qBAAqB;AAAA,EAChC;AACF;AAGA,IAAI,OAAO;AAGX,OAAO,OAAO,KAAK;AACjB,OAAK,IAAI,IAAI;AACb;AACA,MAAI,SAAS;AAAI,WAAO;AAAA,WACf,SAAS;AAAI,WAAO;AAC/B;AACA,KAAK,EAAE,IAAI;AACX,KAAK,EAAE,IAAI;AACX,KAAK,EAAE,IAAI;AACX,KAAK,EAAE,IAAI;AACX,KAAK,EAAE,IAAI,CAAC,eAAe,gBAAgB;AAC3C,KAAK,GAAG,IAAI,CAAC,eAAe,gBAAgB;AAC5C,KAAK,EAAE,IAAI,CAAC,eAAe,WAAW;AACtC,KAAK,GAAG,IAAI,CAAC,eAAe,WAAW;AAmBvC,SAAS,sBAAsB,SAASC,KAAI,KAAK;AAC/C,QAAM,OAAO;AAEb,MAAI;AAEJ,MAAIC;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,QACE,CAAC,SAASA,KAAI,KACd,CAAC,cAAc,KAAK,MAAM,KAAK,QAAQ,KACvC,mBAAmB,KAAK,MAAM,GAC9B;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,MAAM,sBAAsB;AACpC,WAAO,MAAMA,KAAI;AAAA,EACnB;AAYA,WAAS,MAAMA,OAAM;AACnB,QAAI,SAASA,KAAI,GAAG;AAClB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAgBA,WAAS,YAAYA,OAAM;AAEzB,QAAIA,UAAS,IAAI;AACf,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAEA,KAAI;AAAA,IACR;AAGA,QAAIA,UAAS,MAAMA,UAAS,MAAM,kBAAkBA,KAAI,GAAG;AACzD,MAAAD,QAAO;AACP,cAAQ,QAAQC,KAAI;AACpB,aAAO;AAAA,IACT;AAQA,WAAO,iBAAiBA,KAAI;AAAA,EAC9B;AAYA,WAAS,eAAeA,OAAM;AAC5B,YAAQ,QAAQA,KAAI;AACpB,UAAM;AACN,WAAO;AAAA,EACT;AAYA,WAAS,iBAAiBA,OAAM;AAG9B,QAAID,SAAQ,OAAO,WAAW,KAAK,QAAQ,GAAG;AAC5C,cAAQ,KAAK,sBAAsB;AACnC,cAAQ,KAAK,iBAAiB;AAC9B,aAAOD,IAAGE,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAaA,SAAS,oBAAoB,SAASF,KAAI,KAAK;AAC7C,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,SAASE,OAAM;AACtB,QACGA,UAAS,MAAMA,UAAS,OACzB,CAAC,YAAY,KAAK,MAAM,KAAK,QAAQ,KACrC,mBAAmB,KAAK,MAAM,GAC9B;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,MAAM,oBAAoB;AAGlC,WAAO,QAAQ;AAAA,MACb;AAAA,MACA,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,MAAM,QAAQ,GAAG,GAAG;AAAA,MAC5D;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,SAASA,OAAM;AACtB,YAAQ,KAAK,oBAAoB;AACjC,YAAQ,KAAK,iBAAiB;AAC9B,WAAOF,IAAGE,KAAI;AAAA,EAChB;AACF;AAaA,SAAS,yBAAyB,SAASF,KAAI,KAAK;AAClD,QAAM,OAAO;AACb,MAAIG,UAAS;AACb,MAAI,OAAO;AACX,SAAO;AAYP,WAAS,cAAcD,OAAM;AAC3B,SACGA,UAAS,MAAMA,UAAS,QACzB,iBAAiB,KAAK,MAAM,KAAK,QAAQ,KACzC,CAAC,mBAAmB,KAAK,MAAM,GAC/B;AACA,cAAQ,MAAM,iBAAiB;AAC/B,cAAQ,MAAM,qBAAqB;AACnC,MAAAC,WAAU,OAAO,cAAcD,KAAI;AACnC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,qBAAqBA,OAAM;AAElC,QAAI,WAAWA,KAAI,KAAKC,QAAO,SAAS,GAAG;AAEzC,MAAAA,WAAU,OAAO,cAAcD,KAAI;AACnC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,YAAM,WAAWC,QAAO,YAAY;AACpC,UAAI,aAAa,UAAU,aAAa,SAAS;AAC/C,gBAAQ,QAAQD,KAAI;AACpB,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,sBAAsBA,OAAM;AACnC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,UAAI,MAAM;AACR,eAAO;AAAA,MACT;AACA,aAAO;AACP,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,cAAcA,OAAM;AAG3B,WAAOA,UAAS,QACd,aAAaA,KAAI,KACjB,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI,KACtB,mBAAmBA,KAAI,IACrB,IAAIA,KAAI,IACR,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,MAAM,aAAa,GAAG,GAAG,EAAEA,KAAI;AAAA,EAC7E;AAYA,WAAS,cAAcA,OAAM;AAC3B,YAAQ,KAAK,qBAAqB;AAClC,YAAQ,KAAK,iBAAiB;AAC9B,WAAOF,IAAGE,KAAI;AAAA,EAChB;AACF;AAaA,SAAS,kBAAkB,SAASF,KAAI,KAAK;AAC3C,MAAI,OAAO;AACX,SAAO;AAYP,WAAS,gBAAgBE,OAAM;AAC7B,SAAKA,UAAS,MAAMA,UAAS,QAAQ,OAAO,GAAG;AAC7C;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM,SAAS,GAAG;AAC7B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,eAAeA,OAAM;AAE5B,WAAOA,UAAS,OAAO,IAAIA,KAAI,IAAIF,IAAGE,KAAI;AAAA,EAC5C;AACF;AAaA,SAAS,eAAe,SAASF,KAAI,KAAK;AAExC,MAAI;AAEJ,MAAI;AAEJ,MAAI;AACJ,SAAO;AAYP,WAAS,aAAaE,OAAM;AAI1B,QAAIA,UAAS,MAAMA,UAAS,IAAI;AAC9B,aAAO,QAAQ,MAAM,OAAO,aAAa,mBAAmB,EAAEA,KAAI;AAAA,IACpE;AAQA,QACEA,UAAS,QACT,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI,KACrBA,UAAS,MAAM,mBAAmBA,KAAI,GACvC;AACA,aAAO,YAAYA,KAAI;AAAA,IACzB;AACA,WAAO;AACP,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,oBAAoBA,OAAM;AAEjC,QAAIA,UAAS,IAAI;AACf,gCAA0B;AAAA,IAC5B,OAGK;AACH,oCAA8B;AAC9B,gCAA0B;AAAA,IAC5B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAWA,WAAS,YAAYA,OAAM;AAGzB,QAAI,+BAA+B,2BAA2B,CAAC,MAAM;AACnE,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,WAAOF,IAAGE,KAAI;AAAA,EAChB;AACF;AAaA,SAAS,aAAa,SAASF,KAAI;AACjC,MAAI,WAAW;AACf,MAAI,YAAY;AAChB,SAAO;AAYP,WAAS,WAAWE,OAAM;AACxB,QAAIA,UAAS,IAAI;AACf;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAKA,QAAIA,UAAS,MAAM,YAAY,UAAU;AACvC,aAAO,kBAAkBA,KAAI;AAAA,IAC/B;AAKA,QACEA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,KACT;AACA,aAAO,QAAQ,MAAM,OAAOF,KAAI,iBAAiB,EAAEE,KAAI;AAAA,IACzD;AACA,QACEA,UAAS,QACT,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI,GACtB;AACA,aAAOF,IAAGE,KAAI;AAAA,IAChB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,kBAAkBA,OAAM;AAE/B,QAAIA,UAAS,IAAI;AACf;AAAA,IACF;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AACF;AAiBA,SAAS,cAAc,SAASF,KAAI,KAAK;AACvC,SAAOI;AAYP,WAASA,OAAMF,OAAM;AAEnB,QACEA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,KACT;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAOE;AAAA,IACT;AAKA,QAAIF,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAKA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA;AAAA;AAAA,MAEEA,UAAS;AAAA,MAETA,UAAS,QACT,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI;AAAA,MACtB;AACA,aAAOF,IAAGE,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAeA,WAAS,kBAAkBA,OAAM;AAG/B,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACT,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI,GACtB;AACA,aAAOF,IAAGE,KAAI;AAAA,IAChB;AACA,WAAOE,OAAMF,KAAI;AAAA,EACnB;AAYA,WAAS,kBAAkBA,OAAM;AAE/B,WAAO,WAAWA,KAAI,IAAI,mBAAmBA,KAAI,IAAI,IAAIA,KAAI;AAAA,EAC/D;AAYA,WAAS,mBAAmBA,OAAM;AAEhC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAOE;AAAA,IACT;AACA,QAAI,WAAWF,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAiBA,SAAS,4BAA4B,SAASF,KAAI,KAAK;AACrD,SAAO;AAYP,WAAS,MAAME,OAAM;AAEnB,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,MAAMA,OAAM;AAEnB,WAAO,kBAAkBA,KAAI,IAAI,IAAIA,KAAI,IAAIF,IAAGE,KAAI;AAAA,EACtD;AACF;AAQA,SAAS,YAAYA,OAAM;AACzB,SACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,OACT,0BAA0BA,KAAI;AAElC;AAQA,SAAS,iBAAiBA,OAAM;AAC9B,SAAO,CAAC,WAAWA,KAAI;AACzB;AAMA,SAAS,cAAcA,OAAM;AAK3B,SAAO,EAAEA,UAAS,MAAM,SAASA,KAAI;AACvC;AAMA,SAAS,SAASA,OAAM;AACtB,SACEA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACT,kBAAkBA,KAAI;AAE1B;AAMA,SAAS,mBAAmB,QAAQ;AAClC,MAAIG,SAAQ,OAAO;AACnB,MAAI,SAAS;AACb,SAAOA,UAAS;AACd,UAAM,QAAQ,OAAOA,MAAK,EAAE,CAAC;AAC7B,SACG,MAAM,SAAS,eAAe,MAAM,SAAS,iBAC9C,CAAC,MAAM,WACP;AACA,eAAS;AACT;AAAA,IACF;AAIA,QAAI,MAAM,+BAA+B;AACvC,eAAS;AACT;AAAA,IACF;AAAA,EACF;AACA,MAAI,OAAO,SAAS,KAAK,CAAC,QAAQ;AAGhC,WAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,gCAAgC;AAAA,EAC/D;AACA,SAAO;AACT;;;AG17BA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAuBO,SAAS,kBAAkBC,OAAM;AACtC,MACEA,UAAS,QACT,0BAA0BA,KAAI,KAC9B,kBAAkBA,KAAI,GACtB;AACA,WAAO;AAAA,EACT;AACA,MAAI,mBAAmBA,KAAI,GAAG;AAC5B,WAAO;AAAA,EACT;AACF;;;AClCA;AAkBO,SAAS,WAAWC,aAAY,QAAQ,SAAS;AAEtD,QAAM,SAAS,CAAC;AAChB,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQD,YAAW,QAAQ;AAClC,UAAM,UAAUA,YAAWC,MAAK,EAAE;AAElC,QAAI,WAAW,CAAC,OAAO,SAAS,OAAO,GAAG;AACxC,eAAS,QAAQ,QAAQ,OAAO;AAChC,aAAO,KAAK,OAAO;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AACT;;;AFjBO,IAAM,YAAY;AAAA,EACvB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,YAAY;AACd;AAOA,SAAS,oBAAoB,QAAQ,SAAS;AAC5C,MAAIC,SAAQ;AAEZ,MAAI;AAEJ,MAAI;AAEJ,MAAIC;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAMJ,SAAO,EAAED,SAAQ,OAAO,QAAQ;AAE9B,QACE,OAAOA,MAAK,EAAE,CAAC,MAAM,WACrB,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,uBAC1B,OAAOA,MAAK,EAAE,CAAC,EAAE,QACjB;AACA,aAAOA;AAGP,aAAO,QAAQ;AAEb,YACE,OAAO,IAAI,EAAE,CAAC,MAAM,UACpB,OAAO,IAAI,EAAE,CAAC,EAAE,SAAS,uBACzB,OAAO,IAAI,EAAE,CAAC,EAAE;AAAA,QAEhB,QAAQ,eAAe,OAAO,IAAI,EAAE,CAAC,CAAC,EAAE,WAAW,CAAC,MAClD,QAAQ,eAAe,OAAOA,MAAK,EAAE,CAAC,CAAC,EAAE,WAAW,CAAC,GACvD;AAKA,eACG,OAAO,IAAI,EAAE,CAAC,EAAE,UAAU,OAAOA,MAAK,EAAE,CAAC,EAAE,WAC3C,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,SAAS,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,UAAU,KAChE,GACG,OAAO,IAAI,EAAE,CAAC,EAAE,IAAI,SACnB,OAAO,IAAI,EAAE,CAAC,EAAE,MAAM,SACtB,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,SACrB,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,UACzB,IAEF;AACA;AAAA,UACF;AAGA,gBACE,OAAO,IAAI,EAAE,CAAC,EAAE,IAAI,SAAS,OAAO,IAAI,EAAE,CAAC,EAAE,MAAM,SAAS,KAC5D,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,SAAS,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,SAAS,IAC1D,IACA;AACN,gBAAM,QAAQ,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,GAAG;AACnD,gBAAM,MAAM,OAAO,OAAO,CAAC,GAAG,OAAOA,MAAK,EAAE,CAAC,EAAE,KAAK;AACpD,oBAAU,OAAO,CAAC,GAAG;AACrB,oBAAU,KAAK,GAAG;AAClB,4BAAkB;AAAA,YAChB,MAAM,MAAM,IAAI,mBAAmB;AAAA,YACnC;AAAA,YACA,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,GAAG;AAAA,UAC5C;AACA,4BAAkB;AAAA,YAChB,MAAM,MAAM,IAAI,mBAAmB;AAAA,YACnC,OAAO,OAAO,OAAO,CAAC,GAAG,OAAOA,MAAK,EAAE,CAAC,EAAE,KAAK;AAAA,YAC/C;AAAA,UACF;AACA,UAAAC,QAAO;AAAA,YACL,MAAM,MAAM,IAAI,eAAe;AAAA,YAC/B,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,GAAG;AAAA,YAC5C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAOD,MAAK,EAAE,CAAC,EAAE,KAAK;AAAA,UAC/C;AACA,kBAAQ;AAAA,YACN,MAAM,MAAM,IAAI,WAAW;AAAA,YAC3B,OAAO,OAAO,OAAO,CAAC,GAAG,gBAAgB,KAAK;AAAA,YAC9C,KAAK,OAAO,OAAO,CAAC,GAAG,gBAAgB,GAAG;AAAA,UAC5C;AACA,iBAAO,IAAI,EAAE,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAG,gBAAgB,KAAK;AAC7D,iBAAOA,MAAK,EAAE,CAAC,EAAE,QAAQ,OAAO,OAAO,CAAC,GAAG,gBAAgB,GAAG;AAC9D,uBAAa,CAAC;AAGd,cAAI,OAAO,IAAI,EAAE,CAAC,EAAE,IAAI,SAAS,OAAO,IAAI,EAAE,CAAC,EAAE,MAAM,QAAQ;AAC7D,yBAAa,KAAK,YAAY;AAAA,cAC5B,CAAC,SAAS,OAAO,IAAI,EAAE,CAAC,GAAG,OAAO;AAAA,cAClC,CAAC,QAAQ,OAAO,IAAI,EAAE,CAAC,GAAG,OAAO;AAAA,YACnC,CAAC;AAAA,UACH;AAGA,uBAAa,KAAK,YAAY;AAAA,YAC5B,CAAC,SAAS,OAAO,OAAO;AAAA,YACxB,CAAC,SAAS,iBAAiB,OAAO;AAAA,YAClC,CAAC,QAAQ,iBAAiB,OAAO;AAAA,YACjC,CAAC,SAASC,OAAM,OAAO;AAAA,UACzB,CAAC;AAKD,uBAAa;AAAA,YACX;AAAA,YACA;AAAA,cACE,QAAQ,OAAO,WAAW,WAAW;AAAA,cACrC,OAAO,MAAM,OAAO,GAAGD,MAAK;AAAA,cAC5B;AAAA,YACF;AAAA,UACF;AAGA,uBAAa,KAAK,YAAY;AAAA,YAC5B,CAAC,QAAQC,OAAM,OAAO;AAAA,YACtB,CAAC,SAAS,iBAAiB,OAAO;AAAA,YAClC,CAAC,QAAQ,iBAAiB,OAAO;AAAA,YACjC,CAAC,QAAQ,OAAO,OAAO;AAAA,UACzB,CAAC;AAGD,cAAI,OAAOD,MAAK,EAAE,CAAC,EAAE,IAAI,SAAS,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,QAAQ;AAC/D,qBAAS;AACT,yBAAa,KAAK,YAAY;AAAA,cAC5B,CAAC,SAAS,OAAOA,MAAK,EAAE,CAAC,GAAG,OAAO;AAAA,cACnC,CAAC,QAAQ,OAAOA,MAAK,EAAE,CAAC,GAAG,OAAO;AAAA,YACpC,CAAC;AAAA,UACH,OAAO;AACL,qBAAS;AAAA,UACX;AACA,iBAAO,QAAQ,OAAO,GAAGA,SAAQ,OAAO,GAAG,UAAU;AACrD,UAAAA,SAAQ,OAAO,WAAW,SAAS,SAAS;AAC5C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAAA,SAAQ;AACR,SAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,QAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,qBAAqB;AACjD,aAAOA,MAAK,EAAE,CAAC,EAAE,OAAO;AAAA,IAC1B;AAAA,EACF;AACA,SAAO;AACT;AAMA,SAAS,kBAAkB,SAASE,KAAI;AACtC,QAAMC,oBAAmB,KAAK,OAAO,WAAW,iBAAiB;AACjE,QAAMC,YAAW,KAAK;AACtB,QAAM,SAAS,kBAAkBA,SAAQ;AAGzC,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,aAASA;AACT,YAAQ,MAAM,mBAAmB;AACjC,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AACpB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,QAAQ,KAAK,mBAAmB;AAG9C,UAAM,QAAQ,kBAAkBA,KAAI;AAIpC,UAAM,OACJ,CAAC,SAAU,UAAU,KAAK,UAAWF,kBAAiB,SAASE,KAAI;AACrE,UAAM,QACJ,CAAC,UAAW,WAAW,KAAK,SAAUF,kBAAiB,SAASC,SAAQ;AAC1E,UAAM,QAAQ,QAAQ,WAAW,KAAK,OAAO,SAAS,UAAU,CAAC,MAAM;AACvE,UAAM,SAAS,QAAQ,WAAW,KAAK,QAAQ,UAAU,SAAS,CAAC,KAAK;AACxE,WAAOF,IAAGG,KAAI;AAAA,EAChB;AACF;AAYA,SAAS,UAAUC,QAAO,QAAQ;AAChC,EAAAA,OAAM,UAAU;AAChB,EAAAA,OAAM,UAAU;AAChB,EAAAA,OAAM,gBAAgB;AACxB;;;AGrQA;AAcO,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,iBAAiB,SAASC,KAAI,KAAK;AAC1C,MAAI,OAAO;AACX,SAAO;AAcP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,gBAAgB;AAC9B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,gBAAgB;AAC7B,YAAQ,MAAM,kBAAkB;AAChC,WAAO;AAAA,EACT;AAcA,WAAS,KAAKA,OAAM;AAClB,QAAI,WAAWA,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,WAAWA,KAAI;AAAA,EACxB;AAcA,WAAS,mBAAmBA,OAAM;AAEhC,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,MAAM,kBAAkBA,KAAI,GAAG;AAExE,aAAO;AACP,aAAO,yBAAyBA,KAAI;AAAA,IACtC;AACA,WAAO,WAAWA,KAAI;AAAA,EACxB;AAcA,WAAS,yBAAyBA,OAAM;AACtC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AACP,aAAO;AAAA,IACT;AAGA,SACGA,UAAS,MAAMA,UAAS,MAAMA,UAAS,MAAM,kBAAkBA,KAAI,MACpE,SAAS,IACT;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO;AACP,WAAO,WAAWA,KAAI;AAAA,EACxB;AAYA,WAAS,UAAUA,OAAM;AACvB,QAAIA,UAAS,IAAI;AACf,cAAQ,KAAK,kBAAkB;AAC/B,cAAQ,MAAM,gBAAgB;AAC9B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,gBAAgB;AAC7B,cAAQ,KAAK,UAAU;AACvB,aAAOD;AAAA,IACT;AAGA,QAAIC,UAAS,QAAQA,UAAS,MAAMA,UAAS,MAAM,aAAaA,KAAI,GAAG;AACrE,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,WAAWA,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,iBAAiBA,OAAM;AAC9B,WAAO,kBAAkBA,KAAI,IAAI,WAAWA,KAAI,IAAI,IAAIA,KAAI;AAAA,EAC9D;AAYA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AACP,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AAEf,cAAQ,KAAK,kBAAkB,EAAE,OAAO;AACxC,cAAQ,MAAM,gBAAgB;AAC9B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,gBAAgB;AAC7B,cAAQ,KAAK,UAAU;AACvB,aAAOD;AAAA,IACT;AACA,WAAO,WAAWC,KAAI;AAAA,EACxB;AAcA,WAAS,WAAWA,OAAM;AAExB,SAAKA,UAAS,MAAM,kBAAkBA,KAAI,MAAM,SAAS,IAAI;AAC3D,YAAM,OAAOA,UAAS,KAAK,aAAa;AACxC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;;;AC1OA;;;ACAA;AA0CO,SAAS,aAAa,SAASC,KAAI,MAAM,KAAK;AACnD,QAAM,QAAQ,MAAM,MAAM,IAAI,OAAO;AACrC,MAAI,OAAO;AACX,SAAO;AAGP,WAAS,MAAMC,OAAM;AACnB,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,MAAM,IAAI;AAClB,aAAO,OAAOA,KAAI;AAAA,IACpB;AACA,WAAOD,IAAGC,KAAI;AAAA,EAChB;AAGA,WAAS,OAAOA,OAAM;AACpB,QAAI,cAAcA,KAAI,KAAK,SAAS,OAAO;AACzC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,IAAI;AACjB,WAAOD,IAAGC,KAAI;AAAA,EAChB;AACF;;;ADvDO,IAAM,YAAY;AAAA,EACvB,UAAU;AAAA,EACV,SAAS;AACX;AAMA,SAAS,kBAAkB,SAASC,KAAI,KAAK;AAC3C,SAAO;AAgBP,WAAS,MAAMC,OAAM;AACnB,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,OAAO,YAAY,EAAEA,KAAI,IAC/C,MAAMA,KAAI;AAAA,EAChB;AAgBA,WAAS,MAAMA,OAAM;AACnB,WAAOA,UAAS,QAAQ,mBAAmBA,KAAI,IAAID,IAAGC,KAAI,IAAI,IAAIA,KAAI;AAAA,EACxE;AACF;;;AE3DA;AAWO,IAAM,aAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,cAAc;AAAA,IACZ,UAAU;AAAA,EACZ;AAAA,EACA;AACF;AAMA,SAAS,wBAAwB,SAASC,KAAI,KAAK;AACjD,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,QAAIA,UAAS,IAAI;AACf,YAAM,QAAQ,KAAK;AACnB,UAAI,CAAC,MAAM,MAAM;AACf,gBAAQ,MAAM,cAAc;AAAA,UAC1B,YAAY;AAAA,QACd,CAAC;AACD,cAAM,OAAO;AAAA,MACf;AACA,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAC/B,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,MAAMA,OAAM;AACnB,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,MAAM,4BAA4B;AAC1C,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,4BAA4B;AACzC,cAAQ,KAAK,kBAAkB;AAC/B,aAAOD;AAAA,IACT;AACA,YAAQ,KAAK,kBAAkB;AAC/B,WAAOA,IAAGC,KAAI;AAAA,EAChB;AACF;AAcA,SAAS,+BAA+B,SAASD,KAAI,KAAK;AACxD,QAAM,OAAO;AACb,SAAO;AAeP,WAAS,UAAUC,OAAM;AACvB,QAAI,cAAcA,KAAI,GAAG;AAGvB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA;AAAA,MACN,EAAEA,KAAI;AAAA,IACR;AACA,WAAO,WAAWA,KAAI;AAAA,EACxB;AAeA,WAAS,WAAWA,OAAM;AACxB,WAAO,QAAQ,QAAQ,YAAYD,KAAI,GAAG,EAAEC,KAAI;AAAA,EAClD;AACF;AAGA,SAAS,KAAK,SAAS;AACrB,UAAQ,KAAK,YAAY;AAC3B;;;ACjJA;AASO,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,wBAAwB,SAASC,KAAI,KAAK;AACjD,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,MAAM,cAAc;AAC5B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,cAAc;AAC3B,WAAO;AAAA,EACT;AAYA,WAAS,OAAOA,OAAM;AAEpB,QAAI,iBAAiBA,KAAI,GAAG;AAC1B,cAAQ,MAAM,sBAAsB;AACpC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,sBAAsB;AACnC,cAAQ,KAAK,iBAAiB;AAC9B,aAAOD;AAAA,IACT;AACA,WAAO,IAAIC,KAAI;AAAA,EACjB;AACF;;;AC5DA;;;ACAA;AAIA,IAAM,UAAU,SAAS,cAAc,GAAG;AAMnC,SAAS,8BAA8B,OAAO;AACnD,QAAMC,sBAAqB,MAAM,QAAQ;AACzC,UAAQ,YAAYA;AACpB,QAAM,OAAO,QAAQ;AAUrB,MAAI,KAAK,WAAW,KAAK,SAAS,CAAC,MAAM,MAAgB,UAAU,QAAQ;AACzE,WAAO;AAAA,EACT;AAMA,SAAO,SAASA,sBAAqB,QAAQ;AAC/C;;;ADjBO,IAAM,qBAAqB;AAAA,EAChC,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,2BAA2B,SAASC,KAAI,KAAK;AACpD,QAAM,OAAO;AACb,MAAI,OAAO;AAEX,MAAI;AAEJ,MAAI;AACJ,SAAO;AAgBP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,oBAAoB;AAClC,YAAQ,MAAM,0BAA0B;AACxC,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,0BAA0B;AACvC,WAAO;AAAA,EACT;AAiBA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,iCAAiC;AAC/C,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,iCAAiC;AAC9C,aAAO;AAAA,IACT;AACA,YAAQ,MAAM,yBAAyB;AACvC,UAAM;AACN,WAAO;AACP,WAAO,MAAMA,KAAI;AAAA,EACnB;AAcA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,MAAMA,UAAS,KAAK;AAC/B,cAAQ,MAAM,qCAAqC;AACnD,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,qCAAqC;AAClD,cAAQ,MAAM,yBAAyB;AACvC,YAAM;AACN,aAAO;AACP,aAAO;AAAA,IACT;AACA,YAAQ,MAAM,yBAAyB;AACvC,UAAM;AACN,WAAO;AACP,WAAO,MAAMA,KAAI;AAAA,EACnB;AAmBA,WAAS,MAAMA,OAAM;AACnB,QAAIA,UAAS,MAAM,MAAM;AACvB,YAAM,QAAQ,QAAQ,KAAK,yBAAyB;AACpD,UACE,SAAS,qBACT,CAAC,8BAA8B,KAAK,eAAe,KAAK,CAAC,GACzD;AACA,eAAO,IAAIA,KAAI;AAAA,MACjB;AAIA,cAAQ,MAAM,0BAA0B;AACxC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,0BAA0B;AACvC,cAAQ,KAAK,oBAAoB;AACjC,aAAOD;AAAA,IACT;AACA,QAAI,KAAKC,KAAI,KAAK,SAAS,KAAK;AAC9B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;;;AExJA;AAWA,IAAM,sBAAsB;AAAA,EAC1B,UAAU;AAAA,EACV,SAAS;AACX;AAGO,IAAM,aAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,UAAU;AACZ;AAMA,SAAS,mBAAmB,SAASC,KAAI,KAAK;AAC5C,QAAM,OAAO;AAEb,QAAM,aAAa;AAAA,IACjB,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AACA,MAAI,gBAAgB;AACpB,MAAI,WAAW;AAEf,MAAI;AACJ,SAAO;AAcP,WAAS,MAAMC,OAAM;AAEnB,WAAO,mBAAmBA,KAAI;AAAA,EAChC;AAcA,WAAS,mBAAmBA,OAAM;AAChC,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,oBACE,QAAQ,KAAK,CAAC,EAAE,SAAS,eACrB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,SACtC;AACN,aAASA;AACT,YAAQ,MAAM,YAAY;AAC1B,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,MAAM,yBAAyB;AACvC,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAcA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,QAAQ;AACnB;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,WAAW,GAAG;AAChB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,KAAK,yBAAyB;AACtC,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,YAAY,YAAY,EAAEA,KAAI,IACpD,WAAWA,KAAI;AAAA,EACrB;AAcA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,iBAAiB;AAC9B,aAAO,KAAK,YACRD,IAAGC,KAAI,IACP,QAAQ,MAAM,qBAAqB,gBAAgB,KAAK,EAAEA,KAAI;AAAA,IACpE;AACA,YAAQ,MAAM,qBAAqB;AACnC,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,KAAKA,KAAI;AAAA,EAClB;AAcA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,qBAAqB;AAClC,aAAO,WAAWA,KAAI;AAAA,IACxB;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,qBAAqB;AAClC,aAAO,aAAa,SAAS,YAAY,YAAY,EAAEA,KAAI;AAAA,IAC7D;AACA,QAAIA,UAAS,MAAMA,UAAS,QAAQ;AAClC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAcA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,WAAWA,KAAI;AAAA,IACxB;AACA,YAAQ,MAAM,qBAAqB;AACnC,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,KAAKA,KAAI;AAAA,EAClB;AAcA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,qBAAqB;AAClC,aAAO,WAAWA,KAAI;AAAA,IACxB;AACA,QAAIA,UAAS,MAAMA,UAAS,QAAQ;AAClC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAeA,WAAS,eAAeA,OAAM;AAC5B,WAAO,QAAQ,QAAQ,YAAY,OAAO,aAAa,EAAEA,KAAI;AAAA,EAC/D;AAcA,WAAS,cAAcA,OAAM;AAC3B,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO;AAAA,EACT;AAcA,WAAS,aAAaA,OAAM;AAC1B,WAAO,gBAAgB,KAAK,cAAcA,KAAI,IAC1C;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,gBAAgB;AAAA,IAClB,EAAEA,KAAI,IACN,mBAAmBA,KAAI;AAAA,EAC7B;AAcA,WAAS,mBAAmBA,OAAM;AAChC,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,QAAQ,MAAM,qBAAqB,gBAAgB,KAAK,EAAEA,KAAI;AAAA,IACvE;AACA,YAAQ,MAAM,eAAe;AAC7B,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAcA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,eAAe;AAC5B,aAAO,mBAAmBA,KAAI;AAAA,IAChC;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAcA,WAAS,MAAMA,OAAM;AACnB,YAAQ,KAAK,YAAY;AACzB,WAAOD,IAAGC,KAAI;AAAA,EAChB;AAMA,WAAS,mBAAmBC,UAASF,KAAIG,MAAK;AAC5C,QAAI,OAAO;AACX,WAAO;AAOP,aAAS,YAAYF,OAAM;AACzB,MAAAC,SAAQ,MAAM,YAAY;AAC1B,MAAAA,SAAQ,QAAQD,KAAI;AACpB,MAAAC,SAAQ,KAAK,YAAY;AACzB,aAAOE;AAAA,IACT;AAcA,aAASA,OAAMH,OAAM;AAInB,MAAAC,SAAQ,MAAM,iBAAiB;AAC/B,aAAO,cAAcD,KAAI,IACrB;AAAA,QACEC;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA;AAAA,MACN,EAAED,KAAI,IACN,oBAAoBA,KAAI;AAAA,IAC9B;AAcA,aAAS,oBAAoBA,OAAM;AACjC,UAAIA,UAAS,QAAQ;AACnB,QAAAC,SAAQ,MAAM,yBAAyB;AACvC,eAAO,cAAcD,KAAI;AAAA,MAC3B;AACA,aAAOE,KAAIF,KAAI;AAAA,IACjB;AAcA,aAAS,cAAcA,OAAM;AAC3B,UAAIA,UAAS,QAAQ;AACnB;AACA,QAAAC,SAAQ,QAAQD,KAAI;AACpB,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,UAAU;AACpB,QAAAC,SAAQ,KAAK,yBAAyB;AACtC,eAAO,cAAcD,KAAI,IACrB,aAAaC,UAAS,oBAAoB,YAAY,EAAED,KAAI,IAC5D,mBAAmBA,KAAI;AAAA,MAC7B;AACA,aAAOE,KAAIF,KAAI;AAAA,IACjB;AAcA,aAAS,mBAAmBA,OAAM;AAChC,UAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,QAAAC,SAAQ,KAAK,iBAAiB;AAC9B,eAAOF,IAAGC,KAAI;AAAA,MAChB;AACA,aAAOE,KAAIF,KAAI;AAAA,IACjB;AAAA,EACF;AACF;AAMA,SAAS,4BAA4B,SAASD,KAAI,KAAK;AACrD,QAAM,OAAO;AACb,SAAO;AAOP,WAAS,MAAMC,OAAM;AACnB,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO;AAAA,EACT;AAOA,WAAS,UAAUA,OAAM;AACvB,WAAO,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,IAAI,IAAIA,KAAI,IAAID,IAAGC,KAAI;AAAA,EAChE;AACF;;;AC/dA;AAUO,IAAM,eAAe;AAAA,EAC1B,MAAM;AAAA,EACN,UAAU;AACZ;AAGA,IAAM,eAAe;AAAA,EACnB,UAAU;AAAA,EACV,SAAS;AACX;AAMA,SAAS,qBAAqB,SAASI,KAAI,KAAK;AAC9C,QAAM,OAAO;AACb,SAAO;AAgBP,WAAS,MAAMC,OAAM;AAGnB,YAAQ,MAAM,cAAc;AAG5B,WAAO,aAAa,SAAS,aAAa,cAAc,IAAI,CAAC,EAAEA,KAAI;AAAA,EACrE;AAYA,WAAS,YAAYA,OAAM;AACzB,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,WAAO,QACL,KAAK,CAAC,EAAE,SAAS,gBACjB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,UAAU,IAC9C,QAAQA,KAAI,IACZ,IAAIA,KAAI;AAAA,EACd;AAYA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,MAAM;AACjB,aAAO,MAAMA,KAAI;AAAA,IACnB;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,aAAO,QAAQ,QAAQ,cAAc,SAAS,KAAK,EAAEA,KAAI;AAAA,IAC3D;AACA,YAAQ,MAAM,eAAe;AAC7B,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AACpB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,eAAe;AAC5B,aAAO,QAAQA,KAAI;AAAA,IACrB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAGA,WAAS,MAAMA,OAAM;AACnB,YAAQ,KAAK,cAAc;AAI3B,WAAOD,IAAGC,KAAI;AAAA,EAChB;AACF;AAMA,SAAS,qBAAqB,SAASD,KAAI,KAAK;AAC9C,QAAM,OAAO;AACb,SAAOE;AAaP,WAASA,cAAaD,OAAM;AAG1B,QAAI,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,GAAG;AACrC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAOC;AAAA,IACT;AAQA,WAAO,aAAa,SAAS,aAAa,cAAc,IAAI,CAAC,EAAED,KAAI;AAAA,EACrE;AAYA,WAAS,YAAYA,OAAM;AACzB,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,WAAO,QACL,KAAK,CAAC,EAAE,SAAS,gBACjB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,UAAU,IAC9CD,IAAGC,KAAI,IACP,mBAAmBA,KAAI,IACvBC,cAAaD,KAAI,IACjB,IAAIA,KAAI;AAAA,EACd;AACF;;;ACtLA;AAYO,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,SAAS;AAAA,EACT;AACF;AAIA,SAAS,gBAAgB,QAAQ;AAC/B,MAAI,gBAAgB,OAAO,SAAS;AACpC,MAAI,iBAAiB;AAErB,MAAIE;AAEJ,MAAI;AAGJ,OACG,OAAO,cAAc,EAAE,CAAC,EAAE,SAAS,gBAClC,OAAO,cAAc,EAAE,CAAC,EAAE,SAAS,aACpC,OAAO,aAAa,EAAE,CAAC,EAAE,SAAS,gBACjC,OAAO,aAAa,EAAE,CAAC,EAAE,SAAS,UACpC;AACA,IAAAA,SAAQ;AAGR,WAAO,EAAEA,SAAQ,eAAe;AAC9B,UAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBAAgB;AAE5C,eAAO,cAAc,EAAE,CAAC,EAAE,OAAO;AACjC,eAAO,aAAa,EAAE,CAAC,EAAE,OAAO;AAChC,0BAAkB;AAClB,yBAAiB;AACjB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,EAAAA,SAAQ,iBAAiB;AACzB;AACA,SAAO,EAAEA,UAAS,eAAe;AAC/B,QAAI,UAAU,QAAW;AACvB,UAAIA,WAAU,iBAAiB,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,cAAc;AACrE,gBAAQA;AAAA,MACV;AAAA,IACF,WACEA,WAAU,iBACV,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,cAC1B;AACA,aAAO,KAAK,EAAE,CAAC,EAAE,OAAO;AACxB,UAAIA,WAAU,QAAQ,GAAG;AACvB,eAAO,KAAK,EAAE,CAAC,EAAE,MAAM,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE;AAC5C,eAAO,OAAO,QAAQ,GAAGA,SAAQ,QAAQ,CAAC;AAC1C,yBAAiBA,SAAQ,QAAQ;AACjC,QAAAA,SAAQ,QAAQ;AAAA,MAClB;AACA,cAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAO;AACT;AAMA,SAAS,SAASC,OAAM;AAEtB,SACEA,UAAS,MACT,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS;AAEpD;AAMA,SAAS,iBAAiB,SAASC,KAAI,KAAK;AAC1C,QAAM,OAAO;AACb,MAAI,WAAW;AAEf,MAAI;AAEJ,MAAI;AACJ,SAAO;AAcP,WAAS,MAAMD,OAAM;AACnB,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,kBAAkB;AAChC,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,kBAAkB;AAC/B,WAAOE,SAAQF,KAAI;AAAA,EACrB;AAYA,WAASE,SAAQF,OAAM;AAErB,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AAKA,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,OAAO;AACrB,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,OAAO;AACpB,aAAOE;AAAA,IACT;AAGA,QAAIF,UAAS,IAAI;AACf,cAAQ,QAAQ,MAAM,kBAAkB;AACxC,aAAO;AACP,aAAO,cAAcA,KAAI;AAAA,IAC3B;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAOE;AAAA,IACT;AAGA,YAAQ,MAAM,cAAc;AAC5B,WAAOC,MAAKH,KAAI;AAAA,EAClB;AAYA,WAASG,MAAKH,OAAM;AAClB,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACT,mBAAmBA,KAAI,GACvB;AACA,cAAQ,KAAK,cAAc;AAC3B,aAAOE,SAAQF,KAAI;AAAA,IACrB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOG;AAAA,EACT;AAYA,WAAS,cAAcH,OAAM;AAE3B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AAGA,QAAI,SAAS,UAAU;AACrB,cAAQ,KAAK,kBAAkB;AAC/B,cAAQ,KAAK,UAAU;AACvB,aAAOC,IAAGD,KAAI;AAAA,IAChB;AAGA,UAAM,OAAO;AACb,WAAOG,MAAKH,KAAI;AAAA,EAClB;AACF;;;AC5OA;;;ACAA;AAeO,SAAS,YAAY,QAAQ;AAElC,QAAM,QAAQ,CAAC;AACf,MAAII,SAAQ;AAEZ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AACJ,SAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,WAAOA,UAAS,OAAO;AACrB,MAAAA,SAAQ,MAAMA,MAAK;AAAA,IACrB;AACA,YAAQ,OAAOA,MAAK;AAIpB,QACEA,UACA,MAAM,CAAC,EAAE,SAAS,eAClB,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,kBAC9B;AACA,kBAAY,MAAM,CAAC,EAAE,WAAW;AAChC,mBAAa;AACb,UACE,aAAa,UAAU,UACvB,UAAU,UAAU,EAAE,CAAC,EAAE,SAAS,mBAClC;AACA,sBAAc;AAAA,MAChB;AACA,UACE,aAAa,UAAU,UACvB,UAAU,UAAU,EAAE,CAAC,EAAE,SAAS,WAClC;AACA,eAAO,EAAE,aAAa,UAAU,QAAQ;AACtC,cAAI,UAAU,UAAU,EAAE,CAAC,EAAE,SAAS,WAAW;AAC/C;AAAA,UACF;AACA,cAAI,UAAU,UAAU,EAAE,CAAC,EAAE,SAAS,aAAa;AACjD,sBAAU,UAAU,EAAE,CAAC,EAAE,8BAA8B;AACvD;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,MAAM,CAAC,MAAM,SAAS;AACxB,UAAI,MAAM,CAAC,EAAE,aAAa;AACxB,eAAO,OAAO,OAAO,WAAW,QAAQA,MAAK,CAAC;AAC9C,QAAAA,SAAQ,MAAMA,MAAK;AACnB,eAAO;AAAA,MACT;AAAA,IACF,WAES,MAAM,CAAC,EAAE,YAAY;AAC5B,mBAAaA;AACb,kBAAY;AACZ,aAAO,cAAc;AACnB,qBAAa,OAAO,UAAU;AAC9B,YACE,WAAW,CAAC,EAAE,SAAS,gBACvB,WAAW,CAAC,EAAE,SAAS,mBACvB;AACA,cAAI,WAAW,CAAC,MAAM,SAAS;AAC7B,gBAAI,WAAW;AACb,qBAAO,SAAS,EAAE,CAAC,EAAE,OAAO;AAAA,YAC9B;AACA,uBAAW,CAAC,EAAE,OAAO;AACrB,wBAAY;AAAA,UACd;AAAA,QACF,OAAO;AACL;AAAA,QACF;AAAA,MACF;AACA,UAAI,WAAW;AAEb,cAAM,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAG,OAAO,SAAS,EAAE,CAAC,EAAE,KAAK;AAG3D,qBAAa,OAAO,MAAM,WAAWA,MAAK;AAC1C,mBAAW,QAAQ,KAAK;AACxB,eAAO,QAAQ,WAAWA,SAAQ,YAAY,GAAG,UAAU;AAAA,MAC7D;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC;AACV;AASA,SAAS,WAAW,QAAQ,YAAY;AACtC,QAAM,QAAQ,OAAO,UAAU,EAAE,CAAC;AAClC,QAAM,UAAU,OAAO,UAAU,EAAE,CAAC;AACpC,MAAI,gBAAgB,aAAa;AAEjC,QAAM,iBAAiB,CAAC;AACxB,QAAM,YACJ,MAAM,cAAc,QAAQ,OAAO,MAAM,WAAW,EAAE,MAAM,KAAK;AACnE,QAAM,cAAc,UAAU;AAE9B,QAAM,QAAQ,CAAC;AAEf,QAAM,OAAO,CAAC;AAEd,MAAI;AAEJ,MAAIC;AACJ,MAAID,SAAQ;AAEZ,MAAI,UAAU;AACd,MAAI,SAAS;AACb,MAAI,QAAQ;AACZ,QAAM,SAAS,CAAC,KAAK;AAIrB,SAAO,SAAS;AAEd,WAAO,OAAO,EAAE,aAAa,EAAE,CAAC,MAAM,SAAS;AAAA,IAE/C;AACA,mBAAe,KAAK,aAAa;AACjC,QAAI,CAAC,QAAQ,YAAY;AACvB,eAAS,QAAQ,YAAY,OAAO;AACpC,UAAI,CAAC,QAAQ,MAAM;AACjB,eAAO,KAAK,IAAI;AAAA,MAClB;AACA,UAAIC,WAAU;AACZ,kBAAU,WAAW,QAAQ,KAAK;AAAA,MACpC;AACA,UAAI,QAAQ,6BAA6B;AACvC,kBAAU,qCAAqC;AAAA,MACjD;AACA,gBAAU,MAAM,MAAM;AACtB,UAAI,QAAQ,6BAA6B;AACvC,kBAAU,qCAAqC;AAAA,MACjD;AAAA,IACF;AAGA,IAAAA,YAAW;AACX,cAAU,QAAQ;AAAA,EACpB;AAIA,YAAU;AACV,SAAO,EAAED,SAAQ,YAAY,QAAQ;AACnC;AAAA;AAAA,MAEE,YAAYA,MAAK,EAAE,CAAC,MAAM,UAC1B,YAAYA,SAAQ,CAAC,EAAE,CAAC,MAAM,WAC9B,YAAYA,MAAK,EAAE,CAAC,EAAE,SAAS,YAAYA,SAAQ,CAAC,EAAE,CAAC,EAAE,QACzD,YAAYA,MAAK,EAAE,CAAC,EAAE,MAAM,SAAS,YAAYA,MAAK,EAAE,CAAC,EAAE,IAAI;AAAA,MAC/D;AACA,cAAQA,SAAQ;AAChB,aAAO,KAAK,KAAK;AAEjB,cAAQ,aAAa;AACrB,cAAQ,WAAW;AACnB,gBAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AAGA,YAAU,SAAS,CAAC;AAKpB,MAAI,SAAS;AAEX,YAAQ,aAAa;AACrB,YAAQ,WAAW;AAAA,EACrB,OAAO;AACL,WAAO,IAAI;AAAA,EACb;AAIA,EAAAA,SAAQ,OAAO;AACf,SAAOA,UAAS;AACd,UAAM,QAAQ,YAAY,MAAM,OAAOA,MAAK,GAAG,OAAOA,SAAQ,CAAC,CAAC;AAChE,UAAME,SAAQ,eAAe,IAAI;AACjC,UAAM,QAAQ,CAACA,QAAOA,SAAQ,MAAM,SAAS,CAAC,CAAC;AAC/C,WAAO,QAAQA,QAAO,GAAG,KAAK;AAAA,EAChC;AACA,EAAAF,SAAQ;AACR,SAAO,EAAEA,SAAQ,MAAM,QAAQ;AAC7B,SAAK,SAAS,MAAMA,MAAK,EAAE,CAAC,CAAC,IAAI,SAAS,MAAMA,MAAK,EAAE,CAAC;AACxD,cAAU,MAAMA,MAAK,EAAE,CAAC,IAAI,MAAMA,MAAK,EAAE,CAAC,IAAI;AAAA,EAChD;AACA,SAAO;AACT;;;AD/MO,IAAM,UAAU;AAAA,EACrB,UAAU;AAAA,EACV,SAAS;AACX;AAGA,IAAM,wBAAwB;AAAA,EAC5B,UAAU;AAAA,EACV,SAAS;AACX;AAQA,SAAS,eAAe,QAAQ;AAC9B,cAAY,MAAM;AAClB,SAAO;AACT;AAMA,SAAS,gBAAgB,SAASG,KAAI;AAEpC,MAAIC;AACJ,SAAO;AAYP,WAAS,WAAWC,OAAM;AACxB,YAAQ,MAAM,SAAS;AACvB,IAAAD,YAAW,QAAQ,MAAM,gBAAgB;AAAA,MACvC,aAAa;AAAA,IACf,CAAC;AACD,WAAO,YAAYC,KAAI;AAAA,EACzB;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,MAAM;AACjB,aAAO,WAAWA,KAAI;AAAA,IACxB;AAIA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAEA,KAAI;AAAA,IACR;AAGA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAOA,WAAS,WAAWA,OAAM;AACxB,YAAQ,KAAK,cAAc;AAC3B,YAAQ,KAAK,SAAS;AACtB,WAAOF,IAAGE,KAAI;AAAA,EAChB;AAOA,WAAS,gBAAgBA,OAAM;AAC7B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,cAAc;AAC3B,IAAAD,UAAS,OAAO,QAAQ,MAAM,gBAAgB;AAAA,MAC5C,aAAa;AAAA,MACb,UAAAA;AAAA,IACF,CAAC;AACD,IAAAA,YAAWA,UAAS;AACpB,WAAO;AAAA,EACT;AACF;AAMA,SAAS,qBAAqB,SAASD,KAAI,KAAK;AAC9C,QAAM,OAAO;AACb,SAAO;AAOP,WAAS,eAAeE,OAAM;AAC5B,YAAQ,KAAK,cAAc;AAC3B,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO,aAAa,SAAS,UAAU,YAAY;AAAA,EACrD;AAOA,WAAS,SAASA,OAAM;AACtB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,IAAIA,KAAI;AAAA,IACjB;AAIA,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,QACE,CAAC,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,KAC5D,QACA,KAAK,CAAC,EAAE,SAAS,gBACjB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,UAAU,GAChD;AACA,aAAOF,IAAGE,KAAI;AAAA,IAChB;AACA,WAAO,QAAQ,UAAU,KAAK,OAAO,WAAW,MAAM,KAAKF,GAAE,EAAEE,KAAI;AAAA,EACrE;AACF;;;AEvKA;;;ACAA;AAgDO,SAAS,mBACd,SACAC,KACA,KACA,MACA,aACA,mBACA,SACA,YACA,KACA;AACA,QAAM,QAAQ,OAAO,OAAO;AAC5B,MAAI,UAAU;AACd,SAAO;AAcP,WAAS,MAAMC,OAAM;AACnB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,IAAI;AAClB,cAAQ,MAAM,WAAW;AACzB,cAAQ,MAAM,iBAAiB;AAC/B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,iBAAiB;AAC9B,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,QAAQA,UAAS,MAAMA,UAAS,MAAM,aAAaA,KAAI,GAAG;AACrE,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,IAAI;AAClB,YAAQ,MAAM,OAAO;AACrB,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,eAAeA,OAAM;AAC5B,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,iBAAiB;AAC/B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,iBAAiB;AAC9B,cAAQ,KAAK,WAAW;AACxB,cAAQ,KAAK,IAAI;AACjB,aAAOD;AAAA,IACT;AACA,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,SAASC,KAAI;AAAA,EACtB;AAYA,WAAS,SAASA,OAAM;AACtB,QAAIA,UAAS,IAAI;AACf,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,UAAU;AACvB,aAAO,eAAeA,KAAI;AAAA,IAC5B;AACA,QAAIA,UAAS,QAAQA,UAAS,MAAM,mBAAmBA,KAAI,GAAG;AAC5D,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOA,UAAS,KAAK,iBAAiB;AAAA,EACxC;AAYA,WAAS,eAAeA,OAAM;AAC5B,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,SAASA,KAAI;AAAA,EACtB;AAYA,WAAS,IAAIA,OAAM;AACjB,QACE,CAAC,YACAA,UAAS,QAAQA,UAAS,MAAM,0BAA0BA,KAAI,IAC/D;AACA,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,UAAU;AACvB,cAAQ,KAAK,OAAO;AACpB,cAAQ,KAAK,IAAI;AACjB,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,QAAI,UAAU,SAASA,UAAS,IAAI;AAClC,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AAKA,QAAIA,UAAS,QAAQA,UAAS,MAAMA,UAAS,MAAM,aAAaA,KAAI,GAAG;AACrE,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOA,UAAS,KAAK,YAAY;AAAA,EACnC;AAYA,WAAS,UAAUA,OAAM;AACvB,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;;;AChOA;AAuCO,SAAS,aAAa,SAASC,KAAI,KAAK,MAAM,YAAY,YAAY;AAC3E,QAAM,OAAO;AACb,MAAI,OAAO;AAEX,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,IAAI;AAClB,YAAQ,MAAM,UAAU;AACxB,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,UAAU;AACvB,YAAQ,MAAM,UAAU;AACxB,WAAO;AAAA,EACT;AAYA,WAAS,QAAQA,OAAM;AACrB,QACE,OAAO,OACPA,UAAS,QACTA,UAAS,MACRA,UAAS,MAAM,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,IAMhBA,UAAS,MACR,CAAC,QACD,4BAA4B,KAAK,OAAO,YAC1C;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,KAAK,UAAU;AACvB,cAAQ,MAAM,UAAU;AACxB,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,UAAU;AACvB,cAAQ,KAAK,IAAI;AACjB,aAAOD;AAAA,IACT;AAGA,QAAI,mBAAmBC,KAAI,GAAG;AAC5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAO;AAAA,IACT;AACA,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,YAAYA,KAAI;AAAA,EACzB;AAYA,WAAS,YAAYA,OAAM;AACzB,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACT,mBAAmBA,KAAI,KACvB,SAAS,KACT;AACA,cAAQ,KAAK,aAAa;AAC1B,aAAO,QAAQA,KAAI;AAAA,IACrB;AACA,YAAQ,QAAQA,KAAI;AACpB,QAAI,CAAC;AAAM,aAAO,CAAC,cAAcA,KAAI;AACrC,WAAOA,UAAS,KAAK,cAAc;AAAA,EACrC;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AACF;;;AC9JA;AAwCO,SAAS,aAAa,SAASC,KAAI,KAAK,MAAM,YAAY,YAAY;AAE3E,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,MAAM,IAAI;AAClB,cAAQ,MAAM,UAAU;AACxB,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,UAAU;AACvB,eAASA,UAAS,KAAK,KAAKA;AAC5B,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAcA,WAAS,MAAMA,OAAM;AACnB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,MAAM,UAAU;AACxB,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,UAAU;AACvB,cAAQ,KAAK,IAAI;AACjB,aAAOD;AAAA,IACT;AACA,YAAQ,MAAM,UAAU;AACxB,WAAO,QAAQC,KAAI;AAAA,EACrB;AAYA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,KAAK,UAAU;AACvB,aAAO,MAAM,MAAM;AAAA,IACrB;AACA,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AAGA,QAAI,mBAAmBA,KAAI,GAAG;AAE5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAO,aAAa,SAAS,SAAS,YAAY;AAAA,IACpD;AACA,YAAQ,MAAM,eAAe;AAAA,MAC3B,aAAa;AAAA,IACf,CAAC;AACD,WAAO,OAAOA,KAAI;AAAA,EACpB;AAOA,WAAS,OAAOA,OAAM;AACpB,QAAIA,UAAS,UAAUA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAChE,cAAQ,KAAK,aAAa;AAC1B,aAAO,QAAQA,KAAI;AAAA,IACrB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOA,UAAS,KAAK,SAAS;AAAA,EAChC;AAYA,WAAS,OAAOA,OAAM;AACpB,QAAIA,UAAS,UAAUA,UAAS,IAAI;AAClC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,OAAOA,KAAI;AAAA,EACpB;AACF;;;AC3JA;AAyBO,SAAS,kBAAkB,SAASC,KAAI;AAE7C,MAAI;AACJ,SAAO;AAGP,WAAS,MAAMC,OAAM;AACnB,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAO;AACP,aAAO;AAAA,IACT;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,OAAO,eAAe;AAAA,MACxB,EAAEA,KAAI;AAAA,IACR;AACA,WAAOD,IAAGC,KAAI;AAAA,EAChB;AACF;;;AChDA;AAmBO,SAAS,oBAAoB,OAAO;AACzC,SACE,MAEG,QAAQ,eAAe,GAAG,EAE1B,QAAQ,UAAU,EAAE,EAOpB,YAAY,EACZ,YAAY;AAEnB;;;ALhBO,IAAM,aAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAU;AACZ;AAGA,IAAM,cAAc;AAAA,EAClB,UAAU;AAAA,EACV,SAAS;AACX;AAMA,SAAS,mBAAmB,SAASC,KAAI,KAAK;AAC5C,QAAM,OAAO;AAEb,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AAInB,YAAQ,MAAM,YAAY;AAC1B,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AAGpB,WAAO,aAAa;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,WAAWA,OAAM;AACxB,iBAAa;AAAA,MACX,KAAK,eAAe,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE;AAAA,IACzE;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAC/B,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,YAAYA,OAAM;AAEzB,WAAO,0BAA0BA,KAAI,IACjC,kBAAkB,SAAS,iBAAiB,EAAEA,KAAI,IAClD,kBAAkBA,KAAI;AAAA,EAC5B;AAYA,WAAS,kBAAkBA,OAAM;AAC/B,WAAO;AAAA,MACL;AAAA,MACA;AAAA;AAAA,MAEA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,iBAAiBA,OAAM;AAC9B,WAAO,QAAQ,QAAQ,aAAa,OAAO,KAAK,EAAEA,KAAI;AAAA,EACxD;AAcA,WAAS,MAAMA,OAAM;AACnB,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,iBAAiB,YAAY,EAAEA,KAAI,IACzD,gBAAgBA,KAAI;AAAA,EAC1B;AAcA,WAAS,gBAAgBA,OAAM;AAC7B,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,YAAY;AAKzB,WAAK,OAAO,QAAQ,KAAK,UAAU;AAKnC,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAMA,SAAS,oBAAoB,SAASD,KAAI,KAAK;AAC7C,SAAOE;AAcP,WAASA,aAAYD,OAAM;AACzB,WAAO,0BAA0BA,KAAI,IACjC,kBAAkB,SAAS,YAAY,EAAEA,KAAI,IAC7C,IAAIA,KAAI;AAAA,EACd;AAaA,WAAS,aAAaA,OAAM;AAC1B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,WAAWA,OAAM;AACxB,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,8BAA8B,YAAY,EAAEA,KAAI,IACtE,6BAA6BA,KAAI;AAAA,EACvC;AAYA,WAAS,6BAA6BA,OAAM;AAC1C,WAAOA,UAAS,QAAQ,mBAAmBA,KAAI,IAAID,IAAGC,KAAI,IAAI,IAAIA,KAAI;AAAA,EACxE;AACF;;;AM7RA;AASO,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,wBAAwB,SAASE,KAAI,KAAK;AACjD,SAAO;AAaP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAaA,WAAS,MAAMA,OAAM;AACnB,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,KAAK,iBAAiB;AAC9B,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;;;ACxDA;AAiBO,IAAM,aAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,SAAS;AACX;AAGA,SAAS,kBAAkB,QAAQ,SAAS;AAC1C,MAAI,aAAa,OAAO,SAAS;AACjC,MAAI,eAAe;AAEnB,MAAIC;AAEJ,MAAIC;AAGJ,MAAI,OAAO,YAAY,EAAE,CAAC,EAAE,SAAS,cAAc;AACjD,oBAAgB;AAAA,EAClB;AAGA,MACE,aAAa,IAAI,gBACjB,OAAO,UAAU,EAAE,CAAC,EAAE,SAAS,cAC/B;AACA,kBAAc;AAAA,EAChB;AACA,MACE,OAAO,UAAU,EAAE,CAAC,EAAE,SAAS,yBAC9B,iBAAiB,aAAa,KAC5B,aAAa,IAAI,gBAChB,OAAO,aAAa,CAAC,EAAE,CAAC,EAAE,SAAS,eACvC;AACA,kBAAc,eAAe,MAAM,aAAa,IAAI;AAAA,EACtD;AACA,MAAI,aAAa,cAAc;AAC7B,IAAAD,WAAU;AAAA,MACR,MAAM;AAAA,MACN,OAAO,OAAO,YAAY,EAAE,CAAC,EAAE;AAAA,MAC/B,KAAK,OAAO,UAAU,EAAE,CAAC,EAAE;AAAA,IAC7B;AACA,IAAAC,QAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO,OAAO,YAAY,EAAE,CAAC,EAAE;AAAA,MAC/B,KAAK,OAAO,UAAU,EAAE,CAAC,EAAE;AAAA,MAC3B,aAAa;AAAA,IACf;AACA,WAAO,QAAQ,cAAc,aAAa,eAAe,GAAG;AAAA,MAC1D,CAAC,SAASD,UAAS,OAAO;AAAA,MAC1B,CAAC,SAASC,OAAM,OAAO;AAAA,MACvB,CAAC,QAAQA,OAAM,OAAO;AAAA,MACtB,CAAC,QAAQD,UAAS,OAAO;AAAA,IAC3B,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAMA,SAAS,mBAAmB,SAASE,KAAI,KAAK;AAC5C,MAAI,OAAO;AACX,SAAO;AAYP,WAAS,MAAMC,OAAM;AAEnB,YAAQ,MAAM,YAAY;AAC1B,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AACpB,YAAQ,MAAM,oBAAoB;AAClC,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,MAAM,SAAS,GAAG;AAC7B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,QAAQ,0BAA0BA,KAAI,GAAG;AACpD,cAAQ,KAAK,oBAAoB;AACjC,aAAO,QAAQA,KAAI;AAAA,IACrB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,oBAAoB;AAClC,aAAO,gBAAgBA,KAAI;AAAA,IAC7B;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,YAAY;AAIzB,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO,aAAa,SAAS,SAAS,YAAY,EAAEA,KAAI;AAAA,IAC1D;AAIA,YAAQ,MAAM,gBAAgB;AAC9B,WAAOC,MAAKD,KAAI;AAAA,EAClB;AAcA,WAAS,gBAAgBA,OAAM;AAC7B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,oBAAoB;AACjC,WAAO,QAAQA,KAAI;AAAA,EACrB;AAYA,WAASC,MAAKD,OAAM;AAClB,QAAIA,UAAS,QAAQA,UAAS,MAAM,0BAA0BA,KAAI,GAAG;AACnE,cAAQ,KAAK,gBAAgB;AAC7B,aAAO,QAAQA,KAAI;AAAA,IACrB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOC;AAAA,EACT;AACF;;;AChNA;;;ACAA;AAeO,IAAM,iBAAiB;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAcO,IAAM,eAAe,CAAC,OAAO,UAAU,SAAS,UAAU;;;ADxE1D,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,WAAW;AAAA,EACX,UAAU;AACZ;AAGA,IAAM,kBAAkB;AAAA,EACtB,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAM,2BAA2B;AAAA,EAC/B,UAAU;AAAA,EACV,SAAS;AACX;AAGA,SAAS,kBAAkB,QAAQ;AACjC,MAAIC,SAAQ,OAAO;AACnB,SAAOA,UAAS;AACd,QAAI,OAAOA,MAAK,EAAE,CAAC,MAAM,WAAW,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,YAAY;AACxE;AAAA,IACF;AAAA,EACF;AACA,MAAIA,SAAQ,KAAK,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,cAAc;AAE3D,WAAOA,MAAK,EAAE,CAAC,EAAE,QAAQ,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE;AAE9C,WAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,QAAQ,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE;AAElD,WAAO,OAAOA,SAAQ,GAAG,CAAC;AAAA,EAC5B;AACA,SAAO;AACT;AAMA,SAAS,iBAAiB,SAASC,KAAI,KAAK;AAC1C,QAAM,OAAO;AAEb,MAAI;AAEJ,MAAI;AAEJ,MAAIC;AAEJ,MAAIF;AAEJ,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMG,OAAM;AAEnB,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AACpB,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,cAAc;AAC5B,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAgBA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,mBAAa;AACb,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,eAAS;AAMT,aAAO,KAAK,YAAYF,MAAK;AAAA,IAC/B;AAGA,QAAI,WAAWE,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AAEpB,MAAAD,UAAS,OAAO,aAAaC,KAAI;AACjC,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAgBA,WAAS,gBAAgBA,OAAM;AAC7B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,eAAS;AACT,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,eAAS;AACT,MAAAH,SAAQ;AACR,aAAO;AAAA,IACT;AAGA,QAAI,WAAWG,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,eAAS;AAGT,aAAO,KAAK,YAAYF,MAAK;AAAA,IAC/B;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AAYA,WAAS,kBAAkBA,OAAM;AAC/B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AAGpB,aAAO,KAAK,YAAYF,MAAK;AAAA,IAC/B;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AAYA,WAAS,gBAAgBA,OAAM;AAC7B,UAAM,QAAQ;AACd,QAAIA,UAAS,MAAM,WAAWH,QAAO,GAAG;AACtC,cAAQ,QAAQG,KAAI;AACpB,UAAIH,WAAU,MAAM,QAAQ;AAG1B,eAAO,KAAK,YAAYC,MAAK;AAAA,MAC/B;AACA,aAAO;AAAA,IACT;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AAYA,WAAS,cAAcA,OAAM;AAC3B,QAAI,WAAWA,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AAEpB,MAAAD,UAAS,OAAO,aAAaC,KAAI;AACjC,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAcA,WAAS,QAAQA,OAAM;AACrB,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACT,0BAA0BA,KAAI,GAC9B;AACA,YAAM,QAAQA,UAAS;AACvB,YAAM,OAAOD,QAAO,YAAY;AAChC,UAAI,CAAC,SAAS,CAAC,cAAc,aAAa,SAAS,IAAI,GAAG;AACxD,iBAAS;AAGT,eAAO,KAAK,YAAYD,IAAGE,KAAI,IAAI,aAAaA,KAAI;AAAA,MACtD;AACA,UAAI,eAAe,SAASD,QAAO,YAAY,CAAC,GAAG;AACjD,iBAAS;AACT,YAAI,OAAO;AACT,kBAAQ,QAAQC,KAAI;AACpB,iBAAO;AAAA,QACT;AAIA,eAAO,KAAK,YAAYF,IAAGE,KAAI,IAAI,aAAaA,KAAI;AAAA,MACtD;AACA,eAAS;AAET,aAAO,KAAK,aAAa,CAAC,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,IACtD,IAAIA,KAAI,IACR,aACA,wBAAwBA,KAAI,IAC5B,4BAA4BA,KAAI;AAAA,IACtC;AAGA,QAAIA,UAAS,MAAM,kBAAkBA,KAAI,GAAG;AAC1C,cAAQ,QAAQA,KAAI;AACpB,MAAAD,WAAU,OAAO,aAAaC,KAAI;AAClC,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,iBAAiBA,OAAM;AAC9B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AAGpB,aAAO,KAAK,YAAYF,MAAK;AAAA,IAC/B;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AAYA,WAAS,wBAAwBA,OAAM;AACrC,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAyBA,WAAS,4BAA4BA,OAAM;AACzC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,MAAMA,UAAS,MAAM,WAAWA,KAAI,GAAG;AAClD,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAgBA,WAAS,sBAAsBA,OAAM;AAEnC,QACEA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACT,kBAAkBA,KAAI,GACtB;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,2BAA2BA,KAAI;AAAA,EACxC;AAeA,WAAS,2BAA2BA,OAAM;AACxC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,4BAA4BA,KAAI;AAAA,EACzC;AAeA,WAAS,6BAA6BA,OAAM;AAC1C,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,IACT;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,MAAMA,UAAS,IAAI;AAC9B,cAAQ,QAAQA,KAAI;AACpB,gBAAUA;AACV,aAAO;AAAA,IACT;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,+BAA+BA,KAAI;AAAA,EAC5C;AAcA,WAAS,6BAA6BA,OAAM;AAC1C,QAAIA,UAAS,SAAS;AACpB,cAAQ,QAAQA,KAAI;AACpB,gBAAU;AACV,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,+BAA+BA,OAAM;AAC5C,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACT,0BAA0BA,KAAI,GAC9B;AACA,aAAO,2BAA2BA,KAAI;AAAA,IACxC;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAaA,WAAS,kCAAkCA,OAAM;AAC/C,QAAIA,UAAS,MAAMA,UAAS,MAAM,cAAcA,KAAI,GAAG;AACrD,aAAO,4BAA4BA,KAAI;AAAA,IACzC;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,cAAcA,OAAM;AAC3B,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAG7C,aAAO,aAAaA,KAAI;AAAA,IAC1B;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,MAAM,WAAW,KAAK,WAAW,IAAI;AAC9D,cAAQ,KAAK,cAAc;AAC3B,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAEA,KAAI;AAAA,IACR;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,cAAc;AAC3B,aAAO,kBAAkBA,KAAI;AAAA,IAC/B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAaA,WAAS,kBAAkBA,OAAM;AAC/B,WAAO,QAAQ;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAaA,WAAS,yBAAyBA,OAAM;AACtC,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO;AAAA,EACT;AAaA,WAAS,mBAAmBA,OAAM;AAChC,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,kBAAkBA,KAAI;AAAA,IAC/B;AACA,YAAQ,MAAM,cAAc;AAC5B,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,0BAA0BA,OAAM;AACvC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,uBAAuBA,OAAM;AACpC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,MAAAD,UAAS;AACT,aAAO;AAAA,IACT;AACA,WAAO,aAAaC,KAAI;AAAA,EAC1B;AAYA,WAAS,sBAAsBA,OAAM;AACnC,QAAIA,UAAS,IAAI;AACf,YAAM,OAAOD,QAAO,YAAY;AAChC,UAAI,aAAa,SAAS,IAAI,GAAG;AAC/B,gBAAQ,QAAQC,KAAI;AACpB,eAAO;AAAA,MACT;AACA,aAAO,aAAaA,KAAI;AAAA,IAC1B;AACA,QAAI,WAAWA,KAAI,KAAKD,QAAO,SAAS,GAAG;AACzC,cAAQ,QAAQC,KAAI;AAEpB,MAAAD,WAAU,OAAO,aAAaC,KAAI;AAClC,aAAO;AAAA,IACT;AACA,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,wBAAwBA,OAAM;AACrC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAoBA,WAAS,8BAA8BA,OAAM;AAC3C,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,MAAM,WAAW,GAAG;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAYA,WAAS,kBAAkBA,OAAM;AAC/B,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,cAAc;AAC3B,aAAO,kBAAkBA,KAAI;AAAA,IAC/B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,kBAAkBA,OAAM;AAC/B,YAAQ,KAAK,UAAU;AAKvB,WAAOF,IAAGE,KAAI;AAAA,EAChB;AACF;AAMA,SAAS,iCAAiC,SAASF,KAAI,KAAK;AAC1D,QAAM,OAAO;AACb,SAAO;AAaP,WAAS,MAAME,OAAM;AACnB,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,MAAM,YAAY;AAC1B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,YAAY;AACzB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAaA,WAAS,MAAMA,OAAM;AACnB,WAAO,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,IAAI,IAAIA,KAAI,IAAIF,IAAGE,KAAI;AAAA,EAChE;AACF;AAMA,SAAS,wBAAwB,SAASF,KAAI,KAAK;AACjD,SAAO;AAaP,WAAS,MAAME,OAAM;AACnB,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO,QAAQ,QAAQ,WAAWF,KAAI,GAAG;AAAA,EAC3C;AACF;;;AEn5BA;AAiBO,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,iBAAiB,SAASG,KAAI,KAAK;AAC1C,QAAM,OAAO;AAEb,MAAI;AAEJ,MAAIC;AAEJ,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,cAAc;AAC5B,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAgBA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAI,WAAWA,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAgBA,WAAS,gBAAgBA,OAAM;AAC7B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,MAAAD,SAAQ;AACR,aAAO;AAAA,IACT;AACA,QAAI,WAAWC,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,kBAAkBA,OAAM;AAC/B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,QAAQA,KAAI;AAAA,EACrB;AAYA,WAAS,WAAWA,OAAM;AACxB,WAAOA,UAAS,KACZ,IAAIA,KAAI,IACRA,UAAS,KACT,aAAaA,KAAI,IACjB,QAAQA,KAAI;AAAA,EAClB;AAYA,WAAS,gBAAgBA,OAAM;AAC7B,UAAM,QAAQ;AACd,QAAIA,UAAS,MAAM,WAAWD,QAAO,GAAG;AACtC,cAAQ,QAAQC,KAAI;AACpB,aAAOD,WAAU,MAAM,SAAS,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAIC,KAAI;AAAA,EACjB;AAYA,WAAS,MAAMA,OAAM;AACnB,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,MAAMA,KAAI;AAAA,EACnB;AAYA,WAAS,SAASA,OAAM;AACtB,QAAIA,UAAS,IAAI;AACf,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,MAAMA,KAAI;AAAA,EACnB;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,QAAQA,UAAS,IAAI;AAChC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,iBAAiBA,OAAM;AAC9B,WAAOA,UAAS,KAAK,IAAIA,KAAI,IAAI,YAAYA,KAAI;AAAA,EACnD;AAYA,WAAS,cAAcA,OAAM;AAE3B,QAAI,WAAWA,KAAI,GAAG;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,SAASA,OAAM;AAEtB,QAAIA,UAAS,MAAM,kBAAkBA,KAAI,GAAG;AAC1C,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,gBAAgBA,KAAI;AAAA,EAC7B;AAYA,WAAS,gBAAgBA,OAAM;AAC7B,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,QAAQA,OAAM;AAErB,QAAIA,UAAS,MAAM,kBAAkBA,KAAI,GAAG;AAC1C,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAMA,UAAS,MAAM,0BAA0BA,KAAI,GAAG;AACjE,aAAO,eAAeA,KAAI;AAAA,IAC5B;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,eAAeA,OAAM;AAC5B,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,MAAMA,UAAS,MAAM,WAAWA,KAAI,GAAG;AAClD,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,qBAAqBA,OAAM;AAElC,QACEA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACT,kBAAkBA,KAAI,GACtB;AACA,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,0BAA0BA,KAAI;AAAA,EACvC;AAaA,WAAS,0BAA0BA,OAAM;AACvC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,eAAeA,KAAI;AAAA,EAC5B;AAaA,WAAS,4BAA4BA,OAAM;AACzC,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,IACT;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,MAAMA,UAAS,IAAI;AAC9B,cAAQ,QAAQA,KAAI;AACpB,eAASA;AACT,aAAO;AAAA,IACT;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,4BAA4BA,OAAM;AACzC,QAAIA,UAAS,QAAQ;AACnB,cAAQ,QAAQA,KAAI;AACpB,eAAS;AACT,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAM;AACjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,oBAAc;AACd,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAYA,WAAS,8BAA8BA,OAAM;AAC3C,QACEA,UAAS,QACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,MACTA,UAAS,IACT;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,MAAMA,UAAS,MAAM,0BAA0BA,KAAI,GAAG;AACjE,aAAO,eAAeA,KAAI;AAAA,IAC5B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAaA,WAAS,iCAAiCA,OAAM;AAC9C,QAAIA,UAAS,MAAMA,UAAS,MAAM,0BAA0BA,KAAI,GAAG;AACjE,aAAO,eAAeA,KAAI;AAAA,IAC5B;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,IAAIA,OAAM;AACjB,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,cAAc;AAC3B,cAAQ,KAAK,UAAU;AACvB,aAAOF;AAAA,IACT;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AAgBA,WAAS,iBAAiBA,OAAM;AAC9B,YAAQ,KAAK,cAAc;AAC3B,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO;AAAA,EACT;AAgBA,WAAS,gBAAgBA,OAAM;AAG7B,WAAO,cAAcA,KAAI,IACrB;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA;AAAA,IACN,EAAEA,KAAI,IACN,sBAAsBA,KAAI;AAAA,EAChC;AAgBA,WAAS,sBAAsBA,OAAM;AACnC,YAAQ,MAAM,cAAc;AAC5B,WAAO,YAAYA,KAAI;AAAA,EACzB;AACF;;;ACxsBA;AAmBO,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,WAAW;AAAA,EACX,YAAY;AACd;AAGA,IAAM,oBAAoB;AAAA,EACxB,UAAU;AACZ;AAEA,IAAM,yBAAyB;AAAA,EAC7B,UAAU;AACZ;AAEA,IAAM,8BAA8B;AAAA,EAClC,UAAU;AACZ;AAGA,SAAS,mBAAmB,QAAQ;AAClC,MAAIC,SAAQ;AACZ,SAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,UAAM,QAAQ,OAAOA,MAAK,EAAE,CAAC;AAC7B,QACE,MAAM,SAAS,gBACf,MAAM,SAAS,eACf,MAAM,SAAS,YACf;AAEA,aAAO,OAAOA,SAAQ,GAAG,MAAM,SAAS,eAAe,IAAI,CAAC;AAC5D,YAAM,OAAO;AACb,MAAAA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAGA,SAAS,kBAAkB,QAAQ,SAAS;AAC1C,MAAIA,SAAQ,OAAO;AACnB,MAAI,SAAS;AAEb,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAEJ,MAAI;AAGJ,SAAOA,UAAS;AACd,YAAQ,OAAOA,MAAK,EAAE,CAAC;AACvB,QAAI,MAAM;AAER,UACE,MAAM,SAAS,UACd,MAAM,SAAS,eAAe,MAAM,WACrC;AACA;AAAA,MACF;AAIA,UAAI,OAAOA,MAAK,EAAE,CAAC,MAAM,WAAW,MAAM,SAAS,aAAa;AAC9D,cAAM,YAAY;AAAA,MACpB;AAAA,IACF,WAAW,OAAO;AAChB,UACE,OAAOA,MAAK,EAAE,CAAC,MAAM,YACpB,MAAM,SAAS,gBAAgB,MAAM,SAAS,gBAC/C,CAAC,MAAM,WACP;AACA,eAAOA;AACP,YAAI,MAAM,SAAS,aAAa;AAC9B,mBAAS;AACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,WAAW,MAAM,SAAS,YAAY;AACpC,cAAQA;AAAA,IACV;AAAA,EACF;AACA,QAAM,QAAQ;AAAA,IACZ,MAAM,OAAO,IAAI,EAAE,CAAC,EAAE,SAAS,cAAc,SAAS;AAAA,IACtD,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,KAAK;AAAA,IAC9C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,EACzD;AACA,QAAM,QAAQ;AAAA,IACZ,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,KAAK;AAAA,IAC9C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,KAAK,EAAE,CAAC,EAAE,GAAG;AAAA,EAC7C;AACA,QAAMC,QAAO;AAAA,IACX,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,IACzD,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK;AAAA,EACnD;AACA,UAAQ;AAAA,IACN,CAAC,SAAS,OAAO,OAAO;AAAA,IACxB,CAAC,SAAS,OAAO,OAAO;AAAA,EAC1B;AAGA,UAAQ,KAAK,OAAO,OAAO,MAAM,OAAO,GAAG,OAAO,SAAS,CAAC,CAAC;AAG7D,UAAQ,KAAK,OAAO,CAAC,CAAC,SAASA,OAAM,OAAO,CAAC,CAAC;AAK9C,UAAQ;AAAA,IACN;AAAA,IACA;AAAA,MACE,QAAQ,OAAO,WAAW,WAAW;AAAA,MACrC,OAAO,MAAM,OAAO,SAAS,GAAG,QAAQ,CAAC;AAAA,MACzC;AAAA,IACF;AAAA,EACF;AAGA,UAAQ,KAAK,OAAO;AAAA,IAClB,CAAC,QAAQA,OAAM,OAAO;AAAA,IACtB,OAAO,QAAQ,CAAC;AAAA,IAChB,OAAO,QAAQ,CAAC;AAAA,IAChB,CAAC,QAAQ,OAAO,OAAO;AAAA,EACzB,CAAC;AAGD,UAAQ,KAAK,OAAO,OAAO,MAAM,QAAQ,CAAC,CAAC;AAG3C,UAAQ,KAAK,OAAO,CAAC,CAAC,QAAQ,OAAO,OAAO,CAAC,CAAC;AAC9C,SAAO,QAAQ,MAAM,OAAO,QAAQ,KAAK;AACzC,SAAO;AACT;AAMA,SAAS,iBAAiB,SAASC,KAAI,KAAK;AAC1C,QAAM,OAAO;AACb,MAAIF,SAAQ,KAAK,OAAO;AAExB,MAAI;AAEJ,MAAIG;AAGJ,SAAOH,UAAS;AACd,SACG,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBAC9B,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBACjC,CAAC,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,WACvB;AACA,mBAAa,KAAK,OAAOA,MAAK,EAAE,CAAC;AACjC;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAiBP,WAAS,MAAMI,OAAM;AAEnB,QAAI,CAAC,YAAY;AACf,aAAO,IAAIA,KAAI;AAAA,IACjB;AAWA,QAAI,WAAW,WAAW;AACxB,aAAO,YAAYA,KAAI;AAAA,IACzB;AACA,IAAAD,WAAU,KAAK,OAAO,QAAQ;AAAA,MAC5B;AAAA,QACE,KAAK,eAAe;AAAA,UAClB,OAAO,WAAW;AAAA,UAClB,KAAK,KAAK,IAAI;AAAA,QAChB,CAAC;AAAA,MACH;AAAA,IACF;AACA,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,aAAa;AAC3B,YAAQ,QAAQC,KAAI;AACpB,YAAQ,KAAK,aAAa;AAC1B,YAAQ,KAAK,UAAU;AACvB,WAAO;AAAA,EACT;AAkBA,WAAS,MAAMA,OAAM;AAKnB,QAAIA,UAAS,IAAI;AACf,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACAD,WAAU,aAAa;AAAA,MACzB,EAAEC,KAAI;AAAA,IACR;AAGA,QAAIA,UAAS,IAAI;AACf,aAAO,QAAQ;AAAA,QACb;AAAA,QACA;AAAA,QACAD,WAAU,mBAAmB;AAAA,MAC/B,EAAEC,KAAI;AAAA,IACR;AAGA,WAAOD,WAAU,WAAWC,KAAI,IAAI,YAAYA,KAAI;AAAA,EACtD;AAgBA,WAAS,iBAAiBA,OAAM;AAC9B,WAAO,QAAQ;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAkBA,WAAS,WAAWA,OAAM;AAExB,WAAOF,IAAGE,KAAI;AAAA,EAChB;AAkBA,WAAS,YAAYA,OAAM;AACzB,eAAW,YAAY;AACvB,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAMA,SAAS,iBAAiB,SAASF,KAAI,KAAK;AAC1C,SAAO;AAYP,WAAS,cAAcE,OAAM;AAC3B,YAAQ,MAAM,UAAU;AACxB,YAAQ,MAAM,gBAAgB;AAC9B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,gBAAgB;AAC7B,WAAO;AAAA,EACT;AAYA,WAAS,eAAeA,OAAM;AAC5B,WAAO,0BAA0BA,KAAI,IACjC,kBAAkB,SAAS,YAAY,EAAEA,KAAI,IAC7C,aAAaA,KAAI;AAAA,EACvB;AAYA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,IAAI;AACf,aAAO,YAAYA,KAAI;AAAA,IACzB;AACA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,yBAAyBA,OAAM;AACtC,WAAO,0BAA0BA,KAAI,IACjC,kBAAkB,SAAS,eAAe,EAAEA,KAAI,IAChD,YAAYA,KAAI;AAAA,EACtB;AAYA,WAAS,2BAA2BA,OAAM;AACxC,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,gBAAgBA,OAAM;AAC7B,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAEA,KAAI;AAAA,IACR;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAYA,WAAS,mBAAmBA,OAAM;AAChC,WAAO,0BAA0BA,KAAI,IACjC,kBAAkB,SAAS,WAAW,EAAEA,KAAI,IAC5C,YAAYA,KAAI;AAAA,EACtB;AAYA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,gBAAgB;AAC9B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,gBAAgB;AAC7B,cAAQ,KAAK,UAAU;AACvB,aAAOF;AAAA,IACT;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AACF;AAMA,SAAS,sBAAsB,SAASF,KAAI,KAAK;AAC/C,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,cAAcE,OAAM;AAC3B,WAAO,aAAa;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAYA,WAAS,mBAAmBA,OAAM;AAChC,WAAO,KAAK,OAAO,QAAQ;AAAA,MACzB;AAAA,QACE,KAAK,eAAe,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE;AAAA,MACzE;AAAA,IACF,IACIF,IAAGE,KAAI,IACP,IAAIA,KAAI;AAAA,EACd;AAYA,WAAS,qBAAqBA,OAAM;AAClC,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAMA,SAAS,2BAA2B,SAASF,KAAI,KAAK;AACpD,SAAO;AAcP,WAAS,wBAAwBE,OAAM;AAGrC,YAAQ,MAAM,WAAW;AACzB,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,iBAAiB;AAC9B,WAAO;AAAA,EACT;AAcA,WAAS,uBAAuBA,OAAM;AACpC,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,iBAAiB;AAC/B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,iBAAiB;AAC9B,cAAQ,KAAK,WAAW;AACxB,aAAOF;AAAA,IACT;AACA,WAAO,IAAIE,KAAI;AAAA,EACjB;AACF;;;ACxmBA;AAUO,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,EACN,UAAU;AAAA,EACV,YAAY,SAAS;AACvB;AAMA,SAAS,wBAAwB,SAASC,KAAI,KAAK;AACjD,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,YAAY;AAC1B,YAAQ,MAAM,kBAAkB;AAChC,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,kBAAkB;AAC/B,WAAO;AAAA,EACT;AAYA,WAAS,KAAKA,OAAM;AAClB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,aAAa;AAC3B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,aAAa;AAC1B,cAAQ,KAAK,YAAY;AACzB,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AA6BA,WAAS,MAAMA,OAAM;AAMnB,WAAOA,UAAS,MAAM,4BAA4B,KAAK,OAAO,aAC1D,IAAIA,KAAI,IACRD,IAAGC,KAAI;AAAA,EACb;AACF;;;ACpGA;AAUO,IAAM,iBAAiB;AAAA,EAC5B,MAAM;AAAA,EACN,UAAU;AAAA,EACV,YAAY,SAAS;AACvB;AAMA,SAAS,uBAAuB,SAASC,KAAI,KAAK;AAChD,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,WAAW;AACzB,YAAQ,MAAM,aAAa;AAC3B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,aAAa;AAC1B,YAAQ,KAAK,WAAW;AACxB,WAAO;AAAA,EACT;AAGA,WAAS,MAAMA,OAAM;AAKnB,WAAOA,UAAS,MAAM,4BAA4B,KAAK,OAAO,aAC1D,IAAIA,KAAI,IACRD,IAAGC,KAAI;AAAA,EACb;AACF;;;ACrDA;AAUO,IAAM,aAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,mBAAmB,SAASC,KAAI;AACvC,SAAO;AAGP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO,aAAa,SAASD,KAAI,YAAY;AAAA,EAC/C;AACF;;;AC7BA;;;ACAA;AAWO,IAAM,gBAAgB;AAAA,EAC3B,MAAM;AAAA,EACN,UAAU;AACZ;AAMA,SAAS,sBAAsB,SAASE,KAAI,KAAK;AAC/C,MAAI,OAAO;AAEX,MAAI;AACJ,SAAO;AAYP,WAAS,MAAMC,OAAM;AACnB,YAAQ,MAAM,eAAe;AAE7B,WAAO,OAAOA,KAAI;AAAA,EACpB;AAYA,WAAS,OAAOA,OAAM;AACpB,aAASA;AACT,WAAO,QAAQA,KAAI;AAAA,EACrB;AAYA,WAAS,QAAQA,OAAM;AACrB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,MAAM,uBAAuB;AACrC,aAAO,SAASA,KAAI;AAAA,IACtB;AACA,QAAI,QAAQ,MAAMA,UAAS,QAAQ,mBAAmBA,KAAI,IAAI;AAC5D,cAAQ,KAAK,eAAe;AAC5B,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,SAASA,OAAM;AACtB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,uBAAuB;AACpC,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,SAAS,YAAY,EAAEA,KAAI,IACjD,QAAQA,KAAI;AAAA,EAClB;AACF;;;ADpFO,IAAM,OAAO;AAAA,EAClB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,cAAc;AAAA,IACZ,UAAU;AAAA,EACZ;AAAA,EACA,MAAM;AACR;AAGA,IAAM,oCAAoC;AAAA,EACxC,UAAU;AAAA,EACV,SAAS;AACX;AAGA,IAAM,kBAAkB;AAAA,EACtB,UAAU;AAAA,EACV,SAAS;AACX;AASA,SAAS,kBAAkB,SAASC,KAAI,KAAK;AAC3C,QAAM,OAAO;AACb,QAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,MAAI,cACF,QAAQ,KAAK,CAAC,EAAE,SAAS,eACrB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,SACtC;AACN,MAAI,OAAO;AACX,SAAO;AAGP,WAAS,MAAMC,OAAM;AACnB,UAAM,OACJ,KAAK,eAAe,SACnBA,UAAS,MAAMA,UAAS,MAAMA,UAAS,KACpC,kBACA;AACN,QACE,SAAS,kBACL,CAAC,KAAK,eAAe,UAAUA,UAAS,KAAK,eAAe,SAC5D,WAAWA,KAAI,GACnB;AACA,UAAI,CAAC,KAAK,eAAe,MAAM;AAC7B,aAAK,eAAe,OAAO;AAC3B,gBAAQ,MAAM,MAAM;AAAA,UAClB,YAAY;AAAA,QACd,CAAC;AAAA,MACH;AACA,UAAI,SAAS,iBAAiB;AAC5B,gBAAQ,MAAM,gBAAgB;AAC9B,eAAOA,UAAS,MAAMA,UAAS,KAC3B,QAAQ,MAAM,eAAe,KAAK,QAAQ,EAAEA,KAAI,IAChD,SAASA,KAAI;AAAA,MACnB;AACA,UAAI,CAAC,KAAK,aAAaA,UAAS,IAAI;AAClC,gBAAQ,MAAM,gBAAgB;AAC9B,gBAAQ,MAAM,eAAe;AAC7B,eAAO,OAAOA,KAAI;AAAA,MACpB;AAAA,IACF;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAGA,WAAS,OAAOA,OAAM;AACpB,QAAI,WAAWA,KAAI,KAAK,EAAE,OAAO,IAAI;AACnC,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,SACG,CAAC,KAAK,aAAa,OAAO,OAC1B,KAAK,eAAe,SACjBA,UAAS,KAAK,eAAe,SAC7BA,UAAS,MAAMA,UAAS,KAC5B;AACA,cAAQ,KAAK,eAAe;AAC5B,aAAO,SAASA,KAAI;AAAA,IACtB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAKA,WAAS,SAASA,OAAM;AACtB,YAAQ,MAAM,gBAAgB;AAC9B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,gBAAgB;AAC7B,SAAK,eAAe,SAAS,KAAK,eAAe,UAAUA;AAC3D,WAAO,QAAQ;AAAA,MACb;AAAA;AAAA,MAEA,KAAK,YAAY,MAAM;AAAA,MACvB,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,WAAS,QAAQA,OAAM;AACrB,SAAK,eAAe,mBAAmB;AACvC;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAGA,WAAS,YAAYA,OAAM;AACzB,QAAI,cAAcA,KAAI,GAAG;AACvB,cAAQ,MAAM,0BAA0B;AACxC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,0BAA0B;AACvC,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAGA,WAAS,YAAYA,OAAM;AACzB,SAAK,eAAe,OAClB,cACA,KAAK,eAAe,QAAQ,KAAK,gBAAgB,GAAG,IAAI,EAAE;AAC5D,WAAOD,IAAGC,KAAI;AAAA,EAChB;AACF;AAMA,SAAS,yBAAyB,SAASD,KAAI,KAAK;AAClD,QAAM,OAAO;AACb,OAAK,eAAe,aAAa;AACjC,SAAO,QAAQ,MAAM,WAAW,SAAS,QAAQ;AAGjD,WAAS,QAAQC,OAAM;AACrB,SAAK,eAAe,oBAClB,KAAK,eAAe,qBACpB,KAAK,eAAe;AAItB,WAAO;AAAA,MACL;AAAA,MACAD;AAAA,MACA;AAAA,MACA,KAAK,eAAe,OAAO;AAAA,IAC7B,EAAEC,KAAI;AAAA,EACR;AAGA,WAAS,SAASA,OAAM;AACtB,QAAI,KAAK,eAAe,qBAAqB,CAAC,cAAcA,KAAI,GAAG;AACjE,WAAK,eAAe,oBAAoB;AACxC,WAAK,eAAe,mBAAmB;AACvC,aAAO,iBAAiBA,KAAI;AAAA,IAC9B;AACA,SAAK,eAAe,oBAAoB;AACxC,SAAK,eAAe,mBAAmB;AACvC,WAAO,QAAQ,QAAQ,iBAAiBD,KAAI,gBAAgB,EAAEC,KAAI;AAAA,EACpE;AAGA,WAAS,iBAAiBA,OAAM;AAE9B,SAAK,eAAe,aAAa;AAEjC,SAAK,YAAY;AAGjB,WAAO;AAAA,MACL;AAAA,MACA,QAAQ,QAAQ,MAAMD,KAAI,GAAG;AAAA,MAC7B;AAAA,MACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA;AAAA,IACN,EAAEC,KAAI;AAAA,EACR;AACF;AAMA,SAAS,eAAe,SAASD,KAAI,KAAK;AACxC,QAAM,OAAO;AACb,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,eAAe,OAAO;AAAA,EAC7B;AAGA,WAAS,YAAYC,OAAM;AACzB,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,WAAO,QACL,KAAK,CAAC,EAAE,SAAS,oBACjB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,WAAW,KAAK,eAAe,OACnED,IAAGC,KAAI,IACP,IAAIA,KAAI;AAAA,EACd;AACF;AAMA,SAAS,gBAAgB,SAAS;AAChC,UAAQ,KAAK,KAAK,eAAe,IAAI;AACvC;AAMA,SAAS,iCAAiC,SAASD,KAAI,KAAK;AAC1D,QAAM,OAAO;AAIb,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA,IAAI;AAAA,EACV;AAGA,WAAS,YAAYC,OAAM;AACzB,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,WAAO,CAAC,cAAcA,KAAI,KACxB,QACA,KAAK,CAAC,EAAE,SAAS,6BACfD,IAAGC,KAAI,IACP,IAAIA,KAAI;AAAA,EACd;AACF;;;AE3QA;AAYO,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,EACN,UAAU;AAAA,EACV,WAAW;AACb;AAGA,SAAS,yBAAyB,QAAQ,SAAS;AAEjD,MAAIC,SAAQ,OAAO;AAEnB,MAAIC;AAEJ,MAAIC;AAEJ,MAAIC;AAIJ,SAAOH,UAAS;AACd,QAAI,OAAOA,MAAK,EAAE,CAAC,MAAM,SAAS;AAChC,UAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,WAAW;AACvC,QAAAC,WAAUD;AACV;AAAA,MACF;AACA,UAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,aAAa;AACzC,QAAAE,QAAOF;AAAA,MACT;AAAA,IACF,OAEK;AACH,UAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,WAAW;AAEvC,eAAO,OAAOA,QAAO,CAAC;AAAA,MACxB;AACA,UAAI,CAACG,eAAc,OAAOH,MAAK,EAAE,CAAC,EAAE,SAAS,cAAc;AACzD,QAAAG,cAAaH;AAAA,MACf;AAAA,IACF;AAAA,EACF;AACA,QAAM,UAAU;AAAA,IACd,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAOE,KAAI,EAAE,CAAC,EAAE,KAAK;AAAA,IAC9C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,EACzD;AAGA,SAAOA,KAAI,EAAE,CAAC,EAAE,OAAO;AAIvB,MAAIC,aAAY;AACd,WAAO,OAAOD,OAAM,GAAG,CAAC,SAAS,SAAS,OAAO,CAAC;AAClD,WAAO,OAAOC,cAAa,GAAG,GAAG,CAAC,QAAQ,OAAOF,QAAO,EAAE,CAAC,GAAG,OAAO,CAAC;AACtE,WAAOA,QAAO,EAAE,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAG,OAAOE,WAAU,EAAE,CAAC,EAAE,GAAG;AAAA,EACtE,OAAO;AACL,WAAOF,QAAO,EAAE,CAAC,IAAI;AAAA,EACvB;AAGA,SAAO,KAAK,CAAC,QAAQ,SAAS,OAAO,CAAC;AACtC,SAAO;AACT;AAMA,SAAS,wBAAwB,SAASG,KAAI,KAAK;AACjD,QAAM,OAAO;AAEb,MAAI;AACJ,SAAO;AAaP,WAAS,MAAMC,OAAM;AACnB,QAAIL,SAAQ,KAAK,OAAO;AAExB,QAAI;AAEJ,WAAOA,UAAS;AAGd,UACE,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBAC/B,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBAC/B,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,WAC/B;AACA,oBAAY,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS;AAC3C;AAAA,MACF;AAAA,IACF;AAIA,QAAI,CAAC,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,MAAM,KAAK,aAAa,YAAY;AACvE,cAAQ,MAAM,mBAAmB;AACjC,eAASK;AACT,aAAO,OAAOA,KAAI;AAAA,IACpB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAaA,WAAS,OAAOA,OAAM;AACpB,YAAQ,MAAM,2BAA2B;AACzC,WAAO,OAAOA,KAAI;AAAA,EACpB;AAaA,WAAS,OAAOA,OAAM;AACpB,QAAIA,UAAS,QAAQ;AACnB,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,2BAA2B;AACxC,WAAO,cAAcA,KAAI,IACrB,aAAa,SAAS,OAAO,YAAY,EAAEA,KAAI,IAC/C,MAAMA,KAAI;AAAA,EAChB;AAaA,WAAS,MAAMA,OAAM;AACnB,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,mBAAmB;AAChC,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;;;AlCtKA,IAAM,SAAS;AAAA,EACb,UAAUC;AAAA,EACV,SAAS;AACX;AAeO,SAAS,cAAc;AAE5B,SAAO;AAAA,IACL,UAAU;AAAA,MACR,CAAC,EAAE,GAAG;AAAA,QACJ,UAAU;AAAA,QACV,cAAc;AAAA,UACZ,UAAU;AAAA,QACZ;AAAA,QACA,MAAM;AAAA,MACR;AAAA,IACF;AAAA,IACA,MAAM;AAAA,MACJ,CAAC,EAAE,GAAG;AAAA,QACJ,UAAU;AAAA,MACZ;AAAA,MACA,CAAC,EAAE,GAAG;AAAA,QACJ,KAAK;AAAA,QACL,UAAU;AAAA,QACV,WAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACF;AAOA,SAAS,iCAAiC,SAASC,KAAI,KAAK;AAC1D,QAAM,OAAO;AACb,MAAIC,SAAQ,KAAK,OAAO;AAGxB,QAAMC,WAAU,KAAK,OAAO,iBAAiB,KAAK,OAAO,eAAe,CAAC;AAEzE,MAAI;AAGJ,SAAOD,UAAS;AACd,UAAM,QAAQ,KAAK,OAAOA,MAAK,EAAE,CAAC;AAClC,QAAI,MAAM,SAAS,cAAc;AAC/B,mBAAa;AACb;AAAA,IACF;AAGA,QACE,MAAM,SAAS,qBACf,MAAM,SAAS,eACf,MAAM,SAAS,WACf,MAAM,SAAS,WACf,MAAM,SAAS,QACf;AACA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAKP,WAAS,MAAME,OAAM;AACnB,QAAI,CAAC,cAAc,CAAC,WAAW,WAAW;AACxC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,UAAM,KAAK;AAAA,MACT,KAAK,eAAe;AAAA,QAClB,OAAO,WAAW;AAAA,QAClB,KAAK,KAAK,IAAI;AAAA,MAChB,CAAC;AAAA,IACH;AACA,QAAI,GAAG,YAAY,CAAC,MAAM,MAAM,CAACD,SAAQ,SAAS,GAAG,MAAM,CAAC,CAAC,GAAG;AAC9D,aAAO,IAAIC,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,4BAA4B;AAC1C,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,4BAA4B;AACzC,WAAOH,IAAGG,KAAI;AAAA,EAChB;AACF;AAIA,SAAS,kCAAkC,QAAQ,SAAS;AAC1D,MAAIF,SAAQ,OAAO;AAEnB,MAAI;AAGJ,SAAOA,UAAS;AACd,QACE,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,gBAC1B,OAAOA,MAAK,EAAE,CAAC,MAAM,SACrB;AACA,mBAAa,OAAOA,MAAK,EAAE,CAAC;AAC5B;AAAA,IACF;AAAA,EACF;AAEA,SAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,OAAO;AAC5B,SAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,OAAO;AAI5B,QAAM,OAAO;AAAA,IACX,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,KAAK;AAAA,IACnD,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,EACzD;AAGA,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,IACjD,KAAK,OAAO,OAAO,CAAC,GAAG,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,EACjD;AAEA,SAAO,IAAI;AACX,SAAO,IAAI;AACX,SAAO,IAAI;AAEX,QAAMG,UAAS;AAAA,IACb,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,GAAG;AAAA,IACnC,KAAK,OAAO,OAAO,CAAC,GAAG,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,KAAK;AAAA,EAC3D;AAEA,QAAM,QAAQ;AAAA,IACZ,MAAM;AAAA,IACN,aAAa;AAAA,IACb,OAAO,OAAO,OAAO,CAAC,GAAGA,QAAO,KAAK;AAAA,IACrC,KAAK,OAAO,OAAO,CAAC,GAAGA,QAAO,GAAG;AAAA,EACnC;AAGA,QAAM,cAAc;AAAA;AAAA,IAElB,OAAOH,SAAQ,CAAC;AAAA,IAChB,OAAOA,SAAQ,CAAC;AAAA,IAChB,CAAC,SAAS,MAAM,OAAO;AAAA;AAAA,IAEvB,OAAOA,SAAQ,CAAC;AAAA,IAChB,OAAOA,SAAQ,CAAC;AAAA;AAAA,IAEhB,CAAC,SAAS,QAAQ,OAAO;AAAA,IACzB,CAAC,QAAQ,QAAQ,OAAO;AAAA;AAAA,IAExB,CAAC,SAASG,SAAQ,OAAO;AAAA,IACzB,CAAC,SAAS,OAAO,OAAO;AAAA,IACxB,CAAC,QAAQ,OAAO,OAAO;AAAA,IACvB,CAAC,QAAQA,SAAQ,OAAO;AAAA;AAAA,IAExB,OAAO,OAAO,SAAS,CAAC;AAAA,IACxB,OAAO,OAAO,SAAS,CAAC;AAAA,IACxB,CAAC,QAAQ,MAAM,OAAO;AAAA,EACxB;AACA,SAAO,OAAOH,QAAO,OAAO,SAASA,SAAQ,GAAG,GAAG,WAAW;AAC9D,SAAO;AACT;AAMA,SAAS,wBAAwB,SAASD,KAAI,KAAK;AACjD,QAAM,OAAO;AAGb,QAAME,WAAU,KAAK,OAAO,iBAAiB,KAAK,OAAO,eAAe,CAAC;AACzE,MAAI,OAAO;AAEX,MAAIG;AAOJ,SAAO;AAYP,WAAS,MAAMF,OAAM;AACnB,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,MAAM,4BAA4B;AAC1C,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,4BAA4B;AACzC,WAAO;AAAA,EACT;AAYA,WAAS,UAAUA,OAAM;AACvB,QAAIA,UAAS;AAAI,aAAO,IAAIA,KAAI;AAChC,YAAQ,MAAM,uBAAuB;AACrC,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,uBAAuB;AACpC,YAAQ,MAAM,uBAAuB;AACrC,YAAQ,MAAM,aAAa,EAAE,cAAc;AAC3C,WAAO;AAAA,EACT;AAYA,WAAS,SAASA,OAAM;AACtB;AAAA;AAAA,MAEE,OAAO;AAAA,MAENA,UAAS,MAAM,CAACE;AAAA;AAAA,MAGjBF,UAAS,QACTA,UAAS,MACT,0BAA0BA,KAAI;AAAA,MAC9B;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,KAAK,aAAa;AAC1B,YAAM,QAAQ,QAAQ,KAAK,uBAAuB;AAClD,UAAI,CAACD,SAAQ,SAAS,oBAAoB,KAAK,eAAe,KAAK,CAAC,CAAC,GAAG;AACtE,eAAO,IAAIC,KAAI;AAAA,MACjB;AACA,cAAQ,MAAM,4BAA4B;AAC1C,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,4BAA4B;AACzC,cAAQ,KAAK,iBAAiB;AAC9B,aAAOH;AAAA,IACT;AACA,QAAI,CAAC,0BAA0BG,KAAI,GAAG;AACpC,MAAAE,QAAO;AAAA,IACT;AACA;AACA,YAAQ,QAAQF,KAAI;AACpB,WAAOA,UAAS,KAAK,aAAa;AAAA,EACpC;AAYA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,WAAO,SAASA,KAAI;AAAA,EACtB;AACF;AAMA,SAAS,wBAAwB,SAASH,KAAI,KAAK;AACjD,QAAM,OAAO;AAGb,QAAME,WAAU,KAAK,OAAO,iBAAiB,KAAK,OAAO,eAAe,CAAC;AAEzE,MAAI;AACJ,MAAI,OAAO;AAEX,MAAIG;AACJ,SAAO;AAYP,WAAS,MAAMF,OAAM;AACnB,YAAQ,MAAM,uBAAuB,EAAE,aAAa;AACpD,YAAQ,MAAM,4BAA4B;AAC1C,YAAQ,MAAM,kCAAkC;AAChD,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,kCAAkC;AAC/C,WAAO;AAAA,EACT;AAYA,WAAS,cAAcA,OAAM;AAC3B,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,6BAA6B;AAC3C,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,6BAA6B;AAC1C,cAAQ,MAAM,kCAAkC;AAChD,cAAQ,MAAM,aAAa,EAAE,cAAc;AAC3C,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAeA,WAAS,YAAYA,OAAM;AACzB;AAAA;AAAA,MAEE,OAAO;AAAA,MAENA,UAAS,MAAM,CAACE;AAAA;AAAA,MAGjBF,UAAS,QACTA,UAAS,MACT,0BAA0BA,KAAI;AAAA,MAC9B;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAIA,UAAS,IAAI;AACf,cAAQ,KAAK,aAAa;AAC1B,YAAM,QAAQ,QAAQ,KAAK,kCAAkC;AAC7D,mBAAa,oBAAoB,KAAK,eAAe,KAAK,CAAC;AAC3D,cAAQ,MAAM,kCAAkC;AAChD,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kCAAkC;AAC/C,cAAQ,KAAK,4BAA4B;AACzC,aAAO;AAAA,IACT;AACA,QAAI,CAAC,0BAA0BA,KAAI,GAAG;AACpC,MAAAE,QAAO;AAAA,IACT;AACA;AACA,YAAQ,QAAQF,KAAI;AACpB,WAAOA,UAAS,KAAK,cAAc;AAAA,EACrC;AAeA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,MAAMA,UAAS,MAAMA,UAAS,IAAI;AAC7C,cAAQ,QAAQA,KAAI;AACpB;AACA,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAYA,WAAS,WAAWA,OAAM;AACxB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAC/B,UAAI,CAACD,SAAQ,SAAS,UAAU,GAAG;AACjC,QAAAA,SAAQ,KAAK,UAAU;AAAA,MACzB;AAKA,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,IAAIC,KAAI;AAAA,EACjB;AAYA,WAAS,gBAAgBA,OAAM;AAE7B,WAAOH,IAAGG,KAAI;AAAA,EAChB;AACF;AAMA,SAAS,+BAA+B,SAASH,KAAI,KAAK;AAUxD,SAAO,QAAQ,MAAM,WAAWA,KAAI,QAAQ,QAAQ,QAAQA,KAAI,GAAG,CAAC;AACtE;AAGA,SAAS,yBAAyB,SAAS;AACzC,UAAQ,KAAK,uBAAuB;AACtC;AAMA,SAASD,gBAAe,SAASC,KAAI,KAAK;AACxC,QAAM,OAAO;AACb,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,IAAI;AAAA,EACN;AAKA,WAAS,YAAYG,OAAM;AACzB,UAAM,OAAO,KAAK,OAAO,KAAK,OAAO,SAAS,CAAC;AAC/C,WAAO,QACL,KAAK,CAAC,EAAE,SAAS,iCACjB,KAAK,CAAC,EAAE,eAAe,KAAK,CAAC,GAAG,IAAI,EAAE,WAAW,IAC/CH,IAAGG,KAAI,IACP,IAAIA,KAAI;AAAA,EACd;AACF;;;AmCthBA;;;ACAA;AA8BO,SAAS,iBAAiB,SAAS;AACxC,QAAM,WAAW,WAAW,CAAC;AAC7B,MAAI,SAAS,SAAS;AACtB,QAAM,YAAY;AAAA,IAChB,UAAU;AAAA,IACV,YAAY;AAAA,EACd;AACA,MAAI,WAAW,QAAQ,WAAW,QAAW;AAC3C,aAAS;AAAA,EACX;AACA,SAAO;AAAA,IACL,MAAM;AAAA,MACJ,CAAC,GAAG,GAAG;AAAA,IACT;AAAA,IACA,YAAY;AAAA,MACV,MAAM,CAAC,SAAS;AAAA,IAClB;AAAA,IACA,kBAAkB;AAAA,MAChB,MAAM,CAAC,GAAG;AAAA,IACZ;AAAA,EACF;AAOA,WAAS,wBAAwB,QAAQ,SAAS;AAChD,QAAIG,SAAQ;AAGZ,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAE9B,UACE,OAAOA,MAAK,EAAE,CAAC,MAAM,WACrB,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,oCAC1B,OAAOA,MAAK,EAAE,CAAC,EAAE,QACjB;AACA,YAAI,OAAOA;AAGX,eAAO,QAAQ;AAEb,cACE,OAAO,IAAI,EAAE,CAAC,MAAM,UACpB,OAAO,IAAI,EAAE,CAAC,EAAE,SAAS,oCACzB,OAAO,IAAI,EAAE,CAAC,EAAE;AAAA,UAEhB,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,SAAS,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,WACnD,OAAO,IAAI,EAAE,CAAC,EAAE,IAAI,SAAS,OAAO,IAAI,EAAE,CAAC,EAAE,MAAM,QACrD;AACA,mBAAOA,MAAK,EAAE,CAAC,EAAE,OAAO;AACxB,mBAAO,IAAI,EAAE,CAAC,EAAE,OAAO;AAGvB,kBAAM,gBAAgB;AAAA,cACpB,MAAM;AAAA,cACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,KAAK;AAAA,cAC9C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAOA,MAAK,EAAE,CAAC,EAAE,GAAG;AAAA,YAC7C;AAGA,kBAAMC,QAAO;AAAA,cACX,MAAM;AAAA,cACN,OAAO,OAAO,OAAO,CAAC,GAAG,OAAO,IAAI,EAAE,CAAC,EAAE,GAAG;AAAA,cAC5C,KAAK,OAAO,OAAO,CAAC,GAAG,OAAOD,MAAK,EAAE,CAAC,EAAE,KAAK;AAAA,YAC/C;AAIA,kBAAM,aAAa;AAAA,cACjB,CAAC,SAAS,eAAe,OAAO;AAAA,cAChC,CAAC,SAAS,OAAO,IAAI,EAAE,CAAC,GAAG,OAAO;AAAA,cAClC,CAAC,QAAQ,OAAO,IAAI,EAAE,CAAC,GAAG,OAAO;AAAA,cACjC,CAAC,SAASC,OAAM,OAAO;AAAA,YACzB;AACA,kBAAMC,cAAa,QAAQ,OAAO,WAAW,WAAW;AACxD,gBAAIA,aAAY;AAEd;AAAA,gBACE;AAAA,gBACA,WAAW;AAAA,gBACX;AAAA,gBACA,WAAWA,aAAY,OAAO,MAAM,OAAO,GAAGF,MAAK,GAAG,OAAO;AAAA,cAC/D;AAAA,YACF;AAGA,mBAAO,YAAY,WAAW,QAAQ,GAAG;AAAA,cACvC,CAAC,QAAQC,OAAM,OAAO;AAAA,cACtB,CAAC,SAAS,OAAOD,MAAK,EAAE,CAAC,GAAG,OAAO;AAAA,cACnC,CAAC,QAAQ,OAAOA,MAAK,EAAE,CAAC,GAAG,OAAO;AAAA,cAClC,CAAC,QAAQ,eAAe,OAAO;AAAA,YACjC,CAAC;AACD,mBAAO,QAAQ,OAAO,GAAGA,SAAQ,OAAO,GAAG,UAAU;AACrD,YAAAA,SAAQ,OAAO,WAAW,SAAS;AACnC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,IAAAA,SAAQ;AACR,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,UAAI,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,kCAAkC;AAC9D,eAAOA,MAAK,EAAE,CAAC,EAAE,OAAO;AAAA,MAC1B;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAMA,WAAS,sBAAsB,SAASG,KAAI,KAAK;AAC/C,UAAMC,YAAW,KAAK;AACtB,UAAM,SAAS,KAAK;AACpB,QAAI,OAAO;AACX,WAAO;AAGP,aAAS,MAAMC,OAAM;AACnB,UACED,cAAa,OACb,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS,mBACtC;AACA,eAAO,IAAIC,KAAI;AAAA,MACjB;AACA,cAAQ,MAAM,gCAAgC;AAC9C,aAAO,KAAKA,KAAI;AAAA,IAClB;AAGA,aAAS,KAAKA,OAAM;AAClB,YAAM,SAAS,kBAAkBD,SAAQ;AACzC,UAAIC,UAAS,KAAK;AAEhB,YAAI,OAAO;AAAG,iBAAO,IAAIA,KAAI;AAC7B,gBAAQ,QAAQA,KAAI;AACpB;AACA,eAAO;AAAA,MACT;AACA,UAAI,OAAO,KAAK,CAAC;AAAQ,eAAO,IAAIA,KAAI;AACxC,YAAM,QAAQ,QAAQ,KAAK,gCAAgC;AAC3D,YAAM,QAAQ,kBAAkBA,KAAI;AACpC,YAAM,QAAQ,CAAC,SAAU,UAAU,KAAK,QAAQ,MAAM;AACtD,YAAM,SAAS,CAAC,UAAW,WAAW,KAAK,QAAQ,KAAK;AACxD,aAAOF,IAAGE,KAAI;AAAA,IAChB;AAAA,EACF;AACF;;;ACpLA;;;ACAA;;;ACAA;AAyBO,IAAM,UAAN,MAAc;AAAA;AAAA;AAAA;AAAA,EAInB,cAAc;AAMZ,SAAK,MAAM,CAAC;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAIC,QAAO,QAAQ,KAAK;AACtB,YAAQ,MAAMA,QAAO,QAAQ,GAAG;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,QAAQ,QAAQ;AACd,SAAK,IAAI,KAAK,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAGnC,QAAI,KAAK,IAAI,WAAW,GAAG;AACzB;AAAA,IACF;AAoBA,QAAIA,SAAQ,KAAK,IAAI;AAErB,UAAM,OAAO,CAAC;AACd,WAAOA,SAAQ,GAAG;AAChB,MAAAA,UAAS;AACT,WAAK,KAAK,OAAO,MAAM,KAAK,IAAIA,MAAK,EAAE,CAAC,IAAI,KAAK,IAAIA,MAAK,EAAE,CAAC,CAAC,CAAC;AAE/D,WAAK,KAAK,KAAK,IAAIA,MAAK,EAAE,CAAC,CAAC;AAG5B,aAAO,SAAS,KAAK,IAAIA,MAAK,EAAE,CAAC;AAAA,IACnC;AACA,SAAK,KAAK,CAAC,GAAG,MAAM,CAAC;AACrB,WAAO,SAAS;AAChB,QAAI,QAAQ,KAAK,IAAI;AACrB,WAAO,OAAO;AACZ,aAAO,KAAK,GAAG,KAAK;AACpB,cAAQ,KAAK,IAAI;AAAA,IACnB;AAGA,SAAK,IAAI,SAAS;AAAA,EACpB;AACF;AAWA,SAAS,QAAQ,SAAS,IAAI,QAAQ,KAAK;AACzC,MAAIA,SAAQ;AAGZ,MAAI,WAAW,KAAK,IAAI,WAAW,GAAG;AACpC;AAAA,EACF;AACA,SAAOA,SAAQ,QAAQ,IAAI,QAAQ;AACjC,QAAI,QAAQ,IAAIA,MAAK,EAAE,CAAC,MAAM,IAAI;AAChC,cAAQ,IAAIA,MAAK,EAAE,CAAC,KAAK;AAOzB,cAAQ,IAAIA,MAAK,EAAE,CAAC,EAAE,KAAK,GAAG,GAAG;AAGjC;AAAA,IACF;AACA,IAAAA,UAAS;AAAA,EACX;AACA,UAAQ,IAAI,KAAK,CAAC,IAAI,QAAQ,GAAG,CAAC;AACpC;;;ACzJA;AAeO,SAAS,cAAc,QAAQC,QAAO;AAC3C,MAAI,iBAAiB;AAErB,QAAM,QAAQ,CAAC;AACf,SAAOA,SAAQ,OAAO,QAAQ;AAC5B,UAAM,QAAQ,OAAOA,MAAK;AAC1B,QAAI,gBAAgB;AAClB,UAAI,MAAM,CAAC,MAAM,SAAS;AAGxB,YAAI,MAAM,CAAC,EAAE,SAAS,gBAAgB;AACpC,gBAAM;AAAA,YACJ,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,yBAC1B,SACA;AAAA,UACN;AAAA,QACF;AAAA,MACF,WAIS,MAAM,CAAC,EAAE,SAAS,gBAAgB;AACzC,YAAI,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE,SAAS,wBAAwB;AACxD,gBAAM,aAAa,MAAM,SAAS;AAClC,gBAAM,UAAU,IAAI,MAAM,UAAU,MAAM,SAAS,WAAW;AAAA,QAChE;AAAA,MACF,WAES,MAAM,CAAC,EAAE,SAAS,qBAAqB;AAC9C;AAAA,MACF;AAAA,IACF,WAAW,MAAM,CAAC,MAAM,WAAW,MAAM,CAAC,EAAE,SAAS,qBAAqB;AACxE,uBAAiB;AAAA,IACnB;AACA,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;;;AFhBO,IAAM,WAAW;AAAA,EACtB,MAAM;AAAA,IACJ,MAAM;AAAA,MACJ,UAAU;AAAA,MACV,YAAY;AAAA,IACd;AAAA,EACF;AACF;AAMA,SAAS,cAAc,SAASC,KAAI,KAAK;AACvC,QAAM,OAAO;AACb,MAAI,OAAO;AACX,MAAI,QAAQ;AAEZ,MAAI;AACJ,SAAO;AAkBP,WAAS,MAAMC,OAAM;AACnB,QAAIC,SAAQ,KAAK,OAAO,SAAS;AACjC,WAAOA,SAAQ,IAAI;AACjB,YAAM,OAAO,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE;AACnC,UACE,SAAS;AAAA,MAET,SAAS;AAET,QAAAA;AAAA;AACG;AAAA,IACP;AACA,UAAM,OAAOA,SAAQ,KAAK,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,OAAO;AACvD,UAAM,OACJ,SAAS,eAAe,SAAS,aAAa,eAAe;AAG/D,QAAI,SAAS,gBAAgB,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,GAAG;AAC9D,aAAO,IAAID,KAAI;AAAA,IACjB;AACA,WAAO,KAAKA,KAAI;AAAA,EAClB;AAcA,WAAS,cAAcA,OAAM;AAC3B,YAAQ,MAAM,WAAW;AACzB,YAAQ,MAAM,UAAU;AACxB,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAcA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,KAAK;AAChB,aAAO,aAAaA,KAAI;AAAA,IAC1B;AAYA,WAAO;AAEP,aAAS;AACT,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAgBA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,MAAM;AAEjB,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAE5B,UAAI,QAAQ,GAAG;AACb,gBAAQ;AAGR,aAAK,YAAY;AACjB,gBAAQ,KAAK,UAAU;AACvB,gBAAQ,MAAM,YAAY;AAC1B,gBAAQ,QAAQA,KAAI;AACpB,gBAAQ,KAAK,YAAY;AACzB,eAAO;AAAA,MACT;AAGA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,QAAI,cAAcA,KAAI,GAAG;AAIvB,aAAO,aAAa,SAAS,cAAc,YAAY,EAAEA,KAAI;AAAA,IAC/D;AACA,aAAS;AACT,QAAI,MAAM;AACR,aAAO;AAEP,cAAQ;AAAA,IACV;AACA,QAAIA,UAAS,KAAK;AAChB,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAE/B,aAAO;AACP,aAAO;AAAA,IACT;AAGA,YAAQ,MAAM,MAAM;AACpB,WAAO,YAAYA,KAAI;AAAA,EACzB;AAcA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,QAAQA,UAAS,OAAO,0BAA0BA,KAAI,GAAG;AACpE,cAAQ,KAAK,MAAM;AACnB,aAAO,aAAaA,KAAI;AAAA,IAC1B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOA,UAAS,KAAK,gBAAgB;AAAA,EACvC;AAcA,WAAS,cAAcA,OAAM;AAC3B,QAAIA,UAAS,MAAMA,UAAS,KAAK;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AAcA,WAAS,mBAAmBA,OAAM;AAEhC,SAAK,YAAY;AAGjB,QAAI,KAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,GAAG;AACrC,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,mBAAmB;AAEjC,WAAO;AACP,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IACvD,SACA;AAAA,MACN,EAAEA,KAAI;AAAA,IACR;AACA,WAAO,oBAAoBA,KAAI;AAAA,EACjC;AAgBA,WAAS,oBAAoBA,OAAM;AACjC,QAAIA,UAAS,MAAMA,UAAS,IAAI;AAC9B,aAAO,yBAAyBA,KAAI;AAAA,IACtC;AACA,QAAIA,UAAS,KAAK;AAChB,aAAO;AAEP,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAC/B,aAAO;AAAA,IACT;AAGA,WAAO,iBAAiBA,KAAI;AAAA,EAC9B;AAaA,WAAS,wBAAwBA,OAAM;AACrC,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO,aAAa,SAAS,0BAA0B,YAAY,EAAEA,KAAI;AAAA,IAC3E;AACA,WAAO,yBAAyBA,KAAI;AAAA,EACtC;AAaA,WAAS,yBAAyBA,OAAM;AAEtC,QAAIA,UAAS,IAAI;AACf,eAAS;AACT,aAAO;AACP,cAAQ,MAAM,sBAAsB;AACpC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,sBAAsB;AACnC,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,IAAI;AACf,eAAS;AAET,aAAO,gCAAgCA,KAAI;AAAA,IAC7C;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,aAAO,uBAAuBA,KAAI;AAAA,IACpC;AACA,WAAO,iBAAiBA,KAAI;AAAA,EAC9B;AAaA,WAAS,gCAAgCA,OAAM;AAC7C,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,sBAAsB;AACpC,aAAO,oBAAoBA,KAAI;AAAA,IACjC;AAGA,WAAO,iBAAiBA,KAAI;AAAA,EAC9B;AAaA,WAAS,oBAAoBA,OAAM;AACjC,QAAIA,UAAS,IAAI;AACf,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AAGA,QAAIA,UAAS,IAAI;AACf,aAAO;AACP,cAAQ,KAAK,sBAAsB;AACnC,cAAQ,MAAM,sBAAsB;AACpC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,sBAAsB;AACnC,aAAO;AAAA,IACT;AACA,YAAQ,KAAK,sBAAsB;AACnC,WAAO,iCAAiCA,KAAI;AAAA,EAC9C;AAaA,WAAS,iCAAiCA,OAAM;AAC9C,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO,aAAa,SAAS,wBAAwB,YAAY,EAAEA,KAAI;AAAA,IACzE;AACA,WAAO,uBAAuBA,KAAI;AAAA,EACpC;AAaA,WAAS,uBAAuBA,OAAM;AACpC,QAAIA,UAAS,KAAK;AAChB,aAAO,oBAAoBA,KAAI;AAAA,IACjC;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAK7C,UAAI,CAAC,QAAQ,SAAS,OAAO;AAC3B,eAAO,iBAAiBA,KAAI;AAAA,MAC9B;AAGA,cAAQ,KAAK,mBAAmB;AAChC,cAAQ,KAAK,WAAW;AAGxB,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,WAAO,iBAAiBA,KAAI;AAAA,EAC9B;AAaA,WAAS,iBAAiBA,OAAM;AAE9B,WAAO,IAAIA,KAAI;AAAA,EACjB;AAcA,WAAS,aAAaA,OAAM;AAI1B,YAAQ,MAAM,UAAU;AACxB,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAgBA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,KAAK;AAChB,cAAQ,MAAM,kBAAkB;AAChC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,kBAAkB;AAC/B,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,QAAQ,mBAAmBA,KAAI,GAAG;AAC7C,cAAQ,KAAK,UAAU;AACvB,aAAOD,IAAGC,KAAI;AAAA,IAChB;AACA,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO,aAAa,SAAS,cAAc,YAAY,EAAEA,KAAI;AAAA,IAC/D;AAGA,YAAQ,MAAM,MAAM;AACpB,WAAO,YAAYA,KAAI;AAAA,EACzB;AAcA,WAAS,YAAYA,OAAM;AACzB,QAAIA,UAAS,QAAQA,UAAS,OAAO,0BAA0BA,KAAI,GAAG;AACpE,cAAQ,KAAK,MAAM;AACnB,aAAO,aAAaA,KAAI;AAAA,IAC1B;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAOA,UAAS,KAAK,gBAAgB;AAAA,EACvC;AAcA,WAAS,cAAcA,OAAM;AAC3B,QAAIA,UAAS,MAAMA,UAAS,KAAK;AAC/B,cAAQ,QAAQA,KAAI;AACpB,aAAO;AAAA,IACT;AACA,WAAO,YAAYA,KAAI;AAAA,EACzB;AACF;AAIA,SAAS,aAAa,QAAQ,SAAS;AACrC,MAAIC,SAAQ;AACZ,MAAI,0BAA0B;AAE9B,MAAI,UAAU;AAEd,MAAI,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AAE1B,MAAI,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;AACtB,MAAI,gCAAgC;AACpC,MAAI,eAAe;AAEnB,MAAI;AAEJ,MAAI;AAEJ,MAAI;AACJ,QAAMC,OAAM,IAAI,QAAQ;AACxB,SAAO,EAAED,SAAQ,OAAO,QAAQ;AAC9B,UAAM,QAAQ,OAAOA,MAAK;AAC1B,UAAM,QAAQ,MAAM,CAAC;AACrB,QAAI,MAAM,CAAC,MAAM,SAAS;AAExB,UAAI,MAAM,SAAS,aAAa;AAC9B,wCAAgC;AAGhC,YAAI,iBAAiB,GAAG;AACtB,wBAAcC,MAAK,SAAS,cAAc,cAAc,WAAW;AACnE,wBAAc;AACd,yBAAe;AAAA,QACjB;AAGA,uBAAe;AAAA,UACb,MAAM;AAAA,UACN,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK;AAAA;AAAA,UAEpC,KAAK,OAAO,OAAO,CAAC,GAAG,MAAM,GAAG;AAAA,QAClC;AACA,QAAAA,KAAI,IAAID,QAAO,GAAG,CAAC,CAAC,SAAS,cAAc,OAAO,CAAC,CAAC;AAAA,MACtD,WACE,MAAM,SAAS,cACf,MAAM,SAAS,qBACf;AACA,kCAA0B;AAC1B,sBAAc;AACd,mBAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AACtB,eAAO,CAAC,GAAGA,SAAQ,GAAG,GAAG,CAAC;AAG1B,YAAI,+BAA+B;AACjC,0CAAgC;AAChC,wBAAc;AAAA,YACZ,MAAM;AAAA,YACN,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK;AAAA;AAAA,YAEpC,KAAK,OAAO,OAAO,CAAC,GAAG,MAAM,GAAG;AAAA,UAClC;AACA,UAAAC,KAAI,IAAID,QAAO,GAAG,CAAC,CAAC,SAAS,aAAa,OAAO,CAAC,CAAC;AAAA,QACrD;AACA,kBAAU,MAAM,SAAS,sBAAsB,IAAI,cAAc,IAAI;AAAA,MACvE,WAGE,YACC,MAAM,SAAS,UACd,MAAM,SAAS,0BACf,MAAM,SAAS,yBACjB;AACA,kCAA0B;AAG1B,YAAI,KAAK,CAAC,MAAM,GAAG;AACjB,cAAI,SAAS,CAAC,MAAM,GAAG;AACrB,iBAAK,CAAC,IAAI,KAAK,CAAC;AAChB,0BAAc;AAAA,cACZC;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,uBAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA,UACxB;AACA,eAAK,CAAC,IAAID;AAAA,QACZ;AAAA,MACF,WAAW,MAAM,SAAS,oBAAoB;AAC5C,YAAI,yBAAyB;AAC3B,oCAA0B;AAAA,QAC5B,OAAO;AACL,cAAI,SAAS,CAAC,MAAM,GAAG;AACrB,iBAAK,CAAC,IAAI,KAAK,CAAC;AAChB,0BAAc;AAAA,cACZC;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAAA,UACF;AACA,qBAAW;AACX,iBAAO,CAAC,SAAS,CAAC,GAAGD,QAAO,GAAG,CAAC;AAAA,QAClC;AAAA,MACF;AAAA,IACF,WAES,MAAM,SAAS,aAAa;AACnC,sCAAgC;AAChC,qBAAeA;AAAA,IACjB,WACE,MAAM,SAAS,cACf,MAAM,SAAS,qBACf;AACA,qBAAeA;AACf,UAAI,SAAS,CAAC,MAAM,GAAG;AACrB,aAAK,CAAC,IAAI,KAAK,CAAC;AAChB,sBAAc;AAAA,UACZC;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACAD;AAAA,UACA;AAAA,QACF;AAAA,MACF,WAAW,KAAK,CAAC,MAAM,GAAG;AACxB,sBAAc,UAAUC,MAAK,SAAS,MAAM,SAASD,QAAO,WAAW;AAAA,MACzE;AACA,gBAAU;AAAA,IACZ,WACE,YACC,MAAM,SAAS,UACd,MAAM,SAAS,0BACf,MAAM,SAAS,yBACjB;AACA,WAAK,CAAC,IAAIA;AAAA,IACZ;AAAA,EACF;AACA,MAAI,iBAAiB,GAAG;AACtB,kBAAcC,MAAK,SAAS,cAAc,cAAc,WAAW;AAAA,EACrE;AACA,EAAAA,KAAI,QAAQ,QAAQ,MAAM;AAK1B,EAAAD,SAAQ;AACR,SAAO,EAAEA,SAAQ,QAAQ,OAAO,QAAQ;AACtC,UAAM,QAAQ,QAAQ,OAAOA,MAAK;AAClC,QAAI,MAAM,CAAC,MAAM,WAAW,MAAM,CAAC,EAAE,SAAS,SAAS;AACrD,YAAM,CAAC,EAAE,SAAS,cAAc,QAAQ,QAAQA,MAAK;AAAA,IACvD;AAAA,EACF;AACA,SAAO;AACT;AAcA,SAAS,UAAUC,MAAK,SAAS,OAAO,SAAS,QAAQ,cAAc;AAGrE,QAAM,YACJ,YAAY,IACR,gBACA,YAAY,IACZ,mBACA;AAGN,QAAM,YAAY;AASlB,MAAI,MAAM,CAAC,MAAM,GAAG;AAClB,iBAAa,MAAM,OAAO,OAAO,CAAC,GAAG,SAAS,QAAQ,QAAQ,MAAM,CAAC,CAAC,CAAC;AACvE,IAAAA,KAAI,IAAI,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,QAAQ,cAAc,OAAO,CAAC,CAAC;AAAA,EACxD;AASA,QAAM,MAAM,SAAS,QAAQ,QAAQ,MAAM,CAAC,CAAC;AAC7C,iBAAe;AAAA,IACb,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAC,GAAG,GAAG;AAAA;AAAA,IAE5B,KAAK,OAAO,OAAO,CAAC,GAAG,GAAG;AAAA,EAC5B;AACA,EAAAA,KAAI,IAAI,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,SAAS,cAAc,OAAO,CAAC,CAAC;AAWvD,MAAI,MAAM,CAAC,MAAM,GAAG;AAClB,UAAM,eAAe,SAAS,QAAQ,QAAQ,MAAM,CAAC,CAAC;AACtD,UAAM,aAAa,SAAS,QAAQ,QAAQ,MAAM,CAAC,CAAC;AAEpD,UAAM,aAAa;AAAA,MACjB,MAAM;AAAA,MACN,OAAO,OAAO,OAAO,CAAC,GAAG,YAAY;AAAA,MACrC,KAAK,OAAO,OAAO,CAAC,GAAG,UAAU;AAAA,IACnC;AACA,IAAAA,KAAI,IAAI,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,SAAS,YAAY,OAAO,CAAC,CAAC;AACrD,QAAI,YAAY,GAAG;AAEjB,YAAM,QAAQ,QAAQ,OAAO,MAAM,CAAC,CAAC;AACrC,YAAM,MAAM,QAAQ,OAAO,MAAM,CAAC,CAAC;AACnC,YAAM,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG;AAC3C,YAAM,CAAC,EAAE,OAAO;AAChB,YAAM,CAAC,EAAE,cAAc;AAGvB,UAAI,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI,GAAG;AAC3B,cAAM,IAAI,MAAM,CAAC,IAAI;AACrB,cAAM,IAAI,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI;AAChC,QAAAA,KAAI,IAAI,GAAG,GAAG,CAAC,CAAC;AAAA,MAClB;AAAA,IACF;AACA,IAAAA,KAAI,IAAI,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,QAAQ,YAAY,OAAO,CAAC,CAAC;AAAA,EAC1D;AASA,MAAI,WAAW,QAAW;AACxB,iBAAa,MAAM,OAAO,OAAO,CAAC,GAAG,SAAS,QAAQ,QAAQ,MAAM,CAAC;AACrE,IAAAA,KAAI,IAAI,QAAQ,GAAG,CAAC,CAAC,QAAQ,cAAc,OAAO,CAAC,CAAC;AACpD,mBAAe;AAAA,EACjB;AACA,SAAO;AACT;AAYA,SAAS,cAAcA,MAAK,SAASD,QAAO,OAAO,WAAW;AAE5D,QAAM,QAAQ,CAAC;AACf,QAAM,UAAU,SAAS,QAAQ,QAAQA,MAAK;AAC9C,MAAI,WAAW;AACb,cAAU,MAAM,OAAO,OAAO,CAAC,GAAG,OAAO;AACzC,UAAM,KAAK,CAAC,QAAQ,WAAW,OAAO,CAAC;AAAA,EACzC;AACA,QAAM,MAAM,OAAO,OAAO,CAAC,GAAG,OAAO;AACrC,QAAM,KAAK,CAAC,QAAQ,OAAO,OAAO,CAAC;AACnC,EAAAC,KAAI,IAAID,SAAQ,GAAG,GAAG,KAAK;AAC7B;AAOA,SAAS,SAAS,QAAQA,QAAO;AAC/B,QAAM,QAAQ,OAAOA,MAAK;AAC1B,QAAM,OAAO,MAAM,CAAC,MAAM,UAAU,UAAU;AAC9C,SAAO,MAAM,CAAC,EAAE,IAAI;AACtB;;;AGj3BA;;;ACAA;AAaA,IAAM,gBAAgB;AAAA,EACpB,UAAU;AACZ;AAUO,IAAM,kBAAkB;AAAA,EAC7B,MAAM;AAAA,IACJ,CAAC,EAAE,GAAG;AAAA,EACR;AACF;AAMA,SAAS,sBAAsB,SAASE,KAAI,KAAK;AAC/C,QAAM,OAAO;AACb,SAAO;AAYP,WAAS,KAAKC,OAAM;AAClB;AAAA;AAAA,MAEE,KAAK,aAAa;AAAA;AAAA,MAGlB,CAAC,KAAK;AAAA,MACN;AACA,aAAO,IAAIA,KAAI;AAAA,IACjB;AACA,YAAQ,MAAM,eAAe;AAC7B,YAAQ,MAAM,qBAAqB;AACnC,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,qBAAqB;AAClC,WAAO;AAAA,EACT;AAYA,WAAS,OAAOA,OAAM;AAIpB,QAAI,0BAA0BA,KAAI,GAAG;AACnC,cAAQ,MAAM,6BAA6B;AAC3C,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,6BAA6B;AAC1C,aAAO;AAAA,IACT;AACA,QAAIA,UAAS,MAAMA,UAAS,KAAK;AAC/B,cAAQ,MAAM,2BAA2B;AACzC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,2BAA2B;AACxC,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAYA,WAAS,MAAMA,OAAM;AACnB,QAAIA,UAAS,IAAI;AACf,cAAQ,MAAM,qBAAqB;AACnC,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,qBAAqB;AAClC,cAAQ,KAAK,eAAe;AAC5B,aAAO;AAAA,IACT;AACA,WAAO,IAAIA,KAAI;AAAA,EACjB;AAKA,WAAS,MAAMA,OAAM;AAEnB,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,aAAOD,IAAGC,KAAI;AAAA,IAChB;AAIA,QAAI,cAAcA,KAAI,GAAG;AACvB,aAAO,QAAQ;AAAA,QACb;AAAA,UACE,UAAU;AAAA,QACZ;AAAA,QACAD;AAAA,QACA;AAAA,MACF,EAAEC,KAAI;AAAA,IACR;AAGA,WAAO,IAAIA,KAAI;AAAA,EACjB;AACF;AAMA,SAAS,kBAAkB,SAASD,KAAI,KAAK;AAC3C,SAAO,aAAa,SAAS,OAAO,YAAY;AAYhD,WAAS,MAAMC,OAAM;AAKnB,WAAOA,UAAS,OAAO,IAAIA,KAAI,IAAID,IAAGC,KAAI;AAAA,EAC5C;AACF;;;AlDhIO,SAAS,IAAI,SAAS;AAC3B,SAAO,kBAAkB;AAAA,IACvB;AAAA,IACA,YAAY;AAAA,IACZ,iBAAiB,OAAO;AAAA,IACxB;AAAA,IACA;AAAA,EACF,CAAC;AACH;;;AmD9CA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAUO,SAAS,OAAO,OAAO,WAAW;AACvC,QAAM,SAAS,OAAO,KAAK;AAE3B,MAAI,OAAO,cAAc,UAAU;AACjC,UAAM,IAAI,UAAU,oBAAoB;AAAA,EAC1C;AAEA,MAAI,QAAQ;AACZ,MAAIC,SAAQ,OAAO,QAAQ,SAAS;AAEpC,SAAOA,WAAU,IAAI;AACnB;AACA,IAAAA,SAAQ,OAAO,QAAQ,WAAWA,SAAQ,UAAU,MAAM;AAAA,EAC5D;AAEA,SAAO;AACT;;;AC1BA;;;ACAA;;;ACAA;AAAe,SAAR,mBAAoCC,SAAQ;AAClD,MAAI,OAAOA,YAAW,UAAU;AAC/B,UAAM,IAAI,UAAU,mBAAmB;AAAA,EACxC;AAIA,SAAOA,QACL,QAAQ,uBAAuB,MAAM,EACrC,QAAQ,MAAM,OAAO;AACxB;;;ACVA;;;ACAA;;;ACAA;;;ACAA;AAqKO,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYT,SAAU,MAAM;AACd,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,YAAY,IAAI;AAAA,IACzB;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,aAAO,MAAM,QAAQ,IAAI,IAAI,WAAW,IAAI,IAAI,aAAa,IAAI;AAAA,IACnE;AAEA,QAAI,OAAO,SAAS,YAAY;AAC9B,aAAO,YAAY,IAAI;AAAA,IACzB;AAEA,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAChE;AAAA;AAOJ,SAAS,WAAW,OAAO;AAEzB,QAAM,SAAS,CAAC;AAChB,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQ,MAAM,QAAQ;AAC7B,WAAOA,MAAK,IAAI,QAAQ,MAAMA,MAAK,CAAC;AAAA,EACtC;AAEA,SAAO,YAAY,GAAG;AAOtB,WAAS,OAAO,YAAY;AAC1B,QAAIA,SAAQ;AAEZ,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,UAAI,OAAOA,MAAK,EAAE,KAAK,MAAM,GAAG,UAAU;AAAG,eAAO;AAAA,IACtD;AAEA,WAAO;AAAA,EACT;AACF;AAQA,SAAS,aAAa,OAAO;AAC3B,SAAO,YAAYC,IAAG;AAMtB,WAASA,KAAIC,OAAM;AAEjB,QAAIC;AAEJ,SAAKA,QAAO,OAAO;AAEjB,UAAID,MAAKC,IAAG,MAAM,MAAMA,IAAG;AAAG,eAAO;AAAA,IACvC;AAEA,WAAO;AAAA,EACT;AACF;AAQA,SAAS,YAAY,OAAO;AAC1B,SAAO,YAAY,IAAI;AAKvB,WAAS,KAAKD,OAAM;AAClB,WAAOA,SAAQA,MAAK,SAAS;AAAA,EAC/B;AACF;AAQA,SAAS,YAAY,OAAO;AAC1B,SAAO;AAQP,WAAS,UAAUA,UAAS,YAAY;AACtC,WAAO;AAAA,MACLA,SACE,OAAOA,UAAS,YAChB,UAAUA;AAAA,MAEV,QAAQ,MAAM,KAAK,MAAMA,OAAM,GAAG,UAAU,CAAC;AAAA,IACjD;AAAA,EACF;AACF;AAEA,SAAS,KAAK;AACZ,SAAO;AACT;;;AC5SA;AAIO,SAAS,MAAM,GAAG;AACvB,SAAO;AACT;;;AH0EO,IAAM,WAAW;AAKjB,IAAM,OAAO;AAKb,IAAM,OAAO;AA+Bb,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeT,SAAU,MAAM,MAAM,SAAS,SAAS;AACtC,QAAI,OAAO,SAAS,cAAc,OAAO,YAAY,YAAY;AAC/D,gBAAU;AAEV,gBAAU;AACV,aAAO;AAAA,IACT;AAEA,UAAME,MAAK,QAAQ,IAAI;AACvB,UAAM,OAAO,UAAU,KAAK;AAE5B,YAAQ,MAAM,QAAW,CAAC,CAAC,EAAE;AAO7B,aAAS,QAAQC,OAAMC,QAAO,SAAS;AAGrC,YAAM,QAAQD,SAAQ,OAAOA,UAAS,WAAWA,QAAO,CAAC;AAEzD,UAAI,OAAO,MAAM,SAAS,UAAU;AAClC,cAAM;AAAA;AAAA,UAEJ,OAAO,MAAM,YAAY,WACrB,MAAM;AAAA;AAAA,YAER,OAAO,MAAM,SAAS,WACpB,MAAM,OACN;AAAA;AAAA;AAEN,eAAO,eAAeE,QAAO,QAAQ;AAAA,UACnC,OACE,WAAW,MAAMF,MAAK,QAAQ,OAAO,MAAM,OAAO,MAAM,GAAG,IAAI;AAAA,QACnE,CAAC;AAAA,MACH;AAEA,aAAOE;AAEP,eAASA,SAAQ;AAEf,YAAI,SAAS,CAAC;AAEd,YAAI;AAEJ,YAAI;AAEJ,YAAI;AAEJ,YAAI,CAAC,QAAQH,IAAGC,OAAMC,QAAO,QAAQ,QAAQ,SAAS,CAAC,KAAK,IAAI,GAAG;AACjE,mBAAS,SAAS,QAAQD,OAAM,OAAO,CAAC;AAExC,cAAI,OAAO,CAAC,MAAM,MAAM;AACtB,mBAAO;AAAA,UACT;AAAA,QACF;AAGA,YAAIA,MAAK,YAAY,OAAO,CAAC,MAAM,MAAM;AAEvC,oBAAU,UAAUA,MAAK,SAAS,SAAS,MAAM;AAEjD,yBAAe,QAAQ,OAAOA,KAAI;AAGlC,iBAAO,SAAS,MAAM,SAASA,MAAK,SAAS,QAAQ;AAEnD,wBAAY,QAAQA,MAAK,SAAS,MAAM,GAAG,QAAQ,YAAY,EAAE;AAEjE,gBAAI,UAAU,CAAC,MAAM,MAAM;AACzB,qBAAO;AAAA,YACT;AAEA,qBACE,OAAO,UAAU,CAAC,MAAM,WAAW,UAAU,CAAC,IAAI,SAAS;AAAA,UAC/D;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA;AAWJ,SAAS,SAAS,OAAO;AACvB,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO,CAAC,UAAU,KAAK;AAAA,EACzB;AAEA,SAAO,CAAC,KAAK;AACf;;;AH5KA,IAAM,MAAM,CAAC,EAAE;AAqBR,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBT,SAAU,MAAM,MAAMG,UAAS,SAAS;AAEtC,QAAI;AAEJ,QAAI;AAEJ,QAAI,OAAO,SAAS,YAAY,gBAAgB,QAAQ;AAEtD,eAAS,CAAC,CAAC,MAAMA,QAAO,CAAC;AACzB,iBAAW;AAAA,IACb,OAAO;AACL,eAAS;AAET,iBAAWA;AAAA,IACb;AAEA,QAAI,CAAC,UAAU;AACb,iBAAW,CAAC;AAAA,IACd;AAEA,UAAM,UAAU,QAAQ,SAAS,UAAU,CAAC,CAAC;AAC7C,UAAM,QAAQ,QAAQ,MAAM;AAC5B,QAAI,YAAY;AAEhB,WAAO,EAAE,YAAY,MAAM,QAAQ;AACjC,mBAAa,MAAM,QAAQ,OAAO;AAAA,IACpC;AAGA,WAAO;AAGP,aAAS,QAAQC,OAAM,SAAS;AAC9B,UAAIC,SAAQ;AAEZ,UAAI;AAEJ,aAAO,EAAEA,SAAQ,QAAQ,QAAQ;AAC/B,cAAM,SAAS,QAAQA,MAAK;AAE5B,YACE;AAAA,UACE;AAAA;AAAA,UAEA,cAAc,YAAY,SAAS,QAAQ,MAAM,IAAI;AAAA,UACrD;AAAA,QACF,GACA;AACA;AAAA,QACF;AAEA,sBAAc;AAAA,MAChB;AAEA,UAAI,aAAa;AACf,eAAO,QAAQD,OAAM,OAAO;AAAA,MAC9B;AAAA,IACF;AAYA,aAAS,QAAQA,OAAM,SAAS;AAC9B,YAAM,SAAS,QAAQ,QAAQ,SAAS,CAAC;AACzC,YAAME,QAAO,MAAM,SAAS,EAAE,CAAC;AAC/B,YAAMH,WAAU,MAAM,SAAS,EAAE,CAAC;AAClC,UAAI,QAAQ;AAEZ,YAAME,SAAQ,OAAO,SAAS,QAAQD,KAAI;AAC1C,UAAI,SAAS;AAEb,UAAI,QAAQ,CAAC;AAEb,MAAAE,MAAK,YAAY;AAEjB,UAAI,QAAQA,MAAK,KAAKF,MAAK,KAAK;AAEhC,aAAO,OAAO;AACZ,cAAMG,YAAW,MAAM;AAEvB,cAAM,cAAc;AAAA,UAClB,OAAO,MAAM;AAAA,UACb,OAAO,MAAM;AAAA;AAAA,UAEb,OAAO,CAAC,GAAG,SAASH,KAAI;AAAA,QAC1B;AACA,YAAI,QAAQD,SAAQ,GAAG,OAAO,WAAW;AAEzC,YAAI,OAAO,UAAU,UAAU;AAC7B,kBAAQ,MAAM,SAAS,IAAI,EAAC,MAAM,QAAQ,MAAK,IAAI;AAAA,QACrD;AAGA,YAAI,UAAU,OAAO;AACnB,cAAI,UAAUI,WAAU;AACtB,kBAAM,KAAK;AAAA,cACT,MAAM;AAAA,cACN,OAAOH,MAAK,MAAM,MAAM,OAAOG,SAAQ;AAAA,YACzC,CAAC;AAAA,UACH;AAEA,cAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,kBAAM,KAAK,GAAG,KAAK;AAAA,UACrB,WAAW,OAAO;AAChB,kBAAM,KAAK,KAAK;AAAA,UAClB;AAEA,kBAAQA,YAAW,MAAM,CAAC,EAAE;AAC5B,mBAAS;AAAA,QACX;AAEA,YAAI,CAACD,MAAK,QAAQ;AAChB;AAAA,QACF;AAEA,gBAAQA,MAAK,KAAKF,MAAK,KAAK;AAAA,MAC9B;AAEA,UAAI,QAAQ;AACV,YAAI,QAAQA,MAAK,MAAM,QAAQ;AAC7B,gBAAM,KAAK,EAAC,MAAM,QAAQ,OAAOA,MAAK,MAAM,MAAM,KAAK,EAAC,CAAC;AAAA,QAC3D;AAEA,eAAO,SAAS,OAAOC,QAAO,GAAG,GAAG,KAAK;AAAA,MAC3C,OAAO;AACL,gBAAQ,CAACD,KAAI;AAAA,MACf;AAEA,aAAOC,SAAQ,MAAM;AAAA,IACvB;AAAA,EACF;AAAA;AAWJ,SAAS,QAAQ,QAAQ;AAEvB,QAAM,SAAS,CAAC;AAEhB,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,UAAU,oCAAoC;AAAA,EAC1D;AAEA,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,QAAIA,SAAQ;AAEZ,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,aAAO,KAAK;AAAA,QACV,aAAa,OAAOA,MAAK,EAAE,CAAC,CAAC;AAAA,QAC7B,WAAW,OAAOA,MAAK,EAAE,CAAC,CAAC;AAAA,MAC7B,CAAC;AAAA,IACH;AAAA,EACF,OAAO;AAEL,QAAIG;AAEJ,SAAKA,QAAO,QAAQ;AAClB,UAAI,IAAI,KAAK,QAAQA,IAAG,GAAG;AACzB,eAAO,KAAK,CAAC,aAAaA,IAAG,GAAG,WAAW,OAAOA,IAAG,CAAC,CAAC,CAAC;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAUA,SAAS,aAAa,MAAM;AAC1B,SAAO,OAAO,SAAS,WAAW,IAAI,OAAO,mBAAO,IAAI,GAAG,GAAG,IAAI;AACpE;AAUA,SAAS,WAAWL,UAAS;AAC3B,SAAO,OAAOA,aAAY,aAAaA,WAAU,MAAMA;AACzD;;;AH7RA,IAAM,cAAc;AAEpB,IAAM,iBAAiB,CAAC,YAAY,QAAQ,SAAS,OAAO;AASrD,IAAM,iCAAiC;AAAA,EAC5C,YAAY,CAAC,4BAA4B;AAAA,EACzC,OAAO;AAAA,IACL,iBAAiB;AAAA,IACjB,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,oBAAoB;AAAA,EACtB;AAAA,EACA,MAAM;AAAA,IACJ,iBAAiB;AAAA,IACjB,sBAAsB;AAAA,IACtB,qBAAqB;AAAA,IACrB,oBAAoB;AAAA,EACtB;AACF;AAOO,IAAM,+BAA+B;AAAA,EAC1C,QAAQ;AAAA,IACN;AAAA,MACE,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,MACE,WAAW;AAAA,MACX,QAAQ;AAAA,MACR,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,IACA,EAAC,WAAW,KAAK,QAAQ,QAAQ,OAAO,OAAO,aAAa,eAAc;AAAA,EAC5E;AACF;AAMA,SAAS,qBAAqB,OAAO;AACnC,OAAK,MAAM,EAAC,MAAM,QAAQ,OAAO,MAAM,KAAK,IAAI,UAAU,CAAC,EAAC,GAAG,KAAK;AACtE;AAMA,SAAS,0BAA0B,OAAO;AACxC,OAAK,OAAO,MAAM,iBAAiB,KAAK,MAAM,KAAK;AACrD;AAMA,SAAS,wBAAwB,OAAO;AACtC,OAAK,OAAO,KAAK,iBAAiB,KAAK,MAAM,KAAK;AACpD;AAMA,SAAS,uBAAuB,OAAO;AACrC,OAAK,OAAO,KAAK,KAAK,KAAK,MAAM,KAAK;AACtC,QAAMM;AAAA;AAAA,IAA4B,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AAClE,EAAAA,MAAK,MAAM,YAAY,KAAK,eAAe,KAAK;AAClD;AAMA,SAAS,yBAAyB,OAAO;AACvC,OAAK,OAAO,KAAK,cAAc,KAAK,MAAM,KAAK;AACjD;AAMA,SAAS,oBAAoB,OAAO;AAClC,OAAK,KAAK,KAAK;AACjB;AAGA,SAAS,6BAA6B,MAAM;AAC1C;AAAA,IACE;AAAA,IACA;AAAA,MACE,CAAC,mDAAmD,OAAO;AAAA,MAC3D,CAAC,qCAAqC,SAAS;AAAA,IACjD;AAAA,IACA,EAAC,QAAQ,CAAC,QAAQ,eAAe,EAAC;AAAA,EACpC;AACF;AAYA,SAAS,QAAQ,GAAG,UAAUC,SAAQC,OAAM,OAAO;AACjD,MAAI,SAAS;AAGb,MAAI,CAACC,UAAS,KAAK,GAAG;AACpB,WAAO;AAAA,EACT;AAGA,MAAI,MAAM,KAAK,QAAQ,GAAG;AACxB,IAAAF,UAAS,WAAWA;AACpB,eAAW;AACX,aAAS;AAAA,EACX;AAEA,MAAI,CAAC,gBAAgBA,OAAM,GAAG;AAC5B,WAAO;AAAA,EACT;AAEA,QAAM,QAAQ,SAASA,UAASC,KAAI;AAEpC,MAAI,CAAC,MAAM,CAAC;AAAG,WAAO;AAGtB,QAAM,SAAS;AAAA,IACb,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK,SAAS,WAAW,MAAM,CAAC;AAAA,IAChC,UAAU,CAAC,EAAC,MAAM,QAAQ,OAAO,WAAW,MAAM,CAAC,EAAC,CAAC;AAAA,EACvD;AAEA,MAAI,MAAM,CAAC,GAAG;AACZ,WAAO,CAAC,QAAQ,EAAC,MAAM,QAAQ,OAAO,MAAM,CAAC,EAAC,CAAC;AAAA,EACjD;AAEA,SAAO;AACT;AAUA,SAAS,UAAU,GAAG,OAAO,OAAO,OAAO;AACzC;AAAA;AAAA,IAEE,CAACC,UAAS,OAAO,IAAI;AAAA,IAErB,UAAU,KAAK,KAAK;AAAA,IACpB;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,KAAK,YAAY,QAAQ,MAAM;AAAA,IAC/B,UAAU,CAAC,EAAC,MAAM,QAAQ,OAAO,QAAQ,MAAM,MAAK,CAAC;AAAA,EACvD;AACF;AAMA,SAAS,gBAAgBF,SAAQ;AAC/B,QAAM,QAAQA,QAAO,MAAM,GAAG;AAE9B,MACE,MAAM,SAAS,KACd,MAAM,MAAM,SAAS,CAAC,MACpB,IAAI,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,KAC/B,CAAC,aAAa,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,MAC7C,MAAM,MAAM,SAAS,CAAC,MACpB,IAAI,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,KAC/B,CAAC,aAAa,KAAK,MAAM,MAAM,SAAS,CAAC,CAAC,IAC9C;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAMA,SAAS,SAAS,KAAK;AACrB,QAAM,YAAY,sBAAsB,KAAK,GAAG;AAEhD,MAAI,CAAC,WAAW;AACd,WAAO,CAAC,KAAK,MAAS;AAAA,EACxB;AAEA,QAAM,IAAI,MAAM,GAAG,UAAU,KAAK;AAElC,MAAIG,SAAQ,UAAU,CAAC;AACvB,MAAI,oBAAoBA,OAAM,QAAQ,GAAG;AACzC,QAAM,gBAAgB,OAAO,KAAK,GAAG;AACrC,MAAI,gBAAgB,OAAO,KAAK,GAAG;AAEnC,SAAO,sBAAsB,MAAM,gBAAgB,eAAe;AAChE,WAAOA,OAAM,MAAM,GAAG,oBAAoB,CAAC;AAC3C,IAAAA,SAAQA,OAAM,MAAM,oBAAoB,CAAC;AACzC,wBAAoBA,OAAM,QAAQ,GAAG;AACrC;AAAA,EACF;AAEA,SAAO,CAAC,KAAKA,MAAK;AACpB;AAOA,SAASD,UAAS,OAAO,OAAO;AAC9B,QAAME,QAAO,MAAM,MAAM,WAAW,MAAM,QAAQ,CAAC;AAEnD,UACG,MAAM,UAAU,KACf,kBAAkBA,KAAI,KACtB,mBAAmBA,KAAI,OACxB,CAAC,SAASA,UAAS;AAExB;;;AUjRA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAcO,SAAS,gCAAgC,OAAOC,OAAM;AAC3D,QAAMC,QAAO,OAAO,SAAS,OAAOD,KAAI;AACxC;AAAA;AAAA,IAEEC,QAAO,KACPA,UAAS,MACRA,QAAO,MAAMA,QAAO;AAAA,IAEpBA,QAAO,OAAOA,QAAO;AAAA,IAErBA,QAAO,SAASA,QAAO;AAAA,IAEvBA,QAAO,SAASA,QAAO,UACvBA,QAAO,WAAW,UAClBA,QAAO,WAAW;AAAA,IAEnBA,QAAO;AAAA,IACP;AACA,WAAO;AAAA,EACT;AACA,SAAO,OAAO,aAAaA,KAAI;AACjC;;;ADjCA,IAAM,6BACJ;AAcK,SAAS,aAAa,OAAO;AAClC,SAAO,MAAM,QAAQ,4BAA4B,MAAM;AACzD;AAQA,SAAS,OAAO,IAAI,IAAI,IAAI;AAC1B,MAAI,IAAI;AAEN,WAAO;AAAA,EACT;AAGA,QAAM,OAAO,GAAG,WAAW,CAAC;AAC5B,MAAI,SAAS,IAAI;AACf,UAAMC,QAAO,GAAG,WAAW,CAAC;AAC5B,UAAM,MAAMA,UAAS,OAAOA,UAAS;AACrC,WAAO,gCAAgC,GAAG,MAAM,MAAM,IAAI,CAAC,GAAG,MAAM,KAAK,EAAE;AAAA,EAC7E;AACA,SAAO,8BAA8B,EAAE,KAAK;AAC9C;;;ADfO,SAAS,YAAYC,OAAM;AAChC,MAAIA,MAAK,SAAS,CAACA,MAAK,YAAY;AAClC,WAAOA,MAAK,SAAS;AAAA,EACvB;AAEA,SAAO,aAAaA,MAAK,UAAU;AACrC;;;AGhCA;AAkBO,SAAS,cAAc,QAAQ,OAAO,MAAM;AACjD,QAAM,aAAa,MAAM;AACzB,QAAM,WAAW,OAAO,YAAY,CAAC;AACrC,QAAM,UAAU,MAAM,cAAc,IAAI;AAExC,QAAM,UAAU,CAAC;AACjB,MAAIC,SAAQ;AAEZ,aAAW,KAAK,EAAE;AAElB,SAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,UAAM,QAAQ,SAASA,MAAK;AAE5B,eAAW,WAAW,SAAS,CAAC,IAAIA;AAEpC,YAAQ;AAAA,MACN,QAAQ;AAAA,QACN,MAAM,OAAO,OAAO,QAAQ,OAAO;AAAA,UACjC,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,GAAG,QAAQ,QAAQ;AAAA,QACrB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,MAAM,SAAS,QAAQ;AACzB,YAAM,iBAAiB;AAAA,IACzB;AAEA,QAAIA,SAAQ,SAAS,SAAS,GAAG;AAC/B,cAAQ;AAAA,QACN,QAAQ,KAAK,QAAQ,OAAO,SAASA,SAAQ,CAAC,GAAG,QAAQ,KAAK,CAAC;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAEA,aAAW,IAAI;AAEf,SAAO,QAAQ,KAAK,EAAE;AACxB;AASA,SAAS,QAAQ,MAAM,OAAO,QAAQ,OAAO;AAC3C,MAAIA,SAAQ,MAAM,KAAK;AAEvB,SAAOA,UAAS;AACd,UAAM,SAAS,MAAM,KAAKA,MAAK,EAAE,MAAM,OAAO,QAAQ,KAAK;AAE3D,QAAI,WAAW,QAAQ,WAAW,GAAG;AACnC;AAAA,IACF;AAEA,QAAI,OAAO,WAAW,UAAU;AAC9B,aAAO,KAAK,OAAO,IAAI,MAAM;AAAA,IAC/B;AAEA,QAAI,WAAW,OAAO;AACpB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;ACtFA;AAIA,IAAM,MAAM;AAKL,SAAS,YAAY,OAAOC,MAAK;AAEtC,QAAM,SAAS,CAAC;AAChB,MAAI,QAAQ;AACZ,MAAI,OAAO;AAEX,MAAI;AAEJ,SAAQ,QAAQ,IAAI,KAAK,KAAK,GAAI;AAChC,IAAAC,KAAI,MAAM,MAAM,OAAO,MAAM,KAAK,CAAC;AACnC,WAAO,KAAK,MAAM,CAAC,CAAC;AACpB,YAAQ,MAAM,QAAQ,MAAM,CAAC,EAAE;AAC/B;AAAA,EACF;AAEA,EAAAA,KAAI,MAAM,MAAM,KAAK,CAAC;AAEtB,SAAO,OAAO,KAAK,EAAE;AAKrB,WAASA,KAAIC,QAAO;AAClB,WAAO,KAAKF,KAAIE,QAAO,MAAM,CAACA,MAAK,CAAC;AAAA,EACtC;AACF;;;AClCA;;;ACAA;AAQO,SAAS,eAAe,SAAS;AACtC,MAAI,CAAC,QAAQ,WAAW;AACtB,UAAM,UACH,QAAQ,UAAU,oBAAoB,OACtC,QAAQ,SAAS,QAAQ,QAAQ,SAAS,MAAM;AAEnD,YAAQ,YAAY,IAAI;AAAA,OACrB,SAAS,MAAM,SAAS,MAAM,OAC5B,sBAAsB,KAAK,QAAQ,SAAS,IAAI,OAAO,MACxD,QAAQ,aACP,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,MAAM;AAAA,MACjD;AAAA,IACF;AAAA,EACF;AAEA,SAAO,QAAQ;AACjB;;;ACxBA;AAUO,SAAS,eAAe,OAAO,SAAS;AAC7C,SACE,YAAY,OAAO,QAAQ,aAAa,IAAI,KAC5C,CAAC,YAAY,OAAO,QAAQ,gBAAgB,KAAK;AAErD;AAQA,SAAS,YAAY,OAAOC,OAAM,MAAM;AACtC,MAAI,OAAOA,UAAS,UAAU;AAC5B,IAAAA,QAAO,CAACA,KAAI;AAAA,EACd;AAEA,MAAI,CAACA,SAAQA,MAAK,WAAW,GAAG;AAC9B,WAAO;AAAA,EACT;AAEA,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQD,MAAK,QAAQ;AAC5B,QAAI,MAAM,SAASA,MAAKC,MAAK,CAAC,GAAG;AAC/B,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;AFRO,SAAS,KAAK,OAAO,OAAO,QAAQ;AACzC,QAAM,SAAS,OAAO,UAAU,OAAO,SAAS,OAAO,OAAO,SAAS;AAEvE,QAAM,YAAY,CAAC;AAEnB,QAAM,SAAS,CAAC;AAEhB,QAAM,QAAQ,CAAC;AACf,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQ,MAAM,OAAO,QAAQ;AACpC,UAAM,UAAU,MAAM,OAAOA,MAAK;AAElC,QAAI,CAAC,eAAe,MAAM,OAAO,OAAO,GAAG;AACzC;AAAA,IACF;AAEA,UAAM,aAAa,eAAe,OAAO;AAEzC,QAAI;AAEJ,WAAQ,QAAQ,WAAW,KAAK,KAAK,GAAI;AACvC,YAAM,SAAS,YAAY,WAAW,QAAQ,QAAQ,OAAO;AAC7D,YAAM,QAAQ,WAAW;AACzB,YAAMC,YAAW,MAAM,SAAS,SAAS,MAAM,CAAC,EAAE,SAAS;AAE3D,UAAI,UAAU,SAASA,SAAQ,GAAG;AAChC,YAAI,MAAMA,SAAQ,EAAE,UAAU,CAAC,QAAQ;AACrC,gBAAMA,SAAQ,EAAE,SAAS;AAAA,QAC3B;AAEA,YAAI,MAAMA,SAAQ,EAAE,SAAS,CAAC,OAAO;AACnC,gBAAMA,SAAQ,EAAE,QAAQ;AAAA,QAC1B;AAAA,MACF,OAAO;AACL,kBAAU,KAAKA,SAAQ;AACvB,cAAMA,SAAQ,IAAI,EAAC,QAAQ,MAAK;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,YAAU,KAAK,SAAS;AAExB,MAAI,QAAQ,OAAO,SAAS,OAAO,OAAO,SAAS;AACnD,QAAM,MAAM,MAAM,UAAU,OAAO,QAAQ,OAAO,MAAM,SAAS;AACjE,EAAAD,SAAQ;AAER,SAAO,EAAEA,SAAQ,UAAU,QAAQ;AACjC,UAAMC,YAAW,UAAUD,MAAK;AAGhC,QAAIC,YAAW,SAASA,aAAY,KAAK;AACvC;AAAA,IACF;AAKA,QACGA,YAAW,IAAI,OACd,UAAUD,SAAQ,CAAC,MAAMC,YAAW,KACpC,MAAMA,SAAQ,EAAE,SAChB,CAAC,MAAMA,YAAW,CAAC,EAAE,UACrB,CAAC,MAAMA,YAAW,CAAC,EAAE,SACtB,UAAUD,SAAQ,CAAC,MAAMC,YAAW,KACnC,MAAMA,SAAQ,EAAE,UAChB,CAAC,MAAMA,YAAW,CAAC,EAAE,UACrB,CAAC,MAAMA,YAAW,CAAC,EAAE,OACvB;AACA;AAAA,IACF;AAEA,QAAI,UAAUA,WAAU;AAItB,aAAO,KAAK,kBAAkB,MAAM,MAAM,OAAOA,SAAQ,GAAG,IAAI,CAAC;AAAA,IACnE;AAEA,YAAQA;AAER,QACE,iBAAiB,KAAK,MAAM,OAAOA,SAAQ,CAAC,MAC3C,CAAC,OAAO,UAAU,CAAC,OAAO,OAAO,SAAS,MAAM,OAAOA,SAAQ,CAAC,IACjE;AAEA,aAAO,KAAK,IAAI;AAAA,IAClB,OAAO;AAEL,aAAO;AAAA,QACL,QAAQ,MAAM,WAAWA,SAAQ,EAAE,SAAS,EAAE,EAAE,YAAY,IAAI;AAAA,MAClE;AACA;AAAA,IACF;AAAA,EACF;AAEA,SAAO,KAAK,kBAAkB,MAAM,MAAM,OAAO,GAAG,GAAG,OAAO,KAAK,CAAC;AAEpE,SAAO,OAAO,KAAK,EAAE;AACvB;AAOA,SAAS,UAAU,GAAG,GAAG;AACvB,SAAO,IAAI;AACb;AAOA,SAAS,kBAAkB,OAAO,OAAO;AACvC,QAAM,aAAa;AAEnB,QAAM,YAAY,CAAC;AAEnB,QAAM,UAAU,CAAC;AACjB,QAAM,QAAQ,QAAQ;AACtB,MAAID,SAAQ;AACZ,MAAI,QAAQ;AAEZ,MAAI;AAEJ,SAAQ,QAAQ,WAAW,KAAK,KAAK,GAAI;AACvC,cAAU,KAAK,MAAM,KAAK;AAAA,EAC5B;AAEA,SAAO,EAAEA,SAAQ,UAAU,QAAQ;AACjC,QAAI,UAAU,UAAUA,MAAK,GAAG;AAC9B,cAAQ,KAAK,MAAM,MAAM,OAAO,UAAUA,MAAK,CAAC,CAAC;AAAA,IACnD;AAEA,YAAQ,KAAK,IAAI;AACjB,YAAQ,UAAUA,MAAK;AAAA,EACzB;AAEA,UAAQ,KAAK,MAAM,MAAM,KAAK,CAAC;AAE/B,SAAO,QAAQ,KAAK,EAAE;AACxB;;;AGhLA;AAYO,SAAS,MAAM,QAAQ;AAI5B,QAAM,UAAU,UAAU,CAAC;AAC3B,QAAM,MAAM,QAAQ,OAAO,CAAC;AAC5B,MAAI,YAAY,QAAQ,aAAa;AACrC,MAAI,OAAO,IAAI,QAAQ;AACvB,MAAI,SAAS,IAAI,UAAU;AAE3B,SAAO,EAAC,MAAM,SAAS,MAAK;AAO5B,WAAS,UAAU;AACjB,WAAO,EAAC,KAAK,EAAC,MAAM,OAAM,GAAG,UAAS;AAAA,EACxC;AAOA,WAAS,MAAM,OAAO;AACpB,iBAAa;AAAA,EACf;AAOA,WAAS,KAAK,OAAO;AAEnB,UAAM,QAAQ,SAAS;AACvB,UAAM,SAAS,MAAM,MAAM,WAAW;AACtC,UAAM,OAAO,OAAO,OAAO,SAAS,CAAC;AACrC,YAAQ,OAAO,SAAS;AACxB,aACE,OAAO,WAAW,IAAI,SAAS,KAAK,SAAS,IAAI,KAAK,SAAS;AACjE,WAAO;AAAA,EACT;AACF;;;ATvCA,kBAAkB,OAAO;AAYlB,SAAS,0BAA0B;AACxC,SAAO;AAAA,IACL,OAAO;AAAA,MACL,uBAAuB;AAAA,MACvB,kCAAkC;AAAA,MAClC,iBAAiB;AAAA,MACjB,uBAAuB;AAAA,IACzB;AAAA,IACA,MAAM;AAAA,MACJ,uBAAuB;AAAA,MACvB,kCAAkC;AAAA,MAClC,iBAAiB;AAAA,MACjB,uBAAuB;AAAA,IACzB;AAAA,EACF;AACF;AASO,SAAS,wBAAwB;AACtC,SAAO;AAAA;AAAA,IAEL,QAAQ,CAAC,EAAC,WAAW,KAAK,aAAa,CAAC,YAAY,SAAS,WAAW,EAAC,CAAC;AAAA,IAC1E,UAAU,EAAC,oBAAoB,kBAAiB;AAAA,EAClD;AACF;AAMA,SAAS,wBAAwB,OAAO;AACtC,OAAK;AAAA,IACH,EAAC,MAAM,sBAAsB,YAAY,IAAI,OAAO,IAAI,UAAU,CAAC,EAAC;AAAA,IACpE;AAAA,EACF;AACF;AAMA,SAAS,qCAAqC;AAC5C,OAAK,OAAO;AACd;AAMA,SAAS,kCAAkC,OAAO;AAChD,QAAM,QAAQ,KAAK,OAAO;AAC1B,QAAME;AAAA;AAAA,IACJ,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AAElC,EAAAA,MAAK,QAAQ;AACb,EAAAA,MAAK,aAAa;AAAA,IAChB,KAAK,eAAe,KAAK;AAAA,EAC3B,EAAE,YAAY;AAChB;AAMA,SAAS,uBAAuB,OAAO;AACrC,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,kBAAkB,OAAO;AAChC,OAAK,MAAM,EAAC,MAAM,qBAAqB,YAAY,IAAI,OAAO,GAAE,GAAG,KAAK;AAC1E;AAMA,SAAS,0BAA0B;AACjC,OAAK,OAAO;AACd;AAMA,SAAS,uBAAuB,OAAO;AACrC,QAAM,QAAQ,KAAK,OAAO;AAC1B,QAAMA;AAAA;AAAA,IACJ,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AAElC,EAAAA,MAAK,QAAQ;AACb,EAAAA,MAAK,aAAa;AAAA,IAChB,KAAK,eAAe,KAAK;AAAA,EAC3B,EAAE,YAAY;AAChB;AAMA,SAAS,iBAAiB,OAAO;AAC/B,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,kBAAkBA,OAAM,GAAG,SAAS,aAAa;AACxD,QAAM,UAAU,MAAM,WAAW;AACjC,MAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,QAAMC,QAAO,QAAQ,MAAM,mBAAmB;AAC9C,QAAM,UAAU,QAAQ,MAAM,WAAW;AACzC,WAAS,QAAQ;AAAA,IACf,KAAK,SAAS,YAAYD,KAAI,GAAG;AAAA,MAC/B,GAAG,QAAQ,QAAQ;AAAA,MACnB,QAAQ;AAAA,MACR,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AACA,UAAQ;AACR,EAAAC,MAAK;AACL,WAAS,QAAQ,KAAK,GAAG;AACzB,SAAO;AACT;AAGA,SAAS,wBAAwB;AAC/B,SAAO;AACT;AAMA,SAAS,mBAAmBD,OAAM,GAAG,SAAS,aAAa;AACzD,QAAM,UAAU,MAAM,WAAW;AACjC,MAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,QAAMC,QAAO,QAAQ,MAAM,oBAAoB;AAC/C,QAAM,UAAU,QAAQ,MAAM,OAAO;AACrC,WAAS,QAAQ;AAAA,IACf,KAAK,SAAS,YAAYD,KAAI,GAAG;AAAA,MAC/B,GAAG,QAAQ,QAAQ;AAAA,MACnB,QAAQ;AAAA,MACR,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AACA,UAAQ;AACR,WAAS,QAAQ;AAAA,IACf,QAAQA,MAAK,YAAYA,MAAK,SAAS,SAAS,IAAI,MAAM;AAAA,EAC5D;AACA,UAAQ,MAAM,CAAC;AACf,WAAS,QAAQ;AAAA,IACf,YAAY,cAAcA,OAAM,SAAS,QAAQ,QAAQ,CAAC,GAAG,GAAG;AAAA,EAClE;AACA,EAAAC,MAAK;AAEL,SAAO;AACT;AAGA,SAAS,IAAI,MAAMC,QAAO,OAAO;AAC/B,MAAIA,WAAU,GAAG;AACf,WAAO;AAAA,EACT;AAEA,UAAQ,QAAQ,KAAK,UAAU;AACjC;;;AU9MA;;;ACAA;;;ACAA;AAsBO,SAAS,kBAAkB,QAAQ,OAAO,MAAM;AACrD,QAAM,aAAa,MAAM;AACzB,QAAM,WAAW,OAAO,YAAY,CAAC;AAErC,QAAM,UAAU,CAAC;AACjB,MAAIC,SAAQ;AACZ,MAAI,SAAS,KAAK;AAElB,aAAW,KAAK,EAAE;AAClB,MAAI,UAAU,MAAM,cAAc,IAAI;AAEtC,SAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,UAAM,QAAQ,SAASA,MAAK;AAE5B,QAAI;AAEJ,eAAW,WAAW,SAAS,CAAC,IAAIA;AAEpC,QAAIA,SAAQ,IAAI,SAAS,QAAQ;AAG/B,UAAI,SAAS,MAAM,OAAO,SAAS,SAASA,SAAQ,CAAC,EAAE,IAAI;AAG3D,UAAI,UAAU,OAAO;AAAM,iBAAS,OAAO;AAC3C,cAAQ,SACJ,OAAO,SAASA,SAAQ,CAAC,GAAG,QAAQ,OAAO;AAAA,QACzC,QAAQ;AAAA,QACR,OAAO;AAAA,QACP,GAAG,QAAQ,QAAQ;AAAA,MACrB,CAAC,EAAE,OAAO,CAAC,IACX;AAAA,IACN,OAAO;AACL,cAAQ,KAAK;AAAA,IACf;AAQA,QACE,QAAQ,SAAS,MAChB,WAAW,QAAQ,WAAW,SAC/B,MAAM,SAAS,QACf;AACA,cAAQ,QAAQ,SAAS,CAAC,IAAI,QAAQ,QAAQ,SAAS,CAAC,EAAE;AAAA,QACxD;AAAA,QACA;AAAA,MACF;AACA,eAAS;AAGT,gBAAU,MAAM,cAAc,IAAI;AAClC,cAAQ,KAAK,QAAQ,KAAK,EAAE,CAAC;AAAA,IAC/B;AAEA,YAAQ;AAAA,MACN,QAAQ;AAAA,QACN,MAAM,OAAO,OAAO,QAAQ,OAAO;AAAA,UACjC,GAAG,QAAQ,QAAQ;AAAA,UACnB;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,aAAS,QAAQ,QAAQ,SAAS,CAAC,EAAE,MAAM,EAAE;AAAA,EAC/C;AAEA,aAAW,IAAI;AAEf,SAAO,QAAQ,KAAK,EAAE;AACxB;;;ADpEA,IAAM,iCAAiC;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,aAAa,OAAO;AAOb,IAAM,+BAA+B;AAAA,EAC1C,gBAAgB,CAAC,QAAQ;AAAA,EACzB,OAAO,EAAC,eAAe,mBAAkB;AAAA,EACzC,MAAM,EAAC,eAAe,kBAAiB;AACzC;AAOO,IAAM,6BAA6B;AAAA,EACxC,QAAQ;AAAA,IACN;AAAA,MACE,WAAW;AAAA,MACX,aAAa;AAAA,MACb,gBAAgB;AAAA,IAClB;AAAA,EACF;AAAA,EACA,UAAU,EAAC,QAAQ,aAAY;AACjC;AAMA,SAAS,mBAAmB,OAAO;AACjC,OAAK,MAAM,EAAC,MAAM,UAAU,UAAU,CAAC,EAAC,GAAG,KAAK;AAClD;AAMA,SAAS,kBAAkB,OAAO;AAChC,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,aAAaC,OAAM,GAAG,SAAS,aAAa;AACnD,QAAM,UAAU,MAAM,WAAW;AACjC,QAAMC,QAAO,QAAQ,MAAM,eAAe;AAC1C,MAAI,QAAQ,QAAQ,KAAK,IAAI;AAC7B,WAAS,kBAAkBD,OAAM,SAAS;AAAA,IACxC,GAAG,QAAQ,QAAQ;AAAA,IACnB,QAAQ;AAAA,IACR,OAAO;AAAA,EACT,CAAC;AACD,WAAS,QAAQ,KAAK,IAAI;AAC1B,EAAAC,MAAK;AACL,SAAO;AACT;AAGA,SAAS,aAAa;AACpB,SAAO;AACT;;;AEvGA;;;ACAA;;;ACAA;AAQA,WAAW,OAAO;AAQX,SAAS,WAAWC,OAAM,GAAG,OAAO;AACzC,MAAI,QAAQA,MAAK,SAAS;AAC1B,MAAI,WAAW;AACf,MAAIC,SAAQ;AAKZ,SAAO,IAAI,OAAO,aAAa,WAAW,UAAU,EAAE,KAAK,KAAK,GAAG;AACjE,gBAAY;AAAA,EACd;AAIA,MACE,WAAW,KAAK,KAAK,MACnB,WAAW,KAAK,KAAK,KAAK,WAAW,KAAK,KAAK,KAAM,QAAQ,KAAK,KAAK,IACzE;AACA,YAAQ,MAAM,QAAQ;AAAA,EACxB;AASA,SAAO,EAAEA,SAAQ,MAAM,OAAO,QAAQ;AACpC,UAAM,UAAU,MAAM,OAAOA,MAAK;AAClC,UAAM,aAAa,eAAe,OAAO;AAEzC,QAAI;AAKJ,QAAI,CAAC,QAAQ;AAAS;AAEtB,WAAQ,QAAQ,WAAW,KAAK,KAAK,GAAI;AACvC,UAAIC,YAAW,MAAM;AAGrB,UACE,MAAM,WAAWA,SAAQ,MAAM,MAC/B,MAAM,WAAWA,YAAW,CAAC,MAAM,IACnC;AACA,QAAAA;AAAA,MACF;AAEA,cAAQ,MAAM,MAAM,GAAGA,SAAQ,IAAI,MAAM,MAAM,MAAM,MAAM,QAAQ,CAAC;AAAA,IACtE;AAAA,EACF;AAEA,SAAO,WAAW,QAAQ;AAC5B;AAKA,SAAS,iBAAiB;AACxB,SAAO;AACT;;;AC9EA;AA0JO,SAAS,cAAc,OAAO,UAAU,CAAC,GAAG;AACjD,QAAM,SAAS,QAAQ,SAAS,CAAC,GAAG,OAAO;AAC3C,QAAM,eAAe,QAAQ,gBAAgB;AAE7C,QAAM,aAAa,CAAC;AAEpB,QAAM,aAAa,CAAC;AAEpB,QAAM,aAAa,CAAC;AAEpB,QAAM,sBAAsB,CAAC;AAC7B,MAAI,kBAAkB;AACtB,MAAI,WAAW;AAIf,SAAO,EAAE,WAAW,MAAM,QAAQ;AAEhC,UAAMC,OAAM,CAAC;AAEb,UAAMC,SAAQ,CAAC;AACf,QAAIC,eAAc;AAElB,QAAI,MAAM,QAAQ,EAAE,SAAS,iBAAiB;AAC5C,wBAAkB,MAAM,QAAQ,EAAE;AAAA,IACpC;AAEA,WAAO,EAAEA,eAAc,MAAM,QAAQ,EAAE,QAAQ;AAC7C,YAAM,OAAO,UAAU,MAAM,QAAQ,EAAEA,YAAW,CAAC;AAEnD,UAAI,QAAQ,oBAAoB,OAAO;AACrC,cAAM,OAAO,aAAa,IAAI;AAC9B,QAAAD,OAAMC,YAAW,IAAI;AAErB,YACE,oBAAoBA,YAAW,MAAM,UACrC,OAAO,oBAAoBA,YAAW,GACtC;AACA,8BAAoBA,YAAW,IAAI;AAAA,QACrC;AAAA,MACF;AAEA,MAAAF,KAAI,KAAK,IAAI;AAAA,IACf;AAEA,eAAW,QAAQ,IAAIA;AACvB,eAAW,QAAQ,IAAIC;AAAA,EACzB;AAGA,MAAI,cAAc;AAElB,MAAI,OAAO,UAAU,YAAY,YAAY,OAAO;AAClD,WAAO,EAAE,cAAc,iBAAiB;AACtC,iBAAW,WAAW,IAAI,YAAY,MAAM,WAAW,CAAC;AAAA,IAC1D;AAAA,EACF,OAAO;AACL,UAAME,QAAO,YAAY,KAAK;AAE9B,WAAO,EAAE,cAAc,iBAAiB;AACtC,iBAAW,WAAW,IAAIA;AAAA,IAC5B;AAAA,EACF;AAGA,gBAAc;AAEd,QAAM,MAAM,CAAC;AAEb,QAAM,QAAQ,CAAC;AAEf,SAAO,EAAE,cAAc,iBAAiB;AACtC,UAAMA,QAAO,WAAW,WAAW;AACnC,QAAI,SAAS;AACb,QAAI,QAAQ;AAEZ,QAAIA,UAAS,IAAc;AACzB,eAAS;AACT,cAAQ;AAAA,IACV,WAAWA,UAAS,KAAe;AACjC,eAAS;AAAA,IACX,WAAWA,UAAS,KAAe;AACjC,cAAQ;AAAA,IACV;AAGA,QAAI,OACF,QAAQ,oBAAoB,QACxB,IACA,KAAK;AAAA,MACH;AAAA,MACA,oBAAoB,WAAW,IAAI,OAAO,SAAS,MAAM;AAAA,IAC3D;AAEN,UAAM,OAAO,SAAS,IAAI,OAAO,IAAI,IAAI;AAEzC,QAAI,QAAQ,oBAAoB,OAAO;AACrC,aAAO,OAAO,SAAS,OAAO,MAAM;AAEpC,UAAI,OAAO,oBAAoB,WAAW,GAAG;AAC3C,4BAAoB,WAAW,IAAI;AAAA,MACrC;AAEA,YAAM,WAAW,IAAI;AAAA,IACvB;AAEA,QAAI,WAAW,IAAI;AAAA,EACrB;AAGA,aAAW,OAAO,GAAG,GAAG,GAAG;AAC3B,aAAW,OAAO,GAAG,GAAG,KAAK;AAE7B,aAAW;AAEX,QAAM,QAAQ,CAAC;AAEf,SAAO,EAAE,WAAW,WAAW,QAAQ;AACrC,UAAMH,OAAM,WAAW,QAAQ;AAC/B,UAAMC,SAAQ,WAAW,QAAQ;AACjC,kBAAc;AAEd,UAAM,OAAO,CAAC;AAEd,WAAO,EAAE,cAAc,iBAAiB;AACtC,YAAM,OAAOD,KAAI,WAAW,KAAK;AACjC,UAAI,SAAS;AACb,UAAI,QAAQ;AAEZ,UAAI,QAAQ,oBAAoB,OAAO;AACrC,cAAM,OACJ,oBAAoB,WAAW,KAAKC,OAAM,WAAW,KAAK;AAC5D,cAAME,QAAO,WAAW,WAAW;AAEnC,YAAIA,UAAS,KAAe;AAC1B,mBAAS,IAAI,OAAO,IAAI;AAAA,QAC1B,WAAWA,UAAS,IAAc;AAChC,cAAI,OAAO,GAAG;AACZ,qBAAS,IAAI,OAAO,OAAO,IAAI,GAAG;AAClC,oBAAQ,IAAI,OAAO,OAAO,IAAI,GAAG;AAAA,UACnC,OAAO;AACL,qBAAS,IAAI,OAAO,OAAO,CAAC;AAC5B,oBAAQ;AAAA,UACV;AAAA,QACF,OAAO;AACL,kBAAQ,IAAI,OAAO,IAAI;AAAA,QACzB;AAAA,MACF;AAEA,UAAI,QAAQ,mBAAmB,SAAS,CAAC,aAAa;AACpD,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UACE,QAAQ,YAAY;AAAA;AAAA,MAGpB,EAAE,QAAQ,oBAAoB,SAAS,SAAS,QAC/C,QAAQ,mBAAmB,SAAS,cACrC;AACA,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UAAI,QAAQ,oBAAoB,OAAO;AACrC,aAAK,KAAK,MAAM;AAAA,MAClB;AAEA,WAAK,KAAK,IAAI;AAEd,UAAI,QAAQ,oBAAoB,OAAO;AACrC,aAAK,KAAK,KAAK;AAAA,MACjB;AAEA,UAAI,QAAQ,YAAY,OAAO;AAC7B,aAAK,KAAK,GAAG;AAAA,MACf;AAEA,UACE,QAAQ,iBAAiB,SACzB,gBAAgB,kBAAkB,GAClC;AACA,aAAK,KAAK,GAAG;AAAA,MACf;AAAA,IACF;AAEA,UAAM;AAAA,MACJ,QAAQ,iBAAiB,QACrB,KAAK,KAAK,EAAE,EAAE,QAAQ,OAAO,EAAE,IAC/B,KAAK,KAAK,EAAE;AAAA,IAClB;AAAA,EACF;AAEA,SAAO,MAAM,KAAK,IAAI;AACxB;AAMA,SAAS,UAAU,OAAO;AACxB,SAAO,UAAU,QAAQ,UAAU,SAAY,KAAK,OAAO,KAAK;AAClE;AAMA,SAAS,oBAAoB,OAAO;AAClC,SAAO,MAAM;AACf;AAMA,SAAS,YAAY,OAAO;AAC1B,QAAMA,QAAO,OAAO,UAAU,WAAW,MAAM,YAAY,CAAC,IAAI;AAEhE,SAAOA,UAAS,MAAgBA,UAAS,KACrC,KACAA,UAAS,MAAgBA,UAAS,MAClC,MACAA,UAAS,MAAgBA,UAAS,MAClC,MACA;AACN;;;AFhVO,IAAM,uBAAuB;AAAA,EAClC,OAAO;AAAA,IACL,OAAO;AAAA,IACP,WAAW;AAAA,IACX,aAAa;AAAA,IACb,UAAU;AAAA,EACZ;AAAA,EACA,MAAM;AAAA,IACJ,UAAU;AAAA,IACV,OAAO;AAAA,IACP,WAAWC;AAAA,IACX,aAAaA;AAAA,IACb,UAAUA;AAAA,EACZ;AACF;AAMA,SAAS,WAAW,OAAO;AAGzB,QAAM,QAAQ,MAAM;AACpB,OAAK;AAAA,IACH;AAAA,MACE,MAAM;AAAA,MACN,OAAO,MAAM,IAAI,CAAC,MAAO,MAAM,SAAS,OAAO,CAAE;AAAA,MACjD,UAAU,CAAC;AAAA,IACb;AAAA,IACA;AAAA,EACF;AACA,OAAK,QAAQ,WAAW,IAAI;AAC9B;AAMA,SAAS,UAAU,OAAO;AACxB,OAAK,KAAK,KAAK;AACf,OAAK,QAAQ,SAAS;AACxB;AAMA,SAAS,SAAS,OAAO;AACvB,OAAK,MAAM,EAAC,MAAM,YAAY,UAAU,CAAC,EAAC,GAAG,KAAK;AACpD;AAMA,SAASA,MAAK,OAAO;AACnB,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,UAAU,OAAO;AACxB,OAAK,MAAM,EAAC,MAAM,aAAa,UAAU,CAAC,EAAC,GAAG,KAAK;AACrD;AAQA,SAAS,aAAa,OAAO;AAC3B,MAAI,QAAQ,KAAK,OAAO;AAExB,MAAI,KAAK,QAAQ,SAAS,GAAG;AAC3B,YAAQ,MAAM,QAAQ,cAAc,OAAO;AAAA,EAC7C;AAEA,QAAMC;AAAA;AAAA,IAAkC,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AACxE,EAAAA,MAAK,QAAQ;AACb,OAAK,KAAK,KAAK;AACjB;AAOA,SAAS,QAAQ,IAAI,IAAI;AAEvB,SAAO,OAAO,MAAM,KAAK;AAC3B;AAWO,SAAS,mBAAmB,SAAS;AAC1C,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAM,UAAU,SAAS;AACzB,QAAM,kBAAkB,SAAS;AACjC,QAAM,eAAe,SAAS;AAC9B,QAAM,SAAS,UAAU,MAAM;AAE/B,SAAO;AAAA,IACL,QAAQ;AAAA,MACN,EAAC,WAAW,MAAM,aAAa,YAAW;AAAA,MAC1C,EAAC,WAAW,MAAM,aAAa,YAAW;AAAA;AAAA;AAAA,MAG1C,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,SAAS;AAAA;AAAA,MAEhD,EAAC,WAAW,KAAK,aAAa,YAAW;AAAA;AAAA;AAAA,MAGzC,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,IAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAM1C,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,QAAO;AAAA,IAChD;AAAA,IACA,UAAU;AAAA,MACR,OAAO;AAAA,MACP,UAAU;AAAA,MACV,WAAW;AAAA,MACX,YAAY;AAAA,IACd;AAAA,EACF;AAMA,WAAS,YAAYA,OAAM,GAAG,SAAS,aAAa;AAClD,WAAO;AAAA,MACL,kBAAkBA,OAAM,SAAS,WAAW;AAAA,MAC5CA,MAAK;AAAA,IACP;AAAA,EACF;AAUA,WAAS,eAAeA,OAAM,GAAG,SAAS,aAAa;AACrD,UAAM,MAAM,qBAAqBA,OAAM,SAAS,WAAW;AAC3D,UAAM,QAAQ,cAAc,CAAC,GAAG,CAAC;AAEjC,WAAO,MAAM,MAAM,GAAG,MAAM,QAAQ,IAAI,CAAC;AAAA,EAC3C;AAMA,WAAS,gBAAgBA,OAAM,GAAG,SAAS,aAAa;AACtD,UAAMD,QAAO,QAAQ,MAAM,WAAW;AACtC,UAAM,UAAU,QAAQ,MAAM,UAAU;AACxC,UAAM,QAAQ,kBAAkBC,OAAM,SAAS;AAAA,MAC7C,GAAG;AAAA,MACH,QAAQ;AAAA,MACR,OAAO;AAAA,IACT,CAAC;AACD,YAAQ;AACR,IAAAD,MAAK;AACL,WAAO;AAAA,EACT;AAMA,WAAS,cAAc,QAAQ,OAAO;AACpC,WAAO,cAAc,QAAQ;AAAA,MAC3B;AAAA;AAAA,MAEA;AAAA;AAAA,MAEA;AAAA;AAAA,MAEA;AAAA,IACF,CAAC;AAAA,EACH;AAOA,WAAS,kBAAkBC,OAAM,SAAS,aAAa;AACrD,UAAM,WAAWA,MAAK;AACtB,QAAIC,SAAQ;AAEZ,UAAM,SAAS,CAAC;AAChB,UAAM,UAAU,QAAQ,MAAM,OAAO;AAErC,WAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,aAAOA,MAAK,IAAI;AAAA,QACd,SAASA,MAAK;AAAA,QACd;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,YAAQ;AAER,WAAO;AAAA,EACT;AAOA,WAAS,qBAAqBD,OAAM,SAAS,aAAa;AACxD,UAAM,WAAWA,MAAK;AACtB,QAAIC,SAAQ;AAEZ,UAAM,SAAS,CAAC;AAChB,UAAM,UAAU,QAAQ,MAAM,UAAU;AAExC,WAAO,EAAEA,SAAQ,SAAS,QAAQ;AAIhC,aAAOA,MAAK,IAAI;AAAA,QACd,SAASA,MAAK;AAAA,QACdD;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,YAAQ;AAER,WAAO;AAAA,EACT;AAMA,WAAS,oBAAoBA,OAAM,QAAQ,SAAS;AAClD,QAAI,QAAQ,WAAWA,OAAM,QAAQ,OAAO;AAE5C,QAAI,QAAQ,MAAM,SAAS,WAAW,GAAG;AACvC,cAAQ,MAAM,QAAQ,OAAO,MAAM;AAAA,IACrC;AAEA,WAAO;AAAA,EACT;AACF;;;AGpTA;;;ACAA;;;ACAA;;;ACAA;AASO,SAAS,YAAY,OAAO;AACjC,QAAM,SAAS,MAAM,QAAQ,UAAU;AAEvC,MAAI,WAAW,OAAO,WAAW,OAAO,WAAW,KAAK;AACtD,UAAM,IAAI;AAAA,MACR,kCACE,SACA;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;;;ACrBA;AASO,SAAS,oBAAoB,OAAO;AACzC,QAAM,QAAQ,MAAM,QAAQ,kBAAkB;AAI9C,MAAI,UAAU,KAAK,UAAU,KAAK;AAChC,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,SAAS,UAAU,SAAS,UAAU,SAAS;AAC3D,UAAM,IAAI;AAAA,MACR,kCACE,QACA;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;;;AFTO,SAAS,SAASE,OAAM,QAAQ,OAAO,MAAM;AAClD,QAAM,iBAAiB,oBAAoB,KAAK;AAChD,MAAI,SAAS,MAAM,iBAAiB,YAAY,KAAK;AAGrD,MAAI,UAAU,OAAO,SAAS,UAAU,OAAO,SAAS;AACtD,cACG,OAAO,OAAO,UAAU,YAAY,OAAO,QAAQ,KAChD,OAAO,QACP,MACH,MAAM,QAAQ,wBAAwB,QACnC,IACA,OAAO,SAAS,QAAQA,KAAI,KAChC;AAAA,EACJ;AAEA,MAAI,OAAO,OAAO,SAAS;AAE3B,MACE,mBAAmB,SAClB,mBAAmB,YAChB,UAAU,OAAO,SAAS,UAAU,OAAO,UAAWA,MAAK,SAC/D;AACA,WAAO,KAAK,KAAK,OAAO,CAAC,IAAI;AAAA,EAC/B;AAEA,QAAM,UAAU,MAAM,cAAc,IAAI;AACxC,UAAQ,KAAK,SAAS,IAAI,OAAO,OAAO,OAAO,MAAM,CAAC;AACtD,UAAQ,MAAM,IAAI;AAClB,QAAMC,QAAO,MAAM,MAAM,UAAU;AACnC,QAAM,QAAQ,MAAM;AAAA,IAClB,MAAM,cAAcD,OAAM,QAAQ,QAAQ,CAAC;AAAA,IAC3CE;AAAA,EACF;AACA,EAAAD,MAAK;AAEL,SAAO;AAGP,WAASC,KAAI,MAAMC,QAAO,OAAO;AAC/B,QAAIA,QAAO;AACT,cAAQ,QAAQ,KAAK,IAAI,OAAO,IAAI,KAAK;AAAA,IAC3C;AAEA,YAAQ,QAAQ,SAAS,SAAS,IAAI,OAAO,OAAO,OAAO,MAAM,KAAK;AAAA,EACxE;AACF;;;ADlCO,IAAM,8BAA8B;AAAA,EACzC,MAAM;AAAA,IACJ,2BAA2B;AAAA,IAC3B,6BAA6B;AAAA,IAC7B,WAAW;AAAA,EACb;AACF;AAOO,IAAM,4BAA4B;AAAA,EACvC,QAAQ,CAAC,EAAC,SAAS,MAAM,WAAW,KAAK,OAAO,QAAO,CAAC;AAAA,EACxD,UAAU,EAAC,UAAU,yBAAwB;AAC/C;AAMA,SAAS,UAAU,OAAO;AACxB,QAAMC;AAAA;AAAA,IAAgC,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AAEtE,EAAAA,MAAK,UAAU,MAAM,SAAS;AAChC;AAMA,SAAS,8BAA8B,OAAO;AAC5C,QAAM;AAAA;AAAA,IAAiC,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AAEvE,MACE,UACA,OAAO,SAAS,cAChB,OAAO,OAAO,YAAY,WAC1B;AACA,UAAMA;AAAA;AAAA,MAAiC,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA;AACvE,UAAM,OAAOA,MAAK,SAAS,CAAC;AAE5B,QAAI,QAAQ,KAAK,SAAS,QAAQ;AAChC,YAAM,WAAW,OAAO;AACxB,UAAIC,SAAQ;AAEZ,UAAI;AAEJ,aAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,cAAM,UAAU,SAASA,MAAK;AAC9B,YAAI,QAAQ,SAAS,aAAa;AAChC,4BAAkB;AAClB;AAAA,QACF;AAAA,MACF;AAEA,UAAI,oBAAoBD,OAAM;AAE5B,aAAK,QAAQ,KAAK,MAAM,MAAM,CAAC;AAE/B,YAAI,KAAK,MAAM,WAAW,GAAG;AAC3B,UAAAA,MAAK,SAAS,MAAM;AAAA,QACtB,WACEA,MAAK,YACL,KAAK,YACL,OAAO,KAAK,SAAS,MAAM,WAAW,UACtC;AACA,eAAK,SAAS,MAAM;AACpB,eAAK,SAAS,MAAM;AACpB,UAAAA,MAAK,SAAS,QAAQ,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,KAAK;AAAA,QAC7D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,OAAK,KAAK,KAAK;AACjB;AAMA,SAAS,yBAAyBA,OAAM,QAAQ,SAAS,aAAa;AACpE,QAAM,OAAOA,MAAK,SAAS,CAAC;AAC5B,QAAM,YACJ,OAAOA,MAAK,YAAY,aAAa,QAAQ,KAAK,SAAS;AAC7D,QAAM,WAAW,OAAOA,MAAK,UAAU,MAAM,OAAO;AACpD,QAAM,UAAU,MAAM,WAAW;AAEjC,MAAI,WAAW;AACb,YAAQ,KAAK,QAAQ;AAAA,EACvB;AAEA,MAAI,QAAQ,SAASA,OAAM,QAAQ,SAAS;AAAA,IAC1C,GAAG;AAAA,IACH,GAAG,QAAQ,QAAQ;AAAA,EACrB,CAAC;AAED,MAAI,WAAW;AACb,YAAQ,MAAM,QAAQ,mCAAmC,KAAK;AAAA,EAChE;AAEA,SAAO;AAMP,WAAS,MAAM,IAAI;AACjB,WAAO,KAAK;AAAA,EACd;AACF;;;A/B1GO,SAAS,kBAAkB;AAChC,SAAO;AAAA,IACL;AAAA,IACA,wBAAwB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAYO,SAAS,cAAc,SAAS;AACrC,SAAO;AAAA,IACL,YAAY;AAAA,MACV;AAAA,MACA,sBAAsB;AAAA,MACtB;AAAA,MACA,mBAAmB,OAAO;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AACF;;;ArDrDe,SAAR,UAA2B,UAAU,CAAC,GAAG;AAC9C,QAAME,QAAO,KAAK,KAAK;AAEvB,MAAI,uBAAuB,IAAI,OAAO,CAAC;AACvC,MAAI,0BAA0B,gBAAgB,CAAC;AAC/C,MAAI,wBAAwB,cAAc,OAAO,CAAC;AAMlD,WAAS,IAAI,OAAO,OAAO;AACzB,UAAMC;AAAA;AAAA;AAAA;AAAA,MAGJD,MAAK,KAAK,IAAIA,MAAK,KAAK,IAAKA,MAAK,KAAK,IAAI,CAAC;AAAA;AAG9C,IAAAC,MAAK,KAAK,KAAK;AAAA,EACjB;AACF;;;AwFjCA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAYA,IAAM,eAAe,CAAC;AAef,SAAS,SAAS,OAAO,SAAS;AACvC,QAAM,WAAW,WAAW;AAC5B,QAAM,kBACJ,OAAO,SAAS,oBAAoB,YAChC,SAAS,kBACT;AACN,QAAM,cACJ,OAAO,SAAS,gBAAgB,YAAY,SAAS,cAAc;AAErE,SAAO,IAAI,OAAO,iBAAiB,WAAW;AAChD;AAcA,SAAS,IAAI,OAAO,iBAAiB,aAAa;AAChD,MAAI,KAAK,KAAK,GAAG;AACf,QAAI,WAAW,OAAO;AACpB,aAAO,MAAM,SAAS,UAAU,CAAC,cAAc,KAAK,MAAM;AAAA,IAC5D;AAEA,QAAI,mBAAmB,SAAS,SAAS,MAAM,KAAK;AAClD,aAAO,MAAM;AAAA,IACf;AAEA,QAAI,cAAc,OAAO;AACvB,aAAO,IAAI,MAAM,UAAU,iBAAiB,WAAW;AAAA,IACzD;AAAA,EACF;AAEA,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,IAAI,OAAO,iBAAiB,WAAW;AAAA,EAChD;AAEA,SAAO;AACT;AAcA,SAAS,IAAI,QAAQ,iBAAiB,aAAa;AAEjD,QAAM,SAAS,CAAC;AAChB,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,WAAOA,MAAK,IAAI,IAAI,OAAOA,MAAK,GAAG,iBAAiB,WAAW;AAAA,EACjE;AAEA,SAAO,OAAO,KAAK,EAAE;AACvB;AAUA,SAAS,KAAK,OAAO;AACnB,SAAO,QAAQ,SAAS,OAAO,UAAU,QAAQ;AACnD;;;AC3GA;;;ACAA;AAWO,IAAMC,WAAU;AAAA,EACrB,UAAU;AACZ;AAMA,SAAS,kBAAkB,SAAS;AAClC,QAAM,eAAe,QAAQ;AAAA,IAC3B,KAAK,OAAO,WAAW;AAAA,IACvB;AAAA,IACA;AAAA,EACF;AAEA,MAAIC;AACJ,SAAO;AAGP,WAAS,2BAA2BC,OAAM;AACxC,QAAIA,UAAS,MAAM;AACjB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,WAAO,aAAa,SAAS,cAAc,YAAY;AAAA,EACzD;AAGA,WAAS,iBAAiBA,OAAM;AAC9B,YAAQ,MAAM,WAAW;AACzB,WAAO,UAAUA,KAAI;AAAA,EACvB;AAGA,WAAS,UAAUA,OAAM;AACvB,UAAM,QAAQ,QAAQ,MAAM,aAAa;AAAA,MACvC,aAAa;AAAA,MACb,UAAAD;AAAA,IACF,CAAC;AACD,QAAIA,WAAU;AACZ,MAAAA,UAAS,OAAO;AAAA,IAClB;AACA,IAAAA,YAAW;AACX,WAAOE,MAAKD,KAAI;AAAA,EAClB;AAGA,WAASC,MAAKD,OAAM;AAClB,QAAIA,UAAS,MAAM;AACjB,cAAQ,KAAK,WAAW;AACxB,cAAQ,KAAK,WAAW;AACxB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,QAAQA,KAAI;AACpB,cAAQ,KAAK,WAAW;AACxB,aAAO;AAAA,IACT;AAGA,YAAQ,QAAQA,KAAI;AACpB,WAAOC;AAAA,EACT;AACF;;;AC9EA;AAoBO,IAAMC,YAAW;AAAA,EACtB,UAAU;AACZ;AAGA,IAAM,qBAAqB;AAAA,EACzB,UAAU;AACZ;AAMA,SAAS,mBAAmB,SAAS;AACnC,QAAM,OAAO;AAEb,QAAM,QAAQ,CAAC;AACf,MAAI,YAAY;AAEhB,MAAI;AAEJ,MAAI;AAEJ,MAAI;AACJ,SAAO;AAGP,WAAS,MAAMC,OAAM;AAWnB,QAAI,YAAY,MAAM,QAAQ;AAC5B,YAAM,OAAO,MAAM,SAAS;AAC5B,WAAK,iBAAiB,KAAK,CAAC;AAC5B,aAAO,QAAQ;AAAA,QACb,KAAK,CAAC,EAAE;AAAA,QACR;AAAA,QACA;AAAA,MACF,EAAEA,KAAI;AAAA,IACR;AAGA,WAAO,mBAAmBA,KAAI;AAAA,EAChC;AAGA,WAAS,iBAAiBA,OAAM;AAC9B;AAKA,QAAI,KAAK,eAAe,YAAY;AAClC,WAAK,eAAe,aAAa;AACjC,UAAI,WAAW;AACb,kBAAU;AAAA,MACZ;AAIA,YAAM,mBAAmB,KAAK,OAAO;AACrC,UAAI,kBAAkB;AAEtB,UAAIC;AAGJ,aAAO,mBAAmB;AACxB,YACE,KAAK,OAAO,eAAe,EAAE,CAAC,MAAM,UACpC,KAAK,OAAO,eAAe,EAAE,CAAC,EAAE,SAAS,aACzC;AACA,UAAAA,SAAQ,KAAK,OAAO,eAAe,EAAE,CAAC,EAAE;AACxC;AAAA,QACF;AAAA,MACF;AACA,qBAAe,SAAS;AAGxB,UAAIC,SAAQ;AACZ,aAAOA,SAAQ,KAAK,OAAO,QAAQ;AACjC,aAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAGD,MAAK;AACnD,QAAAC;AAAA,MACF;AAGA;AAAA,QACE,KAAK;AAAA,QACL,kBAAkB;AAAA,QAClB;AAAA,QACA,KAAK,OAAO,MAAM,gBAAgB;AAAA,MACpC;AAGA,WAAK,OAAO,SAASA;AACrB,aAAO,mBAAmBF,KAAI;AAAA,IAChC;AACA,WAAO,MAAMA,KAAI;AAAA,EACnB;AAGA,WAAS,mBAAmBA,OAAM;AAMhC,QAAI,cAAc,MAAM,QAAQ;AAI9B,UAAI,CAAC,WAAW;AACd,eAAO,kBAAkBA,KAAI;AAAA,MAC/B;AAKA,UAAI,UAAU,oBAAoB,UAAU,iBAAiB,UAAU;AACrE,eAAO,UAAUA,KAAI;AAAA,MACvB;AAOA,WAAK,YAAY;AAAA,QACf,UAAU,oBAAoB,CAAC,UAAU;AAAA,MAC3C;AAAA,IACF;AAGA,SAAK,iBAAiB,CAAC;AACvB,WAAO,QAAQ;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAGA,WAAS,qBAAqBA,OAAM;AAClC,QAAI;AAAW,gBAAU;AACzB,mBAAe,SAAS;AACxB,WAAO,kBAAkBA,KAAI;AAAA,EAC/B;AAGA,WAAS,sBAAsBA,OAAM;AACnC,SAAK,OAAO,KAAK,KAAK,IAAI,EAAE,IAAI,IAAI,cAAc,MAAM;AACxD,sBAAkB,KAAK,IAAI,EAAE;AAC7B,WAAO,UAAUA,KAAI;AAAA,EACvB;AAGA,WAAS,kBAAkBA,OAAM;AAE/B,SAAK,iBAAiB,CAAC;AACvB,WAAO,QAAQ;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAEA,KAAI;AAAA,EACR;AAGA,WAAS,kBAAkBA,OAAM;AAC/B;AACA,UAAM,KAAK,CAAC,KAAK,kBAAkB,KAAK,cAAc,CAAC;AAEvD,WAAO,kBAAkBA,KAAI;AAAA,EAC/B;AAGA,WAAS,UAAUA,OAAM;AACvB,QAAIA,UAAS,MAAM;AACjB,UAAI;AAAW,kBAAU;AACzB,qBAAe,CAAC;AAChB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,gBAAY,aAAa,KAAK,OAAO,KAAK,KAAK,IAAI,CAAC;AACpD,YAAQ,MAAM,aAAa;AAAA,MACzB,aAAa;AAAA,MACb,UAAU;AAAA,MACV,YAAY;AAAA,IACd,CAAC;AACD,WAAO,aAAaA,KAAI;AAAA,EAC1B;AAGA,WAAS,aAAaA,OAAM;AAC1B,QAAIA,UAAS,MAAM;AACjB,mBAAa,QAAQ,KAAK,WAAW,GAAG,IAAI;AAC5C,qBAAe,CAAC;AAChB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,cAAQ,QAAQA,KAAI;AACpB,mBAAa,QAAQ,KAAK,WAAW,CAAC;AAEtC,kBAAY;AACZ,WAAK,YAAY;AACjB,aAAO;AAAA,IACT;AACA,YAAQ,QAAQA,KAAI;AACpB,WAAO;AAAA,EACT;AAOA,WAAS,aAAa,OAAO,KAAK;AAChC,UAAM,SAAS,KAAK,YAAY,KAAK;AACrC,QAAI;AAAK,aAAO,KAAK,IAAI;AACzB,UAAM,WAAW;AACjB,QAAI;AAAY,iBAAW,OAAO;AAClC,iBAAa;AACb,cAAU,WAAW,MAAM,KAAK;AAChC,cAAU,MAAM,MAAM;AAmCtB,QAAI,KAAK,OAAO,KAAK,MAAM,MAAM,IAAI,GAAG;AACtC,UAAIE,SAAQ,UAAU,OAAO;AAC7B,aAAOA,UAAS;AACd;AAAA;AAAA,UAEE,UAAU,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,SAAS;AAAA,WAEzC,CAAC,UAAU,OAAOA,MAAK,EAAE,CAAC,EAAE;AAAA,UAE3B,UAAU,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,SAAS;AAAA,UAC1C;AAGA;AAAA,QACF;AAAA,MACF;AAIA,YAAM,mBAAmB,KAAK,OAAO;AACrC,UAAI,kBAAkB;AAEtB,UAAI;AAEJ,UAAID;AAGJ,aAAO,mBAAmB;AACxB,YACE,KAAK,OAAO,eAAe,EAAE,CAAC,MAAM,UACpC,KAAK,OAAO,eAAe,EAAE,CAAC,EAAE,SAAS,aACzC;AACA,cAAI,MAAM;AACR,YAAAA,SAAQ,KAAK,OAAO,eAAe,EAAE,CAAC,EAAE;AACxC;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AACA,qBAAe,SAAS;AAGxB,MAAAC,SAAQ;AACR,aAAOA,SAAQ,KAAK,OAAO,QAAQ;AACjC,aAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,MAAM,OAAO,OAAO,CAAC,GAAGD,MAAK;AACnD,QAAAC;AAAA,MACF;AAGA;AAAA,QACE,KAAK;AAAA,QACL,kBAAkB;AAAA,QAClB;AAAA,QACA,KAAK,OAAO,MAAM,gBAAgB;AAAA,MACpC;AAGA,WAAK,OAAO,SAASA;AAAA,IACvB;AAAA,EACF;AAMA,WAAS,eAAe,MAAM;AAC5B,QAAIA,SAAQ,MAAM;AAGlB,WAAOA,WAAU,MAAM;AACrB,YAAM,QAAQ,MAAMA,MAAK;AACzB,WAAK,iBAAiB,MAAM,CAAC;AAC7B,YAAM,CAAC,EAAE,KAAK,KAAK,MAAM,OAAO;AAAA,IAClC;AACA,UAAM,SAAS;AAAA,EACjB;AACA,WAAS,YAAY;AACnB,cAAU,MAAM,CAAC,IAAI,CAAC;AACtB,iBAAa;AACb,gBAAY;AACZ,SAAK,eAAe,aAAa;AAAA,EACnC;AACF;AAMA,SAAS,kBAAkB,SAASC,KAAI,KAAK;AAG3C,SAAO;AAAA,IACL;AAAA,IACA,QAAQ,QAAQ,KAAK,OAAO,WAAW,UAAUA,KAAI,GAAG;AAAA,IACxD;AAAA,IACA,KAAK,OAAO,WAAW,QAAQ,KAAK,SAAS,cAAc,IAAI,SAAY;AAAA,EAC7E;AACF;;;AC7XA;AAWO,IAAM,OAAO;AAAA,EAClB,UAAU;AACZ;AAMA,SAAS,eAAe,SAAS;AAC/B,QAAM,OAAO;AACb,QAAM,UAAU,QAAQ;AAAA;AAAA,IAEtB;AAAA,IACA;AAAA;AAAA,IAEA,QAAQ;AAAA,MACN,KAAK,OAAO,WAAW;AAAA,MACvB;AAAA,MACA;AAAA,QACE;AAAA,QACA,QAAQ;AAAA,UACN,KAAK,OAAO,WAAW;AAAA,UACvB;AAAA,UACA,QAAQ,QAAQ,SAAS,cAAc;AAAA,QACzC;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAGP,WAAS,cAAcC,OAAM;AAC3B,QAAIA,UAAS,MAAM;AACjB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,YAAQ,MAAM,iBAAiB;AAC/B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,iBAAiB;AAC9B,SAAK,mBAAmB;AACxB,WAAO;AAAA,EACT;AAGA,WAAS,eAAeA,OAAM;AAC5B,QAAIA,UAAS,MAAM;AACjB,cAAQ,QAAQA,KAAI;AACpB;AAAA,IACF;AACA,YAAQ,MAAM,YAAY;AAC1B,YAAQ,QAAQA,KAAI;AACpB,YAAQ,KAAK,YAAY;AACzB,SAAK,mBAAmB;AACxB,WAAO;AAAA,EACT;AACF;;;ACnEA;AASO,IAAM,WAAW;AAAA,EACtB,YAAY,eAAe;AAC7B;AACO,IAAM,SAAS,kBAAkB,QAAQ;AACzC,IAAMC,QAAO,kBAAkB,MAAM;AAM5C,SAAS,kBAAkB,OAAO;AAChC,SAAO;AAAA,IACL,UAAU;AAAA,IACV,YAAY;AAAA,MACV,UAAU,SAAS,yBAAyB;AAAA,IAC9C;AAAA,EACF;AAMA,WAAS,eAAe,SAAS;AAC/B,UAAM,OAAO;AACb,UAAMC,cAAa,KAAK,OAAO,WAAW,KAAK;AAC/C,UAAMD,QAAO,QAAQ,QAAQC,aAAY,OAAO,OAAO;AACvD,WAAO;AAGP,aAAS,MAAMC,OAAM;AACnB,aAAO,QAAQA,KAAI,IAAIF,MAAKE,KAAI,IAAI,QAAQA,KAAI;AAAA,IAClD;AAGA,aAAS,QAAQA,OAAM;AACrB,UAAIA,UAAS,MAAM;AACjB,gBAAQ,QAAQA,KAAI;AACpB;AAAA,MACF;AACA,cAAQ,MAAM,MAAM;AACpB,cAAQ,QAAQA,KAAI;AACpB,aAAOC;AAAA,IACT;AAGA,aAASA,MAAKD,OAAM;AAClB,UAAI,QAAQA,KAAI,GAAG;AACjB,gBAAQ,KAAK,MAAM;AACnB,eAAOF,MAAKE,KAAI;AAAA,MAClB;AAGA,cAAQ,QAAQA,KAAI;AACpB,aAAOC;AAAA,IACT;AAMA,aAAS,QAAQD,OAAM;AACrB,UAAIA,UAAS,MAAM;AACjB,eAAO;AAAA,MACT;AACA,YAAME,QAAOH,YAAWC,KAAI;AAC5B,UAAIG,SAAQ;AACZ,UAAID,OAAM;AAGR,eAAO,EAAEC,SAAQD,MAAK,QAAQ;AAC5B,gBAAM,OAAOA,MAAKC,MAAK;AACvB,cAAI,CAAC,KAAK,YAAY,KAAK,SAAS,KAAK,MAAM,KAAK,QAAQ,GAAG;AAC7D,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAMA,SAAS,eAAe,eAAe;AACrC,SAAO;AAGP,WAAS,eAAe,QAAQ,SAAS;AACvC,QAAIA,SAAQ;AAEZ,QAAI;AAIJ,WAAO,EAAEA,UAAS,OAAO,QAAQ;AAC/B,UAAI,UAAU,QAAW;AACvB,YAAI,OAAOA,MAAK,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,QAAQ;AACrD,kBAAQA;AACR,UAAAA;AAAA,QACF;AAAA,MACF,WAAW,CAAC,OAAOA,MAAK,KAAK,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,QAAQ;AAE7D,YAAIA,WAAU,QAAQ,GAAG;AACvB,iBAAO,KAAK,EAAE,CAAC,EAAE,MAAM,OAAOA,SAAQ,CAAC,EAAE,CAAC,EAAE;AAC5C,iBAAO,OAAO,QAAQ,GAAGA,SAAQ,QAAQ,CAAC;AAC1C,UAAAA,SAAQ,QAAQ;AAAA,QAClB;AACA,gBAAQ;AAAA,MACV;AAAA,IACF;AACA,WAAO,gBAAgB,cAAc,QAAQ,OAAO,IAAI;AAAA,EAC1D;AACF;AAaA,SAAS,uBAAuB,QAAQ,SAAS;AAC/C,MAAI,aAAa;AAEjB,SAAO,EAAE,cAAc,OAAO,QAAQ;AACpC,SACG,eAAe,OAAO,UACrB,OAAO,UAAU,EAAE,CAAC,EAAE,SAAS,iBACjC,OAAO,aAAa,CAAC,EAAE,CAAC,EAAE,SAAS,QACnC;AACA,YAAMF,QAAO,OAAO,aAAa,CAAC,EAAE,CAAC;AACrC,YAAM,SAAS,QAAQ,YAAYA,KAAI;AACvC,UAAIE,SAAQ,OAAO;AACnB,UAAI,cAAc;AAClB,UAAI,OAAO;AAEX,UAAI;AACJ,aAAOA,UAAS;AACd,cAAM,QAAQ,OAAOA,MAAK;AAC1B,YAAI,OAAO,UAAU,UAAU;AAC7B,wBAAc,MAAM;AACpB,iBAAO,MAAM,WAAW,cAAc,CAAC,MAAM,IAAI;AAC/C;AACA;AAAA,UACF;AACA,cAAI;AAAa;AACjB,wBAAc;AAAA,QAChB,WAES,UAAU,IAAI;AACrB,iBAAO;AACP;AAAA,QACF,WAAW,UAAU,IAAI;AAAA,QAEzB,OAAO;AAEL,UAAAA;AACA;AAAA,QACF;AAAA,MACF;AACA,UAAI,MAAM;AACR,cAAM,QAAQ;AAAA,UACZ,MACE,eAAe,OAAO,UAAU,QAAQ,OAAO,IAC3C,eACA;AAAA,UACN,OAAO;AAAA,YACL,MAAMF,MAAK,IAAI;AAAA,YACf,QAAQA,MAAK,IAAI,SAAS;AAAA,YAC1B,QAAQA,MAAK,IAAI,SAAS;AAAA,YAC1B,QAAQA,MAAK,MAAM,SAASE;AAAA,YAC5B,cAAcA,SACV,cACAF,MAAK,MAAM,eAAe;AAAA,UAChC;AAAA,UACA,KAAK,OAAO,OAAO,CAAC,GAAGA,MAAK,GAAG;AAAA,QACjC;AACA,QAAAA,MAAK,MAAM,OAAO,OAAO,CAAC,GAAG,MAAM,KAAK;AACxC,YAAIA,MAAK,MAAM,WAAWA,MAAK,IAAI,QAAQ;AACzC,iBAAO,OAAOA,OAAM,KAAK;AAAA,QAC3B,OAAO;AACL,iBAAO;AAAA,YACL;AAAA,YACA;AAAA,YACA,CAAC,SAAS,OAAO,OAAO;AAAA,YACxB,CAAC,QAAQ,OAAO,OAAO;AAAA,UACzB;AACA,wBAAc;AAAA,QAChB;AAAA,MACF;AACA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;;;ACjNA;AA+CO,SAAS,gBAAgBG,SAAQ,YAAY,MAAM;AAExD,MAAIC,SAAQ,OAAO;AAAA,IACjB,OACI,OAAO,OAAO,CAAC,GAAG,IAAI,IACtB;AAAA,MACE,MAAM;AAAA,MACN,QAAQ;AAAA,MACR,QAAQ;AAAA,IACV;AAAA,IACJ;AAAA,MACE,QAAQ;AAAA,MACR,cAAc;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,cAAc,CAAC;AAErB,QAAM,uBAAuB,CAAC;AAE9B,MAAI,SAAS,CAAC;AAEd,MAAI,QAAQ,CAAC;AAEb,MAAI,WAAW;AAOf,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,IACA,MAAAC;AAAA,IACA,SAAS,iBAAiB,qBAAqB;AAAA,IAC/C,OAAO,iBAAiB,iBAAiB;AAAA,IACzC,WAAW,iBAAiB,mBAAmB;AAAA,MAC7C,WAAW;AAAA,IACb,CAAC;AAAA,EACH;AAOA,QAAM,UAAU;AAAA,IACd,UAAU;AAAA,IACV,MAAM;AAAA,IACN,gBAAgB,CAAC;AAAA,IACjB,QAAQ,CAAC;AAAA,IACT,QAAAF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAOA,MAAI,QAAQ,WAAW,SAAS,KAAK,SAAS,OAAO;AAOrD,MAAI;AACJ,MAAI,WAAW,YAAY;AACzB,yBAAqB,KAAK,UAAU;AAAA,EACtC;AACA,SAAO;AAGP,WAAS,MAAM,OAAO;AACpB,aAAS,KAAK,QAAQ,KAAK;AAC3B,SAAK;AAGL,QAAI,OAAO,OAAO,SAAS,CAAC,MAAM,MAAM;AACtC,aAAO,CAAC;AAAA,IACV;AACA,cAAU,YAAY,CAAC;AAGvB,YAAQ,SAAS,WAAW,sBAAsB,QAAQ,QAAQ,OAAO;AACzE,WAAO,QAAQ;AAAA,EACjB;AAOA,WAAS,eAAe,OAAO,YAAY;AACzC,WAAO,gBAAgB,YAAY,KAAK,GAAG,UAAU;AAAA,EACvD;AAGA,WAAS,YAAY,OAAO;AAC1B,WAAO,YAAY,QAAQ,KAAK;AAAA,EAClC;AAGA,WAAS,MAAM;AAEb,UAAM,EAAC,MAAM,QAAQ,QAAQ,QAAQ,aAAY,IAAIC;AACrD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,WAAS,WAAW,OAAO;AACzB,gBAAY,MAAM,IAAI,IAAI,MAAM;AAChC,4BAAwB;AAAA,EAC1B;AAgBA,WAAS,OAAO;AAEd,QAAI;AACJ,WAAOA,OAAM,SAAS,OAAO,QAAQ;AACnC,YAAM,QAAQ,OAAOA,OAAM,MAAM;AAGjC,UAAI,OAAO,UAAU,UAAU;AAC7B,qBAAaA,OAAM;AACnB,YAAIA,OAAM,eAAe,GAAG;AAC1B,UAAAA,OAAM,eAAe;AAAA,QACvB;AACA,eACEA,OAAM,WAAW,cACjBA,OAAM,eAAe,MAAM,QAC3B;AACA,aAAG,MAAM,WAAWA,OAAM,YAAY,CAAC;AAAA,QACzC;AAAA,MACF,OAAO;AACL,WAAG,KAAK;AAAA,MACV;AAAA,IACF;AAAA,EACF;AAQA,WAAS,GAAGE,OAAM;AAChB,eAAW;AACX,mBAAeA;AACf,YAAQ,MAAMA,KAAI;AAAA,EACpB;AAGA,WAAS,QAAQA,OAAM;AACrB,QAAI,mBAAmBA,KAAI,GAAG;AAC5B,MAAAF,OAAM;AACN,MAAAA,OAAM,SAAS;AACf,MAAAA,OAAM,UAAUE,UAAS,KAAK,IAAI;AAClC,8BAAwB;AAAA,IAC1B,WAAWA,UAAS,IAAI;AACtB,MAAAF,OAAM;AACN,MAAAA,OAAM;AAAA,IACR;AAGA,QAAIA,OAAM,eAAe,GAAG;AAC1B,MAAAA,OAAM;AAAA,IACR,OAAO;AACL,MAAAA,OAAM;AAKN,UAAIA,OAAM,iBAAiB,OAAOA,OAAM,MAAM,EAAE,QAAQ;AACtD,QAAAA,OAAM,eAAe;AACrB,QAAAA,OAAM;AAAA,MACR;AAAA,IACF;AAGA,YAAQ,WAAWE;AAGnB,eAAW;AAAA,EACb;AAGA,WAAS,MAAM,MAAM,QAAQ;AAG3B,UAAM,QAAQ,UAAU,CAAC;AACzB,UAAM,OAAO;AACb,UAAM,QAAQ,IAAI;AAClB,YAAQ,OAAO,KAAK,CAAC,SAAS,OAAO,OAAO,CAAC;AAC7C,UAAM,KAAK,KAAK;AAChB,WAAO;AAAA,EACT;AAGA,WAASD,MAAK,MAAM;AAClB,UAAM,QAAQ,MAAM,IAAI;AACxB,UAAM,MAAM,IAAI;AAChB,YAAQ,OAAO,KAAK,CAAC,QAAQ,OAAO,OAAO,CAAC;AAC5C,WAAO;AAAA,EACT;AAOA,WAAS,sBAAsB,WAAW,MAAM;AAC9C,cAAU,WAAW,KAAK,IAAI;AAAA,EAChC;AAOA,WAAS,kBAAkB,GAAG,MAAM;AAClC,SAAK,QAAQ;AAAA,EACf;AAQA,WAAS,iBAAiB,UAAU,QAAQ;AAC1C,WAAO;AAWP,aAAS,KAAKE,aAAY,aAAa,YAAY;AAEjD,UAAI;AAEJ,UAAI;AAEJ,UAAI;AAEJ,UAAI;AACJ,aAAO,MAAM,QAAQA,WAAU,IAC3B,uBAAuBA,WAAU,IACjC,cAAcA;AAAA;AAAA,QAEd,uBAAuB,CAACA,WAAU,CAAC;AAAA,UACnC,sBAAsBA,WAAU;AAQpC,eAAS,sBAAsBC,MAAK;AAClC,eAAO;AAGP,iBAAS,MAAMF,OAAM;AACnB,gBAAM,MAAMA,UAAS,QAAQE,KAAIF,KAAI;AACrC,gBAAMG,OAAMH,UAAS,QAAQE,KAAI;AACjC,gBAAME,QAAO;AAAA;AAAA;AAAA,YAGX,GAAI,MAAM,QAAQ,GAAG,IAAI,MAAM,MAAM,CAAC,GAAG,IAAI,CAAC;AAAA,YAC9C,GAAI,MAAM,QAAQD,IAAG,IAAIA,OAAMA,OAAM,CAACA,IAAG,IAAI,CAAC;AAAA,UAChD;AACA,iBAAO,uBAAuBC,KAAI,EAAEJ,KAAI;AAAA,QAC1C;AAAA,MACF;AAQA,eAAS,uBAAuBI,OAAM;AACpC,2BAAmBA;AACnB,yBAAiB;AACjB,YAAIA,MAAK,WAAW,GAAG;AACrB,iBAAO;AAAA,QACT;AACA,eAAO,gBAAgBA,MAAK,cAAc,CAAC;AAAA,MAC7C;AAQA,eAAS,gBAAgB,WAAW;AAClC,eAAO;AAGP,iBAAS,MAAMJ,OAAM;AAKnB,iBAAO,MAAM;AACb,6BAAmB;AACnB,cAAI,CAAC,UAAU,SAAS;AACtB,oBAAQ,mBAAmB;AAAA,UAC7B;AAIA,cACE,UAAU,QACV,QAAQ,OAAO,WAAW,QAAQ,KAAK,SAAS,UAAU,IAAI,GAC9D;AACA,mBAAO,IAAIA,KAAI;AAAA,UACjB;AACA,iBAAO,UAAU,SAAS;AAAA;AAAA;AAAA;AAAA,YAIxB,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,GAAG,MAAM,IAAI;AAAA,YACzD;AAAA,YACAK;AAAA,YACA;AAAA,UACF,EAAEL,KAAI;AAAA,QACR;AAAA,MACF;AAGA,eAASK,IAAGL,OAAM;AAChB,mBAAW;AACX,iBAAS,kBAAkB,IAAI;AAC/B,eAAO;AAAA,MACT;AAGA,eAAS,IAAIA,OAAM;AACjB,mBAAW;AACX,aAAK,QAAQ;AACb,YAAI,EAAE,iBAAiB,iBAAiB,QAAQ;AAC9C,iBAAO,gBAAgB,iBAAiB,cAAc,CAAC;AAAA,QACzD;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAOA,WAAS,UAAU,WAAWM,OAAM;AAClC,QAAI,UAAU,cAAc,CAAC,qBAAqB,SAAS,SAAS,GAAG;AACrE,2BAAqB,KAAK,SAAS;AAAA,IACrC;AACA,QAAI,UAAU,SAAS;AACrB;AAAA,QACE,QAAQ;AAAA,QACRA;AAAA,QACA,QAAQ,OAAO,SAASA;AAAA,QACxB,UAAU,QAAQ,QAAQ,OAAO,MAAMA,KAAI,GAAG,OAAO;AAAA,MACvD;AAAA,IACF;AACA,QAAI,UAAU,WAAW;AACvB,cAAQ,SAAS,UAAU,UAAU,QAAQ,QAAQ,OAAO;AAAA,IAC9D;AAAA,EACF;AAOA,WAAS,QAAQ;AACf,UAAM,aAAa,IAAI;AACvB,UAAM,gBAAgB,QAAQ;AAC9B,UAAM,wBAAwB,QAAQ;AACtC,UAAM,mBAAmB,QAAQ,OAAO;AACxC,UAAM,aAAa,MAAM,KAAK,KAAK;AACnC,WAAO;AAAA,MACL;AAAA,MACA,MAAM;AAAA,IACR;AAOA,aAAS,UAAU;AACjB,MAAAR,SAAQ;AACR,cAAQ,WAAW;AACnB,cAAQ,mBAAmB;AAC3B,cAAQ,OAAO,SAAS;AACxB,cAAQ;AACR,8BAAwB;AAAA,IAC1B;AAAA,EACF;AAQA,WAAS,0BAA0B;AACjC,QAAIA,OAAM,QAAQ,eAAeA,OAAM,SAAS,GAAG;AACjD,MAAAA,OAAM,SAAS,YAAYA,OAAM,IAAI;AACrC,MAAAA,OAAM,UAAU,YAAYA,OAAM,IAAI,IAAI;AAAA,IAC5C;AAAA,EACF;AACF;AASA,SAAS,YAAY,QAAQ,OAAO;AAClC,QAAM,aAAa,MAAM,MAAM;AAC/B,QAAM,mBAAmB,MAAM,MAAM;AACrC,QAAM,WAAW,MAAM,IAAI;AAC3B,QAAM,iBAAiB,MAAM,IAAI;AAEjC,MAAI;AACJ,MAAI,eAAe,UAAU;AAE3B,WAAO,CAAC,OAAO,UAAU,EAAE,MAAM,kBAAkB,cAAc,CAAC;AAAA,EACpE,OAAO;AACL,WAAO,OAAO,MAAM,YAAY,QAAQ;AACxC,QAAI,mBAAmB,IAAI;AACzB,YAAM,OAAO,KAAK,CAAC;AACnB,UAAI,OAAO,SAAS,UAAU;AAC5B,aAAK,CAAC,IAAI,KAAK,MAAM,gBAAgB;AAAA,MACvC,OAAO;AACL,aAAK,MAAM;AAAA,MACb;AAAA,IACF;AACA,QAAI,iBAAiB,GAAG;AAEtB,WAAK,KAAK,OAAO,QAAQ,EAAE,MAAM,GAAG,cAAc,CAAC;AAAA,IACrD;AAAA,EACF;AACA,SAAO;AACT;AASA,SAAS,gBAAgB,QAAQ,YAAY;AAC3C,MAAIS,SAAQ;AAEZ,QAAM,SAAS,CAAC;AAEhB,MAAI;AACJ,SAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,UAAM,QAAQ,OAAOA,MAAK;AAE1B,QAAI;AACJ,QAAI,OAAO,UAAU,UAAU;AAC7B,cAAQ;AAAA,IACV;AACE,cAAQ,OAAO;AAAA,QACb,KAAK,IAAI;AACP,kBAAQ;AACR;AAAA,QACF;AAAA,QACA,KAAK,IAAI;AACP,kBAAQ;AACR;AAAA,QACF;AAAA,QACA,KAAK,IAAI;AACP,kBAAQ;AACR;AAAA,QACF;AAAA,QACA,KAAK,IAAI;AACP,kBAAQ,aAAa,MAAM;AAC3B;AAAA,QACF;AAAA,QACA,KAAK,IAAI;AACP,cAAI,CAAC,cAAc;AAAO;AAC1B,kBAAQ;AACR;AAAA,QACF;AAAA,QACA,SAAS;AAEP,kBAAQ,OAAO,aAAa,KAAK;AAAA,QACnC;AAAA,MACF;AACF,YAAQ,UAAU;AAClB,WAAO,KAAK,KAAK;AAAA,EACnB;AACA,SAAO,OAAO,KAAK,EAAE;AACvB;;;ACrkBA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA;AAAA;AAAA,gBAAAC;AAAA,EAAA,YAAAC;AAAA;AAAA;AA6BO,IAAMC,YAAW;AAAA,EACtB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AACR;AAGO,IAAM,iBAAiB;AAAA,EAC5B,CAAC,EAAE,GAAG;AACR;AAGO,IAAM,cAAc;AAAA,EACzB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AACR;AAGO,IAAMC,QAAO;AAAA,EAClB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG,CAAC,iBAAiB,aAAa;AAAA,EACrC,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,GAAG,GAAG;AACT;AAGO,IAAMC,UAAS;AAAA,EACpB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AACR;AAGO,IAAMC,QAAO;AAAA,EAClB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG,CAAC,UAAU,QAAQ;AAAA,EACzB,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG,CAAC,iBAAiB,eAAe;AAAA,EACvC,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AAAA,EACN,CAAC,EAAE,GAAG;AACR;AAGO,IAAM,aAAa;AAAA,EACxB,MAAM,CAAC,WAAW,QAAW;AAC/B;AAGO,IAAM,mBAAmB;AAAA,EAC9B,MAAM,CAAC,IAAI,EAAE;AACf;AAGO,IAAM,UAAU;AAAA,EACrB,MAAM,CAAC;AACT;;;ANrFO,SAAS,MAAM,SAAS;AAC7B,QAAM,WAAW,WAAW,CAAC;AAC7B,QAAMC;AAAA;AAAA,IAEJ,kBAAkB,CAAC,oBAAmB,GAAI,SAAS,cAAc,CAAC,CAAE,CAAC;AAAA;AAGvE,QAAMC,UAAS;AAAA,IACb,SAAS,CAAC;AAAA,IACV,MAAM,CAAC;AAAA,IACP,YAAAD;AAAA,IACA,SAASE,QAAOC,QAAO;AAAA,IACvB,UAAUD,QAAOE,SAAQ;AAAA,IACzB,MAAMF,QAAO,IAAI;AAAA,IACjB,QAAQA,QAAO,MAAM;AAAA,IACrB,MAAMA,QAAOG,KAAI;AAAA,EACnB;AACA,SAAOJ;AAKP,WAASC,QAAO,SAAS;AACvB,WAAO;AAEP,aAAS,QAAQ,MAAM;AACrB,aAAO,gBAAgBD,SAAQ,SAAS,IAAI;AAAA,IAC9C;AAAA,EACF;AACF;;;AOjDA;AAeA,IAAM,SAAS;AAKR,SAAS,aAAa;AAC3B,MAAI,SAAS;AACb,MAAIK,UAAS;AAEb,MAAI,QAAQ;AAEZ,MAAI;AACJ,SAAO;AAGP,WAAS,aAAa,OAAO,UAAU,KAAK;AAE1C,UAAM,SAAS,CAAC;AAEhB,QAAI;AAEJ,QAAI;AAEJ,QAAI;AAEJ,QAAI;AAEJ,QAAIC;AAGJ,YAAQD,UAAS,MAAM,SAAS,QAAQ;AACxC,oBAAgB;AAChB,IAAAA,UAAS;AACT,QAAI,OAAO;AAET,UAAI,MAAM,WAAW,CAAC,MAAM,OAAO;AACjC;AAAA,MACF;AACA,cAAQ;AAAA,IACV;AACA,WAAO,gBAAgB,MAAM,QAAQ;AACnC,aAAO,YAAY;AACnB,cAAQ,OAAO,KAAK,KAAK;AACzB,oBACE,SAAS,MAAM,UAAU,SAAY,MAAM,QAAQ,MAAM;AAC3D,MAAAC,QAAO,MAAM,WAAW,WAAW;AACnC,UAAI,CAAC,OAAO;AACV,QAAAD,UAAS,MAAM,MAAM,aAAa;AAClC;AAAA,MACF;AACA,UAAIC,UAAS,MAAM,kBAAkB,eAAe,kBAAkB;AACpE,eAAO,KAAK,EAAE;AACd,2BAAmB;AAAA,MACrB,OAAO;AACL,YAAI,kBAAkB;AACpB,iBAAO,KAAK,EAAE;AACd,6BAAmB;AAAA,QACrB;AACA,YAAI,gBAAgB,aAAa;AAC/B,iBAAO,KAAK,MAAM,MAAM,eAAe,WAAW,CAAC;AACnD,oBAAU,cAAc;AAAA,QAC1B;AACA,gBAAQA,OAAM;AAAA,UACZ,KAAK,GAAG;AACN,mBAAO,KAAK,KAAK;AACjB;AACA;AAAA,UACF;AAAA,UACA,KAAK,GAAG;AACN,mBAAO,KAAK,KAAK,SAAS,CAAC,IAAI;AAC/B,mBAAO,KAAK,EAAE;AACd,mBAAO,WAAW;AAAM,qBAAO,KAAK,EAAE;AACtC;AAAA,UACF;AAAA,UACA,KAAK,IAAI;AACP,mBAAO,KAAK,EAAE;AACd,qBAAS;AACT;AAAA,UACF;AAAA,UACA,SAAS;AACP,+BAAmB;AACnB,qBAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF;AACA,sBAAgB,cAAc;AAAA,IAChC;AACA,QAAI,KAAK;AACP,UAAI;AAAkB,eAAO,KAAK,EAAE;AACpC,UAAID;AAAQ,eAAO,KAAKA,OAAM;AAC9B,aAAO,KAAK,IAAI;AAAA,IAClB;AACA,WAAO;AAAA,EACT;AACF;;;AC7GA;AAUO,SAAS,YAAY,QAAQ;AAClC,SAAO,CAAC,YAAY,MAAM,GAAG;AAAA,EAE7B;AACA,SAAO;AACT;;;ACfA;;;ACAA;AAoCO,SAAS,kBAAkB,OAAO;AAEvC,MAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACvC,WAAO;AAAA,EACT;AAGA,MAAI,cAAc,SAAS,UAAU,OAAO;AAC1C,WAAO,SAAS,MAAM,QAAQ;AAAA,EAChC;AAGA,MAAI,WAAW,SAAS,SAAS,OAAO;AACtC,WAAO,SAAS,KAAK;AAAA,EACvB;AAGA,MAAI,UAAU,SAAS,YAAY,OAAO;AACxC,WAAO,MAAM,KAAK;AAAA,EACpB;AAGA,SAAO;AACT;AAMA,SAAS,MAAME,QAAO;AACpB,SAAO,MAAMA,UAASA,OAAM,IAAI,IAAI,MAAM,MAAMA,UAASA,OAAM,MAAM;AACvE;AAMA,SAAS,SAAS,KAAK;AACrB,SAAO,MAAM,OAAO,IAAI,KAAK,IAAI,MAAM,MAAM,OAAO,IAAI,GAAG;AAC7D;AAMA,SAAS,MAAM,OAAO;AACpB,SAAO,SAAS,OAAO,UAAU,WAAW,QAAQ;AACtD;;;AbwEA,IAAMC,OAAM,CAAC,EAAE;AAYR,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcX,SAAU,OAAO,UAAU,SAAS;AAClC,QAAI,OAAO,aAAa,UAAU;AAChC,gBAAU;AACV,iBAAW;AAAA,IACb;AACA,WAAO,SAAS,OAAO;AAAA,MACrB;AAAA,QACE,MAAM,OAAO,EAAE,SAAS,EAAE,MAAM,WAAW,EAAE,OAAO,UAAU,IAAI,CAAC;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAAA;AAOF,SAAS,SAAS,SAAS;AAEzB,QAAM,SAAS;AAAA,IACb,YAAY,CAAC;AAAA,IACb,gBAAgB,CAAC,YAAY,YAAY,WAAW,aAAa,QAAQ;AAAA,IACzE,OAAO;AAAA,MACL,UAAU,OAAO,IAAI;AAAA,MACrB,kBAAkB;AAAA,MAClB,eAAe;AAAA,MACf,YAAY,OAAO,OAAO;AAAA,MAC1B,YAAY,OAAOC,WAAU;AAAA,MAC7B,iBAAiB;AAAA,MACjB,oBAAoB;AAAA,MACpB,YAAY,OAAO,QAAQ;AAAA,MAC3B,qBAAqBC;AAAA,MACrB,qBAAqBA;AAAA,MACrB,cAAc,OAAO,UAAUA,OAAM;AAAA,MACrC,UAAU,OAAOC,WAAUD,OAAM;AAAA,MACjC,cAAc;AAAA,MACd,MAAM;AAAA,MACN,eAAe;AAAA,MACf,YAAY,OAAOE,WAAU;AAAA,MAC7B,6BAA6BF;AAAA,MAC7B,uBAAuBA;AAAA,MACvB,uBAAuBA;AAAA,MACvB,UAAU,OAAO,QAAQ;AAAA,MACzB,iBAAiB,OAAO,SAAS;AAAA,MACjC,mBAAmB,OAAO,SAAS;AAAA,MACnC,UAAU,OAAO,MAAMA,OAAM;AAAA,MAC7B,cAAc;AAAA,MACd,UAAU,OAAO,MAAMA,OAAM;AAAA,MAC7B,cAAc;AAAA,MACd,OAAO,OAAO,KAAK;AAAA,MACnB,OAAOA;AAAA,MACP,MAAM,OAAO,IAAI;AAAA,MACjB,UAAU,OAAOG,SAAQ;AAAA,MACzB,eAAe;AAAA,MACf,aAAa,OAAOC,OAAM,kBAAkB;AAAA,MAC5C,eAAe,OAAOA,KAAI;AAAA,MAC1B,WAAW,OAAO,SAAS;AAAA,MAC3B,WAAW;AAAA,MACX,iBAAiBJ;AAAA,MACjB,2BAA2BA;AAAA,MAC3B,qBAAqBA;AAAA,MACrB,eAAe,OAAO,OAAO;AAAA,MAC7B,QAAQ,OAAO,MAAM;AAAA,MACrB,eAAe,OAAOK,cAAa;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,MACJ,YAAY,OAAO;AAAA,MACnB,oBAAoB;AAAA,MACpB,UAAU,OAAO;AAAA,MACjB,eAAe;AAAA,MACf,kBAAkB;AAAA,MAClB,YAAY,OAAO;AAAA,MACnB,sBAAsB;AAAA,MACtB,qCAAqC;AAAA,MACrC,iCAAiC;AAAA,MACjC,yBAAyB;AAAA,MACzB,YAAY,OAAO,gBAAgB;AAAA,MACnC,iBAAiB;AAAA,MACjB,qBAAqB;AAAA,MACrB,qBAAqB;AAAA,MACrB,eAAe;AAAA,MACf,cAAc,OAAO,kBAAkB;AAAA,MACvC,UAAU,OAAO,cAAc;AAAA,MAC/B,cAAc;AAAA,MACd,MAAM;AAAA,MACN,YAAY,OAAO;AAAA,MACnB,6BAA6B;AAAA,MAC7B,uBAAuB;AAAA,MACvB,uBAAuB;AAAA,MACvB,UAAU,OAAO;AAAA,MACjB,iBAAiB,OAAO,eAAe;AAAA,MACvC,mBAAmB,OAAO,eAAe;AAAA,MACzC,UAAU,OAAO,cAAc;AAAA,MAC/B,cAAc;AAAA,MACd,UAAU,OAAO,cAAc;AAAA,MAC/B,cAAc;AAAA,MACd,OAAO,OAAO,WAAW;AAAA,MACzB,OAAO;AAAA,MACP,WAAW;AAAA,MACX,YAAY;AAAA,MACZ,MAAM,OAAO,UAAU;AAAA,MACvB,UAAU,OAAO;AAAA,MACjB,aAAa,OAAO;AAAA,MACpB,eAAe,OAAO;AAAA,MACtB,WAAW,OAAO;AAAA,MAClB,iBAAiB;AAAA,MACjB,2BAA2B;AAAA,MAC3B,qBAAqB;AAAA,MACrB,UAAU;AAAA,MACV,eAAe,OAAO,mBAAmB;AAAA,MACzC,2BAA2B;AAAA,MAC3B,mBAAmB;AAAA,MACnB,QAAQ,OAAO;AAAA,MACf,eAAe,OAAO;AAAA,IACxB;AAAA,EACF;AACA,YAAU,SAAS,WAAW,CAAC,GAAG,mBAAmB,CAAC,CAAC;AAGvD,QAAMC,QAAO,CAAC;AACd,SAAO;AAUP,WAAS,QAAQ,QAAQ;AAEvB,QAAI,OAAO;AAAA,MACT,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb;AAEA,UAAM,UAAU;AAAA,MACd,OAAO,CAAC,IAAI;AAAA,MACZ,YAAY,CAAC;AAAA,MACb;AAAA,MACA;AAAA,MACA,MAAAC;AAAA,MACA,QAAAP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,YAAY,CAAC;AACnB,QAAIQ,SAAQ;AACZ,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAG9B,UACE,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,iBAC1B,OAAOA,MAAK,EAAE,CAAC,EAAE,SAAS,iBAC1B;AACA,YAAI,OAAOA,MAAK,EAAE,CAAC,MAAM,SAAS;AAChC,oBAAU,KAAKA,MAAK;AAAA,QACtB,OAAO;AACL,gBAAM,OAAO,UAAU,IAAI;AAC3B,UAAAA,SAAQ,YAAY,QAAQ,MAAMA,MAAK;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AACA,IAAAA,SAAQ;AACR,WAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,YAAM,UAAU,OAAO,OAAOA,MAAK,EAAE,CAAC,CAAC;AACvC,UAAIV,KAAI,KAAK,SAAS,OAAOU,MAAK,EAAE,CAAC,EAAE,IAAI,GAAG;AAC5C,gBAAQ,OAAOA,MAAK,EAAE,CAAC,EAAE,IAAI,EAAE;AAAA,UAC7B,OAAO;AAAA,YACL;AAAA,cACE,gBAAgB,OAAOA,MAAK,EAAE,CAAC,EAAE;AAAA,YACnC;AAAA,YACA;AAAA,UACF;AAAA,UACA,OAAOA,MAAK,EAAE,CAAC;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,QAAQ,WAAW,SAAS,GAAG;AACjC,YAAM,OAAO,QAAQ,WAAW,QAAQ,WAAW,SAAS,CAAC;AAC7D,YAAM,UAAU,KAAK,CAAC,KAAK;AAC3B,cAAQ,KAAK,SAAS,QAAW,KAAK,CAAC,CAAC;AAAA,IAC1C;AAGA,SAAK,WAAW;AAAA,MACd,OAAOC;AAAA,QACL,OAAO,SAAS,IACZ,OAAO,CAAC,EAAE,CAAC,EAAE,QACb;AAAA,UACE,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV;AAAA,MACN;AAAA,MACA,KAAKA;AAAA,QACH,OAAO,SAAS,IACZ,OAAO,OAAO,SAAS,CAAC,EAAE,CAAC,EAAE,MAC7B;AAAA,UACE,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,QAAQ;AAAA,QACV;AAAA,MACN;AAAA,IACF;AAGA,IAAAD,SAAQ;AACR,WAAO,EAAEA,SAAQ,OAAO,WAAW,QAAQ;AACzC,aAAO,OAAO,WAAWA,MAAK,EAAE,IAAI,KAAK;AAAA,IAC3C;AACA,WAAO;AAAA,EACT;AAQA,WAAS,YAAY,QAAQ,OAAO,QAAQ;AAC1C,QAAIA,SAAQ,QAAQ;AACpB,QAAI,mBAAmB;AACvB,QAAI,aAAa;AAEjB,QAAIL;AAEJ,QAAI;AAEJ,QAAI;AAEJ,QAAI;AACJ,WAAO,EAAEK,UAAS,QAAQ;AACxB,YAAM,QAAQ,OAAOA,MAAK;AAC1B,UACE,MAAM,CAAC,EAAE,SAAS,mBAClB,MAAM,CAAC,EAAE,SAAS,iBAClB,MAAM,CAAC,EAAE,SAAS,cAClB;AACA,YAAI,MAAM,CAAC,MAAM,SAAS;AACxB;AAAA,QACF,OAAO;AACL;AAAA,QACF;AACA,mBAAW;AAAA,MACb,WAAW,MAAM,CAAC,EAAE,SAAS,mBAAmB;AAC9C,YAAI,MAAM,CAAC,MAAM,SAAS;AACxB,cACEL,aACA,CAAC,YACD,CAAC,oBACD,CAAC,qBACD;AACA,kCAAsBK;AAAA,UACxB;AACA,qBAAW;AAAA,QACb;AAAA,MACF,WACE,MAAM,CAAC,EAAE,SAAS,gBAClB,MAAM,CAAC,EAAE,SAAS,mBAClB,MAAM,CAAC,EAAE,SAAS,oBAClB,MAAM,CAAC,EAAE,SAAS,oBAClB,MAAM,CAAC,EAAE,SAAS,4BAClB;AAAA,MAEF,OAAO;AACL,mBAAW;AAAA,MACb;AACA,UACG,CAAC,oBACA,MAAM,CAAC,MAAM,WACb,MAAM,CAAC,EAAE,SAAS,oBACnB,qBAAqB,MACpB,MAAM,CAAC,MAAM,WACZ,MAAM,CAAC,EAAE,SAAS,mBACjB,MAAM,CAAC,EAAE,SAAS,gBACtB;AACA,YAAIL,WAAU;AACZ,cAAI,YAAYK;AAChB,sBAAY;AACZ,iBAAO,aAAa;AAClB,kBAAM,YAAY,OAAO,SAAS;AAClC,gBACE,UAAU,CAAC,EAAE,SAAS,gBACtB,UAAU,CAAC,EAAE,SAAS,mBACtB;AACA,kBAAI,UAAU,CAAC,MAAM;AAAQ;AAC7B,kBAAI,WAAW;AACb,uBAAO,SAAS,EAAE,CAAC,EAAE,OAAO;AAC5B,6BAAa;AAAA,cACf;AACA,wBAAU,CAAC,EAAE,OAAO;AACpB,0BAAY;AAAA,YACd,WACE,UAAU,CAAC,EAAE,SAAS,gBACtB,UAAU,CAAC,EAAE,SAAS,sBACtB,UAAU,CAAC,EAAE,SAAS,gCACtB,UAAU,CAAC,EAAE,SAAS,sBACtB,UAAU,CAAC,EAAE,SAAS,kBACtB;AAAA,YAEF,OAAO;AACL;AAAA,YACF;AAAA,UACF;AACA,cACE,wBACC,CAAC,aAAa,sBAAsB,YACrC;AACA,YAAAL,UAAS,UAAU;AAAA,UACrB;AAGA,UAAAA,UAAS,MAAM,OAAO;AAAA,YACpB,CAAC;AAAA,YACD,YAAY,OAAO,SAAS,EAAE,CAAC,EAAE,QAAQ,MAAM,CAAC,EAAE;AAAA,UACpD;AACA,iBAAO,OAAO,aAAaK,QAAO,GAAG,CAAC,QAAQL,WAAU,MAAM,CAAC,CAAC,CAAC;AACjE,UAAAK;AACA;AAAA,QACF;AAGA,YAAI,MAAM,CAAC,EAAE,SAAS,kBAAkB;AACtC,UAAAL,YAAW;AAAA,YACT,MAAM;AAAA,YACN,SAAS;AAAA,YACT,OAAO,OAAO,OAAO,CAAC,GAAG,MAAM,CAAC,EAAE,KAAK;AAAA;AAAA,YAEvC,KAAK;AAAA,UACP;AAEA,iBAAO,OAAOK,QAAO,GAAG,CAAC,SAASL,WAAU,MAAM,CAAC,CAAC,CAAC;AACrD,UAAAK;AACA;AACA,gCAAsB;AACtB,qBAAW;AAAA,QACb;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK,EAAE,CAAC,EAAE,UAAU;AAC3B,WAAO;AAAA,EACT;AAcA,WAAS,QAAQE,MAAK,OAAO;AAC3B,IAAAJ,MAAKI,IAAG,IAAI;AAAA,EACd;AAYA,WAAS,QAAQA,MAAK;AACpB,WAAOJ,MAAKI,IAAG;AAAA,EACjB;AAYA,WAAS,OAAOC,SAAQ,KAAK;AAC3B,WAAO;AAOP,aAAS,KAAK,OAAO;AACnB,YAAM,KAAK,MAAMA,QAAO,KAAK,GAAG,KAAK;AACrC,UAAI;AAAK,YAAI,KAAK,MAAM,KAAK;AAAA,IAC/B;AAAA,EACF;AAMA,WAASX,UAAS;AAChB,SAAK,MAAM,KAAK;AAAA,MACd,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb,CAAC;AAAA,EACH;AAgBA,WAAS,MAAMY,OAAM,OAAO,cAAc;AACxC,UAAM,SAAS,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAE/C,WAAO,SAAS,KAAKA,KAAI;AACzB,SAAK,MAAM,KAAKA,KAAI;AACpB,SAAK,WAAW,KAAK,CAAC,OAAO,YAAY,CAAC;AAE1C,IAAAA,MAAK,WAAW;AAAA,MACd,OAAOH,OAAM,MAAM,KAAK;AAAA,IAC1B;AACA,WAAOG;AAAA,EACT;AAUA,WAAS,OAAO,KAAK;AACnB,WAAO;AAOP,aAAS,MAAM,OAAO;AACpB,UAAI;AAAK,YAAI,KAAK,MAAM,KAAK;AAC7B,MAAAL,MAAK,KAAK,MAAM,KAAK;AAAA,IACvB;AAAA,EACF;AAYA,WAASA,MAAK,OAAO,aAAa;AAChC,UAAMK,QAAO,KAAK,MAAM,IAAI;AAC5B,UAAM,OAAO,KAAK,WAAW,IAAI;AACjC,QAAI,CAAC,MAAM;AACT,YAAM,IAAI;AAAA,QACR,mBACE,MAAM,OACN,QACA,kBAAkB;AAAA,UAChB,OAAO,MAAM;AAAA,UACb,KAAK,MAAM;AAAA,QACb,CAAC,IACD;AAAA,MACJ;AAAA,IACF,WAAW,KAAK,CAAC,EAAE,SAAS,MAAM,MAAM;AACtC,UAAI,aAAa;AACf,oBAAY,KAAK,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,MACvC,OAAO;AACL,cAAM,UAAU,KAAK,CAAC,KAAK;AAC3B,gBAAQ,KAAK,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,MACnC;AAAA,IACF;AACA,IAAAA,MAAK,SAAS,MAAMH,OAAM,MAAM,GAAG;AACnC,WAAOG;AAAA,EACT;AAMA,WAAS,SAAS;AAChB,WAAO,SAAS,KAAK,MAAM,IAAI,CAAC;AAAA,EAClC;AAUA,WAAS,qBAAqB;AAC5B,YAAQ,+BAA+B,IAAI;AAAA,EAC7C;AAMA,WAAS,qBAAqB,OAAO;AACnC,QAAI,QAAQ,6BAA6B,GAAG;AAC1C,YAAM,WAAW,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AACjD,eAAS,QAAQ,OAAO,SAAS,KAAK,eAAe,KAAK,GAAG,EAAE;AAC/D,cAAQ,6BAA6B;AAAA,IACvC;AAAA,EACF;AAMA,WAAS,4BAA4B;AACnC,UAAMN,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,OAAON;AAAA,EACd;AAMA,WAAS,4BAA4B;AACnC,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,OAAON;AAAA,EACd;AAMA,WAAS,wBAAwB;AAE/B,QAAI,QAAQ,gBAAgB;AAAG;AAC/B,SAAK,OAAO;AACZ,YAAQ,kBAAkB,IAAI;AAAA,EAChC;AAMA,WAAS,mBAAmB;AAC1B,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN,MAAK,QAAQ,4BAA4B,EAAE;AACxD,YAAQ,gBAAgB;AAAA,EAC1B;AAMA,WAAS,qBAAqB;AAC5B,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN,MAAK,QAAQ,gBAAgB,EAAE;AAAA,EAC9C;AAMA,WAAS,4BAA4B,OAAO;AAC1C,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQ;AACb,IAAAA,MAAK,aAAa;AAAA,MAChB,KAAK,eAAe,KAAK;AAAA,IAC3B,EAAE,YAAY;AAAA,EAChB;AAMA,WAAS,8BAA8B;AACrC,UAAMN,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN;AAAA,EACf;AAMA,WAAS,oCAAoC;AAC3C,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,MAAMN;AAAA,EACb;AAMA,WAAS,yBAAyB,OAAO;AACvC,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,QAAI,CAACA,MAAK,OAAO;AACf,YAAM,QAAQ,KAAK,eAAe,KAAK,EAAE;AACzC,MAAAA,MAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAMA,WAAS,0BAA0B;AACjC,YAAQ,gCAAgC,IAAI;AAAA,EAC9C;AAMA,WAAS,gCAAgC,OAAO;AAC9C,UAAMA,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQ,KAAK,eAAe,KAAK,EAAE,WAAW,CAAC,MAAM,KAAK,IAAI;AAAA,EACrE;AAMA,WAAS,sBAAsB;AAC7B,YAAQ,8BAA8B;AAAA,EACxC;AAOA,WAAS,YAAY,OAAO;AAC1B,UAAMA,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,QAAI,OAAOA,MAAK,SAASA,MAAK,SAAS,SAAS,CAAC;AACjD,QAAI,CAAC,QAAQ,KAAK,SAAS,QAAQ;AAEjC,aAAOC,MAAK;AAEZ,WAAK,WAAW;AAAA,QACd,OAAOJ,OAAM,MAAM,KAAK;AAAA,MAC1B;AAEA,MAAAG,MAAK,SAAS,KAAK,IAAI;AAAA,IACzB;AACA,SAAK,MAAM,KAAK,IAAI;AAAA,EACtB;AAOA,WAAS,WAAW,OAAO;AACzB,UAAM,OAAO,KAAK,MAAM,IAAI;AAC5B,SAAK,SAAS,KAAK,eAAe,KAAK;AACvC,SAAK,SAAS,MAAMH,OAAM,MAAM,GAAG;AAAA,EACrC;AAOA,WAAS,iBAAiB,OAAO;AAC/B,UAAM,UAAU,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAEhD,QAAI,QAAQ,aAAa,GAAG;AAC1B,YAAM,OAAO,QAAQ,SAAS,QAAQ,SAAS,SAAS,CAAC;AACzD,WAAK,SAAS,MAAMA,OAAM,MAAM,GAAG;AACnC,cAAQ,aAAa;AACrB;AAAA,IACF;AACA,QACE,CAAC,QAAQ,8BAA8B,KACvC,OAAO,eAAe,SAAS,QAAQ,IAAI,GAC3C;AACA,kBAAY,KAAK,MAAM,KAAK;AAC5B,iBAAW,KAAK,MAAM,KAAK;AAAA,IAC7B;AAAA,EACF;AAOA,WAAS,kBAAkB;AACzB,YAAQ,eAAe,IAAI;AAAA,EAC7B;AAOA,WAAS,iBAAiB;AACxB,UAAMH,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN;AAAA,EACf;AAOA,WAAS,iBAAiB;AACxB,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN;AAAA,EACf;AAOA,WAAS,iBAAiB;AACxB,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN;AAAA,EACf;AAOA,WAAS,aAAa;AACpB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAI7C,QAAI,QAAQ,aAAa,GAAG;AAE1B,YAAM,gBAAgB,QAAQ,eAAe,KAAK;AAClD,MAAAA,MAAK,QAAQ;AAEb,MAAAA,MAAK,gBAAgB;AAErB,aAAOA,MAAK;AACZ,aAAOA,MAAK;AAAA,IACd,OAAO;AAEL,aAAOA,MAAK;AAEZ,aAAOA,MAAK;AAAA,IACd;AACA,YAAQ,eAAe;AAAA,EACzB;AAOA,WAAS,cAAc;AACrB,UAAMA,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAI7C,QAAI,QAAQ,aAAa,GAAG;AAE1B,YAAM,gBAAgB,QAAQ,eAAe,KAAK;AAClD,MAAAA,MAAK,QAAQ;AAEb,MAAAA,MAAK,gBAAgB;AAErB,aAAOA,MAAK;AACZ,aAAOA,MAAK;AAAA,IACd,OAAO;AAEL,aAAOA,MAAK;AAEZ,aAAOA,MAAK;AAAA,IACd;AACA,YAAQ,eAAe;AAAA,EACzB;AAOA,WAAS,gBAAgB,OAAO;AAC9B,UAAME,UAAS,KAAK,eAAe,KAAK;AACxC,UAAM,WAAW,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAGjD,aAAS,QAAQ,aAAaA,OAAM;AAEpC,aAAS,aAAa,oBAAoBA,OAAM,EAAE,YAAY;AAAA,EAChE;AAOA,WAAS,cAAc;AACrB,UAAM,WAAW,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AACjD,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAMF,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAE7C,YAAQ,eAAe,IAAI;AAC3B,QAAIA,MAAK,SAAS,QAAQ;AAGxB,YAAM,WAAW,SAAS;AAC1B,MAAAA,MAAK,WAAW;AAAA,IAClB,OAAO;AACL,MAAAA,MAAK,MAAM;AAAA,IACb;AAAA,EACF;AAOA,WAAS,kCAAkC;AACzC,UAAMN,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,MAAMN;AAAA,EACb;AAOA,WAAS,4BAA4B;AACnC,UAAMA,QAAO,KAAK,OAAO;AACzB,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,QAAQN;AAAA,EACf;AAOA,WAAS,iBAAiB;AACxB,YAAQ,aAAa;AAAA,EACvB;AAOA,WAAS,mBAAmB;AAC1B,YAAQ,iBAAiB,WAAW;AAAA,EACtC;AAOA,WAAS,sBAAsB,OAAO;AACpC,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAMM,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAG7C,IAAAA,MAAK,QAAQ;AAEb,IAAAA,MAAK,aAAa;AAAA,MAChB,KAAK,eAAe,KAAK;AAAA,IAC3B,EAAE,YAAY;AACd,YAAQ,iBAAiB,MAAM;AAAA,EACjC;AAOA,WAAS,+BAA+B,OAAO;AAC7C,YAAQ,0BAA0B,MAAM,IAAI;AAAA,EAC9C;AAMA,WAAS,8BAA8B,OAAO;AAC5C,UAAMN,QAAO,KAAK,eAAe,KAAK;AACtC,UAAM,OAAO,QAAQ,wBAAwB;AAE7C,QAAI;AACJ,QAAI,MAAM;AACR,cAAQ;AAAA,QACNA;AAAA,QACA,SAAS,oCAAoC,KAAK;AAAA,MACpD;AACA,cAAQ,wBAAwB;AAAA,IAClC,OAAO;AACL,YAAM,SAAS,8BAA8BA,KAAI;AACjD,cAAQ;AAAA,IACV;AACA,UAAM,OAAO,KAAK,MAAM,IAAI;AAC5B,SAAK,SAAS;AACd,SAAK,SAAS,MAAMG,OAAM,MAAM,GAAG;AAAA,EACrC;AAMA,WAAS,uBAAuB,OAAO;AACrC,eAAW,KAAK,MAAM,KAAK;AAC3B,UAAMG,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,MAAM,KAAK,eAAe,KAAK;AAAA,EACtC;AAMA,WAAS,oBAAoB,OAAO;AAClC,eAAW,KAAK,MAAM,KAAK;AAC3B,UAAMA,QAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAC7C,IAAAA,MAAK,MAAM,YAAY,KAAK,eAAe,KAAK;AAAA,EAClD;AAOA,WAASb,cAAa;AACpB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAAS,WAAW;AAClB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,OAAO;AAAA,IACT;AAAA,EACF;AAGA,WAASE,YAAW;AAClB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,IACT;AAAA,EACF;AAGA,WAASC,cAAa;AACpB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,OAAO;AAAA,MACP,OAAO;AAAA,MACP,KAAK;AAAA,IACP;AAAA,EACF;AAGA,WAAS,WAAW;AAClB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAAS,UAAU;AAEjB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAAS,YAAY;AACnB,WAAO;AAAA,MACL,MAAM;AAAA,IACR;AAAA,EACF;AAGA,WAAS,OAAO;AACd,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,IACT;AAAA,EACF;AAGA,WAAS,QAAQ;AACf,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAGA,WAAS,OAAO;AACd,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAMA,WAASE,MAAK,OAAO;AACnB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,SAAS,MAAM,SAAS;AAAA,MACxB,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,MACd,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAMA,WAASD,UAAS,OAAO;AACvB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,MAAM;AAAA,MACd,SAAS;AAAA,MACT,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAAS,YAAY;AACnB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAAS,SAAS;AAChB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU,CAAC;AAAA,IACb;AAAA,EACF;AAGA,WAASU,QAAO;AACd,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,IACT;AAAA,EACF;AAGA,WAASR,iBAAgB;AACvB,WAAO;AAAA,MACL,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAUA,SAASI,OAAM,GAAG;AAChB,SAAO;AAAA,IACL,MAAM,EAAE;AAAA,IACR,QAAQ,EAAE;AAAA,IACV,QAAQ,EAAE;AAAA,EACZ;AACF;AAOA,SAAS,UAAU,UAAU,YAAY;AACvC,MAAID,SAAQ;AACZ,SAAO,EAAEA,SAAQ,WAAW,QAAQ;AAClC,UAAM,QAAQ,WAAWA,MAAK;AAC9B,QAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAU,UAAU,KAAK;AAAA,IAC3B,OAAO;AACL,gBAAU,UAAU,KAAK;AAAA,IAC3B;AAAA,EACF;AACF;AAOA,SAAS,UAAU,UAAUO,YAAW;AAEtC,MAAIL;AACJ,OAAKA,QAAOK,YAAW;AACrB,QAAIjB,KAAI,KAAKiB,YAAWL,IAAG,GAAG;AAC5B,UAAIA,SAAQ,kBAAkB;AAC5B,cAAM,QAAQK,WAAUL,IAAG;AAC3B,YAAI,OAAO;AACT,mBAASA,IAAG,EAAE,KAAK,GAAG,KAAK;AAAA,QAC7B;AAAA,MACF,WAAWA,SAAQ,cAAc;AAC/B,cAAM,QAAQK,WAAUL,IAAG;AAC3B,YAAI,OAAO;AACT,mBAASA,IAAG,EAAE,KAAK,GAAG,KAAK;AAAA,QAC7B;AAAA,MACF,WAAWA,SAAQ,WAAWA,SAAQ,QAAQ;AAC5C,cAAM,QAAQK,WAAUL,IAAG;AAC3B,YAAI,OAAO;AACT,iBAAO,OAAO,SAASA,IAAG,GAAG,KAAK;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAGA,SAAS,eAAe,MAAM,OAAO;AACnC,MAAI,MAAM;AACR,UAAM,IAAI;AAAA,MACR,mBACE,KAAK,OACL,QACA,kBAAkB;AAAA,QAChB,OAAO,KAAK;AAAA,QACZ,KAAK,KAAK;AAAA,MACZ,CAAC,IACD,4BACA,MAAM,OACN,QACA,kBAAkB;AAAA,QAChB,OAAO,MAAM;AAAA,QACb,KAAK,MAAM;AAAA,MACb,CAAC,IACD;AAAA,IACJ;AAAA,EACF,OAAO;AACL,UAAM,IAAI;AAAA,MACR,sCACE,MAAM,OACN,QACA,kBAAkB;AAAA,QAChB,OAAO,MAAM;AAAA,QACb,KAAK,MAAM;AAAA,MACb,CAAC,IACD;AAAA,IACJ;AAAA,EACF;AACF;;;AF91Ce,SAAR,YAA6B,SAAS;AAE3C,QAAMM,UAAS,CAAC,QAAQ;AAEtB,UAAM;AAAA;AAAA,MAAmC,KAAK,KAAK,UAAU;AAAA;AAE7D,WAAO;AAAA,MACL;AAAA,MACA,OAAO,OAAO,CAAC,GAAG,UAAU,SAAS;AAAA;AAAA;AAAA;AAAA,QAInC,YAAY,KAAK,KAAK,qBAAqB,KAAK,CAAC;AAAA,QACjD,iBAAiB,KAAK,KAAK,wBAAwB,KAAK,CAAC;AAAA,MAC3D,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO,OAAO,MAAM,EAAC,QAAQA,QAAM,CAAC;AACtC;;;ADzBA,IAAO,uBAAQ;;;AiBFf;;;ACAA;;;ACAA;AAOO,SAAS,KAAK,OAAO;AAC1B,MAAI,OAAO;AACT,UAAM;AAAA,EACR;AACF;;;ADUA,IAAAC,oBAAqB;AACrB,oBAAmB;;;AEtBnB;AAAe,SAAR,cAA+B,OAAO;AAC5C,MAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAChD,WAAO;AAAA,EACR;AAEA,QAAM,YAAY,OAAO,eAAe,KAAK;AAC7C,UAAQ,cAAc,QAAQ,cAAc,OAAO,aAAa,OAAO,eAAe,SAAS,MAAM,SAAS,EAAE,OAAO,eAAe,UAAU,EAAE,OAAO,YAAY;AACtK;;;ACPA;AAiBO,SAAS,SAAS;AAEvB,QAAM,MAAM,CAAC;AAEb,QAAM,WAAW,EAAC,KAAK,IAAG;AAE1B,SAAO;AAGP,WAAS,OAAO,QAAQ;AACtB,QAAI,kBAAkB;AAEtB,UAAM,WAAW,OAAO,IAAI;AAE5B,QAAI,OAAO,aAAa,YAAY;AAClC,YAAM,IAAI,UAAU,6CAA6C,QAAQ;AAAA,IAC3E;AAEA,SAAK,MAAM,GAAG,MAAM;AAQpB,aAAS,KAAK,UAAU,QAAQ;AAC9B,YAAM,KAAK,IAAI,EAAE,eAAe;AAChC,UAAIC,SAAQ;AAEZ,UAAI,OAAO;AACT,iBAAS,KAAK;AACd;AAAA,MACF;AAGA,aAAO,EAAEA,SAAQ,OAAO,QAAQ;AAC9B,YAAI,OAAOA,MAAK,MAAM,QAAQ,OAAOA,MAAK,MAAM,QAAW;AACzD,iBAAOA,MAAK,IAAI,OAAOA,MAAK;AAAA,QAC9B;AAAA,MACF;AAGA,eAAS;AAGT,UAAI,IAAI;AACN,aAAK,IAAI,IAAI,EAAE,GAAG,MAAM;AAAA,MAC1B,OAAO;AACL,iBAAS,MAAM,GAAG,MAAM;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAGA,WAAS,IAAI,YAAY;AACvB,QAAI,OAAO,eAAe,YAAY;AACpC,YAAM,IAAI;AAAA,QACR,iDAAiD;AAAA,MACnD;AAAA,IACF;AAEA,QAAI,KAAK,UAAU;AACnB,WAAO;AAAA,EACT;AACF;AAUO,SAAS,KAAK,YAAY,UAAU;AAEzC,MAAI;AAEJ,SAAO;AAQP,WAAS,WAAW,YAAY;AAC9B,UAAM,oBAAoB,WAAW,SAAS,WAAW;AAEzD,QAAI;AAEJ,QAAI,mBAAmB;AACrB,iBAAW,KAAK,IAAI;AAAA,IACtB;AAEA,QAAI;AACF,eAAS,WAAW,MAAM,MAAM,UAAU;AAAA,IAC5C,SAAS,OAAP;AACA,YAAM;AAAA;AAAA,QAAkC;AAAA;AAMxC,UAAI,qBAAqB,QAAQ;AAC/B,cAAM;AAAA,MACR;AAEA,aAAO,KAAK,SAAS;AAAA,IACvB;AAEA,QAAI,CAAC,mBAAmB;AACtB,UAAI,kBAAkB,SAAS;AAC7B,eAAO,KAAK,MAAM,IAAI;AAAA,MACxB,WAAW,kBAAkB,OAAO;AAClC,aAAK,MAAM;AAAA,MACb,OAAO;AACL,aAAK,MAAM;AAAA,MACb;AAAA,IACF;AAAA,EACF;AAMA,WAAS,KAAK,UAAU,QAAQ;AAC9B,QAAI,CAAC,QAAQ;AACX,eAAS;AACT,eAAS,OAAO,GAAG,MAAM;AAAA,IAC3B;AAAA,EACF;AAOA,WAAS,KAAK,OAAO;AACnB,SAAK,MAAM,KAAK;AAAA,EAClB;AACF;;;AC/JA;;;ACAA;AAqFA,uBAAuB;;;ACrFvB;;;ACAA;AAYO,IAAM,eAAN,cAA2B,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBtC,YAAY,QAAQ,OAAO,QAAQ;AAEjC,UAAM,QAAQ,CAAC,MAAM,IAAI;AAEzB,QAAIC,YAAW;AAAA;AAAA,MAEb,OAAO,EAAC,MAAM,MAAM,QAAQ,KAAI;AAAA;AAAA,MAEhC,KAAK,EAAC,MAAM,MAAM,QAAQ,KAAI;AAAA,IAChC;AAEA,UAAM;AAEN,QAAI,OAAO,UAAU,UAAU;AAC7B,eAAS;AACT,cAAQ;AAAA,IACV;AAEA,QAAI,OAAO,WAAW,UAAU;AAC9B,YAAMC,SAAQ,OAAO,QAAQ,GAAG;AAEhC,UAAIA,WAAU,IAAI;AAChB,cAAM,CAAC,IAAI;AAAA,MACb,OAAO;AACL,cAAM,CAAC,IAAI,OAAO,MAAM,GAAGA,MAAK;AAChC,cAAM,CAAC,IAAI,OAAO,MAAMA,SAAQ,CAAC;AAAA,MACnC;AAAA,IACF;AAEA,QAAI,OAAO;AAET,UAAI,UAAU,SAAS,cAAc,OAAO;AAC1C,YAAI,MAAM,UAAU;AAGlB,UAAAD,YAAW,MAAM;AAAA,QACnB;AAAA,MACF,WAES,WAAW,SAAS,SAAS,OAAO;AAG3C,QAAAA,YAAW;AAAA,MACb,WAES,UAAU,SAAS,YAAY,OAAO;AAE7C,QAAAA,UAAS,QAAQ;AAAA,MACnB;AAAA,IACF;AASA,SAAK,OAAO,kBAAkB,KAAK,KAAK;AAOxC,SAAK,UAAU,OAAO,WAAW,WAAW,OAAO,UAAU;AAU7D,SAAK,QAAQ;AAEb,QAAI,OAAO,WAAW,YAAY,OAAO,OAAO;AAC9C,WAAK,QAAQ,OAAO;AAAA,IACtB;AASA,SAAK,SAAS,KAAK;AAYnB,SAAK;AAOL,SAAK,OAAOA,UAAS,MAAM;AAO3B,SAAK,SAASA,UAAS,MAAM;AAO7B,SAAK,WAAWA;AAOhB,SAAK,SAAS,MAAM,CAAC;AAOrB,SAAK,SAAS,MAAM,CAAC;AAOrB,SAAK;AAYL,SAAK;AAOL,SAAK;AAUL,SAAK;AAOL,SAAK;AAAA,EAEP;AACF;AAEA,aAAa,UAAU,OAAO;AAC9B,aAAa,UAAU,OAAO;AAC9B,aAAa,UAAU,SAAS;AAChC,aAAa,UAAU,UAAU;AACjC,aAAa,UAAU,QAAQ;AAC/B,aAAa,UAAU,QAAQ;AAC/B,aAAa,UAAU,SAAS;AAChC,aAAa,UAAU,OAAO;AAC9B,aAAa,UAAU,SAAS;AAChC,aAAa,UAAU,SAAS;AAChC,aAAa,UAAU,WAAW;;;AChOlC;AAmDO,IAAME,QAAO,EAAC,UAAU,SAAS,SAAS,MAAM,KAAK,IAAG;AAc/D,SAAS,SAASA,OAAM,KAAK;AAC3B,MAAI,QAAQ,UAAa,OAAO,QAAQ,UAAU;AAChD,UAAM,IAAI,UAAU,iCAAiC;AAAA,EACvD;AAEA,aAAWA,KAAI;AACf,MAAI,QAAQ;AACZ,MAAI,MAAM;AACV,MAAIC,SAAQD,MAAK;AAEjB,MAAI;AAEJ,MAAI,QAAQ,UAAa,IAAI,WAAW,KAAK,IAAI,SAASA,MAAK,QAAQ;AACrE,WAAOC,UAAS;AACd,UAAID,MAAK,WAAWC,MAAK,MAAM,IAAc;AAG3C,YAAI,cAAc;AAChB,kBAAQA,SAAQ;AAChB;AAAA,QACF;AAAA,MACF,WAAW,MAAM,GAAG;AAGlB,uBAAe;AACf,cAAMA,SAAQ;AAAA,MAChB;AAAA,IACF;AAEA,WAAO,MAAM,IAAI,KAAKD,MAAK,MAAM,OAAO,GAAG;AAAA,EAC7C;AAEA,MAAI,QAAQA,OAAM;AAChB,WAAO;AAAA,EACT;AAEA,MAAI,mBAAmB;AACvB,MAAI,WAAW,IAAI,SAAS;AAE5B,SAAOC,UAAS;AACd,QAAID,MAAK,WAAWC,MAAK,MAAM,IAAc;AAG3C,UAAI,cAAc;AAChB,gBAAQA,SAAQ;AAChB;AAAA,MACF;AAAA,IACF,OAAO;AACL,UAAI,mBAAmB,GAAG;AAGxB,uBAAe;AACf,2BAAmBA,SAAQ;AAAA,MAC7B;AAEA,UAAI,WAAW,IAAI;AAEjB,YAAID,MAAK,WAAWC,MAAK,MAAM,IAAI,WAAW,UAAU,GAAG;AACzD,cAAI,WAAW,GAAG;AAGhB,kBAAMA;AAAA,UACR;AAAA,QACF,OAAO;AAGL,qBAAW;AACX,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,UAAU,KAAK;AACjB,UAAM;AAAA,EACR,WAAW,MAAM,GAAG;AAClB,UAAMD,MAAK;AAAA,EACb;AAEA,SAAOA,MAAK,MAAM,OAAO,GAAG;AAC9B;AAUA,SAAS,QAAQA,OAAM;AACrB,aAAWA,KAAI;AAEf,MAAIA,MAAK,WAAW,GAAG;AACrB,WAAO;AAAA,EACT;AAEA,MAAI,MAAM;AACV,MAAIC,SAAQD,MAAK;AAEjB,MAAI;AAGJ,SAAO,EAAEC,QAAO;AACd,QAAID,MAAK,WAAWC,MAAK,MAAM,IAAc;AAC3C,UAAI,gBAAgB;AAClB,cAAMA;AACN;AAAA,MACF;AAAA,IACF,WAAW,CAAC,gBAAgB;AAE1B,uBAAiB;AAAA,IACnB;AAAA,EACF;AAEA,SAAO,MAAM,IACTD,MAAK,WAAW,CAAC,MAAM,KACrB,MACA,MACF,QAAQ,KAAKA,MAAK,WAAW,CAAC,MAAM,KACpC,OACAA,MAAK,MAAM,GAAG,GAAG;AACvB;AAUA,SAAS,QAAQA,OAAM;AACrB,aAAWA,KAAI;AAEf,MAAIC,SAAQD,MAAK;AAEjB,MAAI,MAAM;AACV,MAAI,YAAY;AAChB,MAAI,WAAW;AAGf,MAAI,cAAc;AAElB,MAAI;AAEJ,SAAOC,UAAS;AACd,UAAMC,QAAOF,MAAK,WAAWC,MAAK;AAElC,QAAIC,UAAS,IAAc;AAGzB,UAAI,gBAAgB;AAClB,oBAAYD,SAAQ;AACpB;AAAA,MACF;AAEA;AAAA,IACF;AAEA,QAAI,MAAM,GAAG;AAGX,uBAAiB;AACjB,YAAMA,SAAQ;AAAA,IAChB;AAEA,QAAIC,UAAS,IAAc;AAEzB,UAAI,WAAW,GAAG;AAChB,mBAAWD;AAAA,MACb,WAAW,gBAAgB,GAAG;AAC5B,sBAAc;AAAA,MAChB;AAAA,IACF,WAAW,WAAW,IAAI;AAGxB,oBAAc;AAAA,IAChB;AAAA,EACF;AAEA,MACE,WAAW,KACX,MAAM;AAAA,EAEN,gBAAgB;AAAA,EAEf,gBAAgB,KAAK,aAAa,MAAM,KAAK,aAAa,YAAY,GACvE;AACA,WAAO;AAAA,EACT;AAEA,SAAOD,MAAK,MAAM,UAAU,GAAG;AACjC;AAUA,SAAS,QAAQ,UAAU;AACzB,MAAIC,SAAQ;AAEZ,MAAI;AAEJ,SAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,eAAW,SAASA,MAAK,CAAC;AAE1B,QAAI,SAASA,MAAK,GAAG;AACnB,eACE,WAAW,SAAY,SAASA,MAAK,IAAI,SAAS,MAAM,SAASA,MAAK;AAAA,IAC1E;AAAA,EACF;AAEA,SAAO,WAAW,SAAY,MAAM,UAAU,MAAM;AACtD;AAYA,SAAS,UAAUD,OAAM;AACvB,aAAWA,KAAI;AAEf,QAAM,WAAWA,MAAK,WAAW,CAAC,MAAM;AAGxC,MAAI,QAAQ,gBAAgBA,OAAM,CAAC,QAAQ;AAE3C,MAAI,MAAM,WAAW,KAAK,CAAC,UAAU;AACnC,YAAQ;AAAA,EACV;AAEA,MAAI,MAAM,SAAS,KAAKA,MAAK,WAAWA,MAAK,SAAS,CAAC,MAAM,IAAY;AACvE,aAAS;AAAA,EACX;AAEA,SAAO,WAAW,MAAM,QAAQ;AAClC;AAYA,SAAS,gBAAgBA,OAAM,gBAAgB;AAC7C,MAAI,SAAS;AACb,MAAI,oBAAoB;AACxB,MAAI,YAAY;AAChB,MAAI,OAAO;AACX,MAAIC,SAAQ;AAEZ,MAAIC;AAEJ,MAAI;AAEJ,SAAO,EAAED,UAASD,MAAK,QAAQ;AAC7B,QAAIC,SAAQD,MAAK,QAAQ;AACvB,MAAAE,QAAOF,MAAK,WAAWC,MAAK;AAAA,IAC9B,WAAWC,UAAS,IAAc;AAChC;AAAA,IACF,OAAO;AACL,MAAAA,QAAO;AAAA,IACT;AAEA,QAAIA,UAAS,IAAc;AACzB,UAAI,cAAcD,SAAQ,KAAK,SAAS,GAAG;AAAA,MAE3C,WAAW,cAAcA,SAAQ,KAAK,SAAS,GAAG;AAChD,YACE,OAAO,SAAS,KAChB,sBAAsB,KACtB,OAAO,WAAW,OAAO,SAAS,CAAC,MAAM,MACzC,OAAO,WAAW,OAAO,SAAS,CAAC,MAAM,IACzC;AACA,cAAI,OAAO,SAAS,GAAG;AACrB,6BAAiB,OAAO,YAAY,GAAG;AAEvC,gBAAI,mBAAmB,OAAO,SAAS,GAAG;AACxC,kBAAI,iBAAiB,GAAG;AACtB,yBAAS;AACT,oCAAoB;AAAA,cACtB,OAAO;AACL,yBAAS,OAAO,MAAM,GAAG,cAAc;AACvC,oCAAoB,OAAO,SAAS,IAAI,OAAO,YAAY,GAAG;AAAA,cAChE;AAEA,0BAAYA;AACZ,qBAAO;AACP;AAAA,YACF;AAAA,UACF,WAAW,OAAO,SAAS,GAAG;AAC5B,qBAAS;AACT,gCAAoB;AACpB,wBAAYA;AACZ,mBAAO;AACP;AAAA,UACF;AAAA,QACF;AAEA,YAAI,gBAAgB;AAClB,mBAAS,OAAO,SAAS,IAAI,SAAS,QAAQ;AAC9C,8BAAoB;AAAA,QACtB;AAAA,MACF,OAAO;AACL,YAAI,OAAO,SAAS,GAAG;AACrB,oBAAU,MAAMD,MAAK,MAAM,YAAY,GAAGC,MAAK;AAAA,QACjD,OAAO;AACL,mBAASD,MAAK,MAAM,YAAY,GAAGC,MAAK;AAAA,QAC1C;AAEA,4BAAoBA,SAAQ,YAAY;AAAA,MAC1C;AAEA,kBAAYA;AACZ,aAAO;AAAA,IACT,WAAWC,UAAS,MAAgB,OAAO,IAAI;AAC7C;AAAA,IACF,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAUA,SAAS,WAAWF,OAAM;AACxB,MAAI,OAAOA,UAAS,UAAU;AAC5B,UAAM,IAAI;AAAA,MACR,qCAAqC,KAAK,UAAUA,KAAI;AAAA,IAC1D;AAAA,EACF;AACF;;;ACnaA;AAGO,IAAM,OAAO,EAAC,IAAG;AAExB,SAAS,MAAM;AACb,SAAO;AACT;;;ACPA;;;ACAA;AA2BO,SAAS,MAAM,eAAe;AACnC,SACE,kBAAkB,QAClB,OAAO,kBAAkB;AAAA,EAEzB,cAAc;AAAA,EAEd,cAAc;AAElB;;;ADxBO,SAAS,UAAUG,OAAM;AAC9B,MAAI,OAAOA,UAAS,UAAU;AAC5B,IAAAA,QAAO,IAAI,IAAIA,KAAI;AAAA,EACrB,WAAW,CAAC,MAAMA,KAAI,GAAG;AAEvB,UAAM,QAAQ,IAAI;AAAA,MAChB,iFACEA,QACA;AAAA,IACJ;AACA,UAAM,OAAO;AACb,UAAM;AAAA,EACR;AAEA,MAAIA,MAAK,aAAa,SAAS;AAE7B,UAAM,QAAQ,IAAI,UAAU,gCAAgC;AAC5D,UAAM,OAAO;AACb,UAAM;AAAA,EACR;AAEA,SAAO,oBAAoBA,KAAI;AACjC;AAUA,SAAS,oBAAoB,KAAK;AAChC,MAAI,IAAI,aAAa,IAAI;AAEvB,UAAM,QAAQ,IAAI;AAAA,MAChB;AAAA,IACF;AACA,UAAM,OAAO;AACb,UAAM;AAAA,EACR;AAEA,QAAM,WAAW,IAAI;AACrB,MAAIC,SAAQ;AAEZ,SAAO,EAAEA,SAAQ,SAAS,QAAQ;AAChC,QACE,SAAS,WAAWA,MAAK,MAAM,MAC/B,SAAS,WAAWA,SAAQ,CAAC,MAAM,IACnC;AACA,YAAM,QAAQ,SAAS,WAAWA,SAAQ,CAAC;AAC3C,UAAI,UAAU,MAAgB,UAAU,KAAe;AAErD,cAAM,QAAQ,IAAI;AAAA,UAChB;AAAA,QACF;AACA,cAAM,OAAO;AACb,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,SAAO,mBAAmB,QAAQ;AACpC;;;ALuBA,IAAM,QAAQ,CAAC,WAAW,QAAQ,YAAY,QAAQ,WAAW,SAAS;AAEnE,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBjB,YAAY,OAAO;AAEjB,QAAI;AAEJ,QAAI,CAAC,OAAO;AACV,gBAAU,CAAC;AAAA,IACb,WAAW,OAAO,UAAU,YAAY,OAAO,KAAK,GAAG;AACrD,gBAAU,EAAC,MAAK;AAAA,IAClB,WAAW,MAAM,KAAK,GAAG;AACvB,gBAAU,EAAC,MAAM,MAAK;AAAA,IACxB,OAAO;AACL,gBAAU;AAAA,IACZ;AAUA,SAAK,OAAO,CAAC;AAOb,SAAK,WAAW,CAAC;AASjB,SAAK,UAAU,CAAC;AAOhB,SAAK,MAAM,KAAK,IAAI;AAQpB,SAAK;AAYL,SAAK;AAUL,SAAK;AAUL,SAAK;AAIL,QAAIC,SAAQ;AAEZ,WAAO,EAAEA,SAAQ,MAAM,QAAQ;AAC7B,YAAMC,QAAO,MAAMD,MAAK;AAIxB,UACEC,SAAQ,WACR,QAAQA,KAAI,MAAM,UAClB,QAAQA,KAAI,MAAM,MAClB;AAEA,aAAKA,KAAI,IAAIA,UAAS,YAAY,CAAC,GAAG,QAAQA,KAAI,CAAC,IAAI,QAAQA,KAAI;AAAA,MACrE;AAAA,IACF;AAGA,QAAI;AAGJ,SAAK,QAAQ,SAAS;AAEpB,UAAI,CAAC,MAAM,SAAS,IAAI,GAAG;AAEzB,aAAK,IAAI,IAAI,QAAQ,IAAI;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAO;AACT,WAAO,KAAK,QAAQ,KAAK,QAAQ,SAAS,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,IAAI,KAAKC,OAAM;AACb,QAAI,MAAMA,KAAI,GAAG;AACf,MAAAA,QAAO,UAAUA,KAAI;AAAA,IACvB;AAEA,mBAAeA,OAAM,MAAM;AAE3B,QAAI,KAAK,SAASA,OAAM;AACtB,WAAK,QAAQ,KAAKA,KAAI;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACZ,WAAO,OAAO,KAAK,SAAS,WAAWA,MAAK,QAAQ,KAAK,IAAI,IAAI;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,QAAQC,UAAS;AACnB,IAAAC,YAAW,KAAK,UAAU,SAAS;AACnC,SAAK,OAAOF,MAAK,KAAKC,YAAW,IAAI,KAAK,QAAQ;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,WAAW;AACb,WAAO,OAAO,KAAK,SAAS,WAAWD,MAAK,SAAS,KAAK,IAAI,IAAI;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,SAASG,WAAU;AACrB,mBAAeA,WAAU,UAAU;AACnC,eAAWA,WAAU,UAAU;AAC/B,SAAK,OAAOH,MAAK,KAAK,KAAK,WAAW,IAAIG,SAAQ;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACZ,WAAO,OAAO,KAAK,SAAS,WAAWH,MAAK,QAAQ,KAAK,IAAI,IAAI;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,QAAQI,UAAS;AACnB,eAAWA,UAAS,SAAS;AAC7B,IAAAF,YAAW,KAAK,SAAS,SAAS;AAElC,QAAIE,UAAS;AACX,UAAIA,SAAQ,WAAW,CAAC,MAAM,IAAc;AAC1C,cAAM,IAAI,MAAM,+BAA+B;AAAA,MACjD;AAEA,UAAIA,SAAQ,SAAS,KAAK,CAAC,GAAG;AAC5B,cAAM,IAAI,MAAM,wCAAwC;AAAA,MAC1D;AAAA,IACF;AAEA,SAAK,OAAOJ,MAAK,KAAK,KAAK,SAAS,KAAK,QAAQI,YAAW,GAAG;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAO;AACT,WAAO,OAAO,KAAK,SAAS,WACxBJ,MAAK,SAAS,KAAK,MAAM,KAAK,OAAO,IACrC;AAAA,EACN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,KAAK,MAAM;AACb,mBAAe,MAAM,MAAM;AAC3B,eAAW,MAAM,MAAM;AACvB,SAAK,OAAOA,MAAK,KAAK,KAAK,WAAW,IAAI,QAAQ,KAAK,WAAW,GAAG;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAAS,UAAU;AACjB,YAAQ,KAAK,SAAS,IAAI,SAAS,YAAY,MAAS;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,QAAQ,QAAQ,OAAO,QAAQ;AAC7B,UAAM,UAAU,IAAI,aAAa,QAAQ,OAAO,MAAM;AAEtD,QAAI,KAAK,MAAM;AACb,cAAQ,OAAO,KAAK,OAAO,MAAM,QAAQ;AACzC,cAAQ,OAAO,KAAK;AAAA,IACtB;AAEA,YAAQ,QAAQ;AAEhB,SAAK,SAAS,KAAK,OAAO;AAE1B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,KAAK,QAAQ,OAAO,QAAQ;AAC1B,UAAM,UAAU,KAAK,QAAQ,QAAQ,OAAO,MAAM;AAElD,YAAQ,QAAQ;AAEhB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,KAAK,QAAQ,OAAO,QAAQ;AAC1B,UAAM,UAAU,KAAK,QAAQ,QAAQ,OAAO,MAAM;AAElD,YAAQ,QAAQ;AAEhB,UAAM;AAAA,EACR;AACF;AAYA,SAAS,WAAW,MAAM,MAAM;AAC9B,MAAI,QAAQ,KAAK,SAASA,MAAK,GAAG,GAAG;AACnC,UAAM,IAAI;AAAA,MACR,MAAM,OAAO,yCAAyCA,MAAK,MAAM;AAAA,IACnE;AAAA,EACF;AACF;AAYA,SAAS,eAAe,MAAM,MAAM;AAClC,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,MAAM,OAAO,mBAAmB;AAAA,EAClD;AACF;AAYA,SAASE,YAAWF,OAAM,MAAM;AAC9B,MAAI,CAACA,OAAM;AACT,UAAM,IAAI,MAAM,cAAc,OAAO,iCAAiC;AAAA,EACxE;AACF;AAUA,SAAS,OAAO,OAAO;AACrB,aAAO,iBAAAK,SAAW,KAAK;AACzB;;;AL3eO,IAAM,UAAU,KAAK,EAAE,OAAO;AAErC,IAAMC,OAAM,CAAC,EAAE;AAMf,SAAS,OAAO;AACd,QAAM,eAAe,OAAO;AAE5B,QAAM,YAAY,CAAC;AAEnB,MAAI,YAAY,CAAC;AAEjB,MAAI;AACJ,MAAI,cAAc;AAIlB,YAAU,OAAOC;AACjB,YAAU,SAAS;AACnB,YAAU,WAAW;AAGrB,YAAU,SAAS;AAGnB,YAAU,YAAY;AAEtB,YAAU,MAAM;AAGhB,YAAU,QAAQC;AAClB,YAAU,YAAY;AAEtB,YAAU,MAAM;AAChB,YAAU,UAAU;AAEpB,YAAU,UAAU;AACpB,YAAU,cAAc;AAGxB,SAAO;AAIP,WAAS,YAAY;AACnB,UAAM,cAAc,KAAK;AACzB,QAAIC,SAAQ;AAEZ,WAAO,EAAEA,SAAQ,UAAU,QAAQ;AACjC,kBAAY,IAAI,GAAG,UAAUA,MAAK,CAAC;AAAA,IACrC;AAEA,gBAAY,SAAK,cAAAC,SAAO,MAAM,CAAC,GAAG,SAAS,CAAC;AAE5C,WAAO;AAAA,EACT;AAOA,WAASH,MAAKI,MAAK,OAAO;AACxB,QAAI,OAAOA,SAAQ,UAAU;AAE3B,UAAI,UAAU,WAAW,GAAG;AAC1B,uBAAe,QAAQ,MAAM;AAC7B,kBAAUA,IAAG,IAAI;AACjB,eAAO;AAAA,MACT;AAGA,aAAQL,KAAI,KAAK,WAAWK,IAAG,KAAK,UAAUA,IAAG,KAAM;AAAA,IACzD;AAGA,QAAIA,MAAK;AACP,qBAAe,QAAQ,MAAM;AAC7B,kBAAYA;AACZ,aAAO;AAAA,IACT;AAGA,WAAO;AAAA,EACT;AAGA,WAAS,SAAS;AAChB,QAAI,QAAQ;AACV,aAAO;AAAA,IACT;AAEA,WAAO,EAAE,cAAc,UAAU,QAAQ;AACvC,YAAM,CAAC,UAAU,GAAG,OAAO,IAAI,UAAU,WAAW;AAEpD,UAAI,QAAQ,CAAC,MAAM,OAAO;AACxB;AAAA,MACF;AAEA,UAAI,QAAQ,CAAC,MAAM,MAAM;AACvB,gBAAQ,CAAC,IAAI;AAAA,MACf;AAGA,YAAM,cAAc,SAAS,KAAK,WAAW,GAAG,OAAO;AAEvD,UAAI,OAAO,gBAAgB,YAAY;AACrC,qBAAa,IAAI,WAAW;AAAA,MAC9B;AAAA,IACF;AAEA,aAAS;AACT,kBAAc,OAAO;AAErB,WAAO;AAAA,EACT;AAOA,WAAS,IAAI,UAAU,SAAS;AAE9B,QAAI;AAEJ,mBAAe,OAAO,MAAM;AAE5B,QAAI,UAAU,QAAQ,UAAU,QAAW;AAAA,IAE3C,WAAW,OAAO,UAAU,YAAY;AACtC,gBAAU,OAAO,GAAG,OAAO;AAAA,IAC7B,WAAW,OAAO,UAAU,UAAU;AACpC,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAQ,KAAK;AAAA,MACf,OAAO;AACL,kBAAU,KAAK;AAAA,MACjB;AAAA,IACF,OAAO;AACL,YAAM,IAAI,UAAU,iCAAiC,QAAQ,GAAG;AAAA,IAClE;AAEA,QAAI,UAAU;AACZ,gBAAU,WAAW,OAAO,OAAO,UAAU,YAAY,CAAC,GAAG,QAAQ;AAAA,IACvE;AAEA,WAAO;AAMP,aAAS,IAAIC,QAAO;AAClB,UAAI,OAAOA,WAAU,YAAY;AAC/B,kBAAUA,MAAK;AAAA,MACjB,WAAW,OAAOA,WAAU,UAAU;AACpC,YAAI,MAAM,QAAQA,MAAK,GAAG;AACxB,gBAAM,CAAC,QAAQ,GAAGC,QAAO,IAAID;AAC7B,oBAAU,QAAQ,GAAGC,QAAO;AAAA,QAC9B,OAAO;AACL,oBAAUD,MAAK;AAAA,QACjB;AAAA,MACF,OAAO;AACL,cAAM,IAAI,UAAU,iCAAiCA,SAAQ,GAAG;AAAA,MAClE;AAAA,IACF;AAMA,aAAS,UAAU,QAAQ;AACzB,cAAQ,OAAO,OAAO;AAEtB,UAAI,OAAO,UAAU;AACnB,mBAAW,OAAO,OAAO,YAAY,CAAC,GAAG,OAAO,QAAQ;AAAA,MAC1D;AAAA,IACF;AAMA,aAAS,QAAQE,UAAS;AACxB,UAAIL,SAAQ;AAEZ,UAAIK,aAAY,QAAQA,aAAY,QAAW;AAAA,MAE/C,WAAW,MAAM,QAAQA,QAAO,GAAG;AACjC,eAAO,EAAEL,SAAQK,SAAQ,QAAQ;AAC/B,gBAAM,QAAQA,SAAQL,MAAK;AAC3B,cAAI,KAAK;AAAA,QACX;AAAA,MACF,OAAO;AACL,cAAM,IAAI,UAAU,sCAAsCK,WAAU,GAAG;AAAA,MACzE;AAAA,IACF;AAOA,aAAS,UAAU,QAAQF,QAAO;AAChC,UAAIH,SAAQ;AAEZ,UAAI;AAEJ,aAAO,EAAEA,SAAQ,UAAU,QAAQ;AACjC,YAAI,UAAUA,MAAK,EAAE,CAAC,MAAM,QAAQ;AAClC,kBAAQ,UAAUA,MAAK;AACvB;AAAA,QACF;AAAA,MACF;AAEA,UAAI,OAAO;AACT,YAAI,cAAW,MAAM,CAAC,CAAC,KAAK,cAAWG,MAAK,GAAG;AAC7C,UAAAA,aAAQ,cAAAF,SAAO,MAAM,MAAM,CAAC,GAAGE,MAAK;AAAA,QACtC;AAEA,cAAM,CAAC,IAAIA;AAAA,MACb,OAAO;AAEL,kBAAU,KAAK,CAAC,GAAG,SAAS,CAAC;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAGA,WAASJ,OAAM,KAAK;AAClB,cAAU,OAAO;AACjB,UAAM,OAAO,MAAM,GAAG;AACtB,UAAM,SAAS,UAAU;AACzB,iBAAa,SAAS,MAAM;AAE5B,QAAI,QAAQ,QAAQ,OAAO,GAAG;AAE5B,aAAO,IAAI,OAAO,OAAO,IAAI,GAAG,IAAI,EAAE,MAAM;AAAA,IAC9C;AAGA,WAAO,OAAO,OAAO,IAAI,GAAG,IAAI;AAAA,EAClC;AAGA,WAAS,UAAUO,OAAM,KAAK;AAC5B,cAAU,OAAO;AACjB,UAAM,OAAO,MAAM,GAAG;AACtB,UAAM,WAAW,UAAU;AAC3B,mBAAe,aAAa,QAAQ;AACpC,eAAWA,KAAI;AAEf,QAAI,QAAQ,UAAU,SAAS,GAAG;AAEhC,aAAO,IAAI,SAASA,OAAM,IAAI,EAAE,QAAQ;AAAA,IAC1C;AAGA,WAAO,SAASA,OAAM,IAAI;AAAA,EAC5B;AAQA,WAAS,IAAIA,OAAM,KAAK,UAAU;AAChC,eAAWA,KAAI;AACf,cAAU,OAAO;AAEjB,QAAI,CAAC,YAAY,OAAO,QAAQ,YAAY;AAC1C,iBAAW;AACX,YAAM;AAAA,IACR;AAEA,QAAI,CAAC,UAAU;AACb,aAAO,IAAI,QAAQ,QAAQ;AAAA,IAC7B;AAEA,aAAS,MAAM,QAAQ;AAOvB,aAAS,SAAS,SAAS,QAAQ;AAEjC,mBAAa,IAAIA,OAAM,MAAM,GAAG,GAAG,IAAI;AAQvC,eAAS,KAAK,OAAO,MAAM,MAAM;AAC/B,eAAO,QAAQA;AACf,YAAI,OAAO;AACT,iBAAO,KAAK;AAAA,QACd,WAAW,SAAS;AAClB,kBAAQ,IAAI;AAAA,QACd,OAAO;AAEL,mBAAS,MAAM,MAAM,IAAI;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,WAAS,QAAQA,OAAM,MAAM;AAE3B,QAAI;AAEJ,QAAI;AAEJ,cAAU,IAAIA,OAAM,MAAM,IAAI;AAE9B,eAAW,WAAW,OAAO,QAAQ;AAGrC,WAAO;AAOP,aAAS,KAAK,OAAO,MAAM;AACzB,WAAK,KAAK;AACV,eAAS;AACT,iBAAW;AAAA,IACb;AAAA,EACF;AAOA,WAAS,QAAQ,KAAK,UAAU;AAC9B,cAAU,OAAO;AACjB,iBAAa,WAAW,UAAU,MAAM;AACxC,mBAAe,WAAW,UAAU,QAAQ;AAE5C,QAAI,CAAC,UAAU;AACb,aAAO,IAAI,QAAQ,QAAQ;AAAA,IAC7B;AAEA,aAAS,MAAM,QAAQ;AAOvB,aAAS,SAAS,SAAS,QAAQ;AACjC,YAAM,OAAO,MAAM,GAAG;AAEtB,gBAAU,IAAI,UAAU,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,MAAMC,UAAS;AAChE,YAAI,SAAS,CAAC,QAAQ,CAACA,OAAM;AAC3B,eAAK,KAAK;AAAA,QACZ,OAAO;AAEL,gBAAM,SAAS,UAAU,UAAU,MAAMA,KAAI;AAE7C,cAAI,WAAW,UAAa,WAAW,MAAM;AAAA,UAE7C,WAAW,qBAAqB,MAAM,GAAG;AACvC,YAAAA,MAAK,QAAQ;AAAA,UACf,OAAO;AACL,YAAAA,MAAK,SAAS;AAAA,UAChB;AAEA,eAAK,OAAOA,KAAI;AAAA,QAClB;AAAA,MACF,CAAC;AAOD,eAAS,KAAK,OAAOA,OAAM;AACzB,YAAI,SAAS,CAACA,OAAM;AAClB,iBAAO,KAAK;AAAA,QACd,WAAW,SAAS;AAClB,kBAAQA,KAAI;AAAA,QACd,OAAO;AAEL,mBAAS,MAAMA,KAAI;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,WAAS,YAAY,KAAK;AAExB,QAAI;AAEJ,cAAU,OAAO;AACjB,iBAAa,eAAe,UAAU,MAAM;AAC5C,mBAAe,eAAe,UAAU,QAAQ;AAEhD,UAAM,OAAO,MAAM,GAAG;AAEtB,cAAU,QAAQ,MAAM,IAAI;AAE5B,eAAW,eAAe,WAAW,QAAQ;AAE7C,WAAO;AAMP,aAAS,KAAK,OAAO;AACnB,iBAAW;AACX,WAAK,KAAK;AAAA,IACZ;AAAA,EACF;AACF;AASA,SAAS,QAAQ,OAAO,MAAM;AAC5B,SACE,OAAO,UAAU;AAAA;AAAA,EAGjB,MAAM;AAAA;AAAA;AAAA;AAAA,GAKL,KAAK,MAAM,SAAS,KAAK,QAAQ,MAAM;AAE5C;AAQA,SAAS,KAAK,OAAO;AAEnB,MAAIL;AAEJ,OAAKA,QAAO,OAAO;AACjB,QAAIL,KAAI,KAAK,OAAOK,IAAG,GAAG;AACxB,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AASA,SAAS,aAAa,MAAM,OAAO;AACjC,MAAI,OAAO,UAAU,YAAY;AAC/B,UAAM,IAAI,UAAU,aAAa,OAAO,oBAAoB;AAAA,EAC9D;AACF;AASA,SAAS,eAAe,MAAM,OAAO;AACnC,MAAI,OAAO,UAAU,YAAY;AAC/B,UAAM,IAAI,UAAU,aAAa,OAAO,sBAAsB;AAAA,EAChE;AACF;AASA,SAAS,eAAe,MAAM,QAAQ;AACpC,MAAI,QAAQ;AACV,UAAM,IAAI;AAAA,MACR,kBACE,OACA;AAAA,IACJ;AAAA,EACF;AACF;AAQA,SAAS,WAAWI,OAAM;AAGxB,MAAI,CAAC,cAAWA,KAAI,KAAK,OAAOA,MAAK,SAAS,UAAU;AACtD,UAAM,IAAI,UAAU,yBAAyBA,QAAO,GAAG;AAAA,EAEzD;AACF;AAUA,SAAS,WAAW,MAAM,WAAW,UAAU;AAC7C,MAAI,CAAC,UAAU;AACb,UAAM,IAAI;AAAA,MACR,MAAM,OAAO,4BAA4B,YAAY;AAAA,IACvD;AAAA,EACF;AACF;AAMA,SAAS,MAAM,OAAO;AACpB,SAAO,gBAAgB,KAAK,IAAI,QAAQ,IAAI,MAAM,KAAK;AACzD;AAMA,SAAS,gBAAgB,OAAO;AAC9B,SAAO;AAAA,IACL,SACE,OAAO,UAAU,YACjB,aAAa,SACb,cAAc;AAAA,EAClB;AACF;AAMA,SAAS,qBAAqB,OAAO;AACnC,SAAO,OAAO,UAAU,gBAAY,kBAAAE,SAAS,KAAK;AACpD;;;AYtlBA;;;ACAA;AAEO,SAAS,OAAO,MAAe,SAAiB;AACrD,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,GAAG,SAAS;AACzC;AAEO,SAAS,kBAAkBC,UAAkB,MAAuB;AACzE,MAAIA,SAAQ,SAAS;AACnB,UAAM,IAAI;AAAA,MACR,kCAAkC,KAAK;AAAA,QACrCA;AAAA,MACF,YAAY,KAAK,UAAUA,UAAS,MAAM,CAAC;AAAA,IAC7C;AACJ;AAEO,SAAS,kBAAkB,GAAiB;AACjD,QAAM,IAAI;AAAA,IACR,wCAAwC,KAAK,UAAU,GAAG,MAAM,CAAC;AAAA,EACnE;AACF;;;ACnBA;AAKO,SAAS,gBAAgBC,UAAgC;AAC9D,SAAO,CAAC,EAAE,MAAM,eAAe,UAAU,cAAcA,SAAQ,QAAQ,EAAE,CAAC;AAC5E;;;ACPA;AAIO,SAAS,eAAeC,UAA0B;AACvD,QAAM,YAAYA,SAAQ,MAAM,MAAM,IAAI;AAC1C,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAUA,SAAQ,QAAQ;AAAA,MAC1B,UAAU,UAAU,IAAI,CAAC,cAAc;AAAA,QACrC,MAAM;AAAA,QACN,UAAU,CAAC,EAAE,MAAM,SAAS,CAAC;AAAA,MAC/B,EAAE;AAAA,IACJ;AAAA,EACF;AACF;;;AChBA;AAcO,SAAS,wBACd,UACW;AACX,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA,QAKR,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE,MAAM,IAAI,SAAS,cAAc,CAAC,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA,QAKtE,GAAG,cAAc,SAAS,QAAQ;AAAA,MACpC;AAAA,IACF;AAAA,EACF;AACF;;;AClCA;;;ACAA;;;ACAA;AAAA,SAAS,QAAQC,kBAAiB;;;ACAlC;AAAA,SAAS,QAAQC,kBAAiB;;;ACAlC;;;ACAA;AAAA,YAAY,WAAW;AAUhB,SAAS,OAAO,SAA4C;AACjE,SAAa,WAAK,OAAO,OAAO;AAClC;AAeO,SAAS,UACd,SACwC;AACxC,SAAa,cAAQ,UAAU,OAAO;AACxC;AAUO,SAAS,aAAa,SAA2B;AACtD,SACQ,WAAK,OAAO,OAAO,KAAK,CAAC,CAAC,QAAQ,KAAK,MAAM,OAAO,KAAK,CAAC,QAAQ;AAE5E;;;AC7CA;;;ACAA;AAEO,IAAM,oBAAoB;AAAA,EAC/B,MAAM;AAAA,EACN,QAAQ;AAAA;AAAA,EAER,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYL,MAAM;AACR;AAKA,SAAS,oBAAoB,MAAuB;AAClD,MAAI,QAAQ;AAAmB,WAAO,kBAAkB,IAAI;AAC5D,QAAM,IAAI;AAAA,IACR,uBAAuB,KAAK,UAAU,IAAI;AAAA,EAC5C;AACF;AAKO,SAAS,gCAAgC,OAAkB;AAChE,SAAO,MAAM,IAAI,mBAAmB,EAAE,KAAK,EAAE;AAC/C;;;ACtCA;AAAA,SAAS,QAAQ,iBAAiB;AAQ3B,SAAS,iBAAiBC,OAAuB;AAKtD,QAAM,EAAE,MAAM,GAAG,GAAG,MAAM,IAAIA;AAC9B,SAAO,OAAO,KAAK,KAAK;AAC1B;AAKO,SAAS,oBAAoB,SAA6B;AAC/D,MAAI,UAAU,OAAO,OAAO,GAAG;AAC7B,QAAI,aAAa,OAAO,GAAG;AACzB,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,WAAO,iBAAiB,OAAO;AAAA,EACjC,WAAW,QAAQ,SAAS,UAAU;AACpC,WAAO,qBAAqB,QAAQ,QAAqB;AAAA,EAC3D,OAAO;AAIL,UAAM,IAAI,MAAM,kBAAkB,QAAQ,MAAM;AAAA,EAClD;AACF;AAEO,SAAS,qBAAqB,UAAgC;AACnE,MAAI;AACJ,aAAW,WAAW,UAAU;AAC9B,QAAI,CAAC,OAAO,OAAO,GAAG;AAMpB,UAAI,QAAQ,SAAS;AAAgB;AAKrC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AACA,QAAI,aAAa,OAAO;AAAG;AAC3B,UAAM,eAAe,iBAAiB,OAAO;AAC7C,QAAI,gBAAgB,QAAW;AAC7B,oBAAc;AACd;AAAA,IACF;AACA,kBAAc,YAAY;AAAA,MAAO,CAAC,eAChC,aAAa,SAAS,UAAU;AAAA,IAClC;AAAA,EACF;AACA,MAAI,gBAAgB;AAClB,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AACF,SAAO;AACT;;;ACvEA;AAcA,IAAM,oBAA+B;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAOO,SAAS,UAAU,OAA6B;AACrD,SAAO,MACJ,MAAM,EACN,KAAK,CAAC,GAAG,MAAM,kBAAkB,QAAQ,CAAC,IAAI,kBAAkB,QAAQ,CAAC,CAAC;AAC/E;;;ACjCA;AAAA,IAAM,UAAU;AAAA,EACd;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,IAAM,iBAAiB,IAAI;AAAA,EACzB,IAAI,QAAQ,IAAI,CAAC,WAAW,KAAK,QAAQ,EAAE,KAAK,GAAG;AAAA,EACnD;AACF;AAKO,SAAS,WAAW,GAAW;AACpC,SAAO,EAAE,QAAQ,gBAAgB,CAACC,OAAc,KAAKA,IAAG;AAE1D;;;AP7CO,SAAS,cAAc,GAAS,GAAkB;AACvD,QAAM,SAAS,iBAAiB,CAAC;AACjC,QAAM,SAAS,iBAAiB,CAAC;AAajC,SACE,OAAO,UAAU,OAAO,UAAU,OAAO,MAAM,CAAC,MAAM,OAAO,SAAS,CAAC,CAAC;AAE5E;AAwBO,SAAS,iBACd,SAKA,oBACW;AACX,QAAM,gBAAgBC,WAAU,OAAO,OAAO;AAC9C,QAAM,oBAAoBA,WAAU,OAAO,kBAAkB;AAY7D,MAAI,sBAAsB,CAAC,qBAAqB,CAAC,eAAe;AAC9D,WAAO,CAAC,EAAE,MAAM,GAAG,GAAG,OAAO;AAAA,EAC/B;AAMA,MAAI,CAAC;AAAe,WAAO,CAAC,OAAO;AAKnC,MAAI,uBAAuB,UAAa,CAAC;AAAmB,WAAO,CAAC,OAAO;AAK3E,QAAM,aAAa,cAAc,oBAAoB,OAAO;AAC5D,MAAI,YAAY;AACd,uBAAmB,OAAO,CAAC,mBAAmB,MAAM,QAAQ,IAAI,EAAE,KAAK,EAAE;AACzE,WAAO,CAAC;AAAA,EACV;AAEA,SAAO,CAAC,OAAO;AACjB;;;AD3EO,SAAS,kBAAkB,UAAgC;AAChE,QAAM,eAA0B,CAAC;AAejC,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AAQxC,UAAM,qBACJ,aAAa,aAAa,SAAS,CAAC;AACtC,iBAAa,KAAK,GAAG,iBAAiB,SAAS,CAAC,GAAG,kBAAkB,CAAC;AAAA,EACxE;AAQA,MAAI,aAAa,WAAW;AAAG,iBAAa,KAAK,EAAE,MAAM,GAAG,CAAC;AAM7D,MAAI,CAACC,WAAU,OAAO,aAAa,CAAC,CAAC;AAAG,iBAAa,QAAQ,EAAE,MAAM,GAAG,CAAC;AAMzE,MAAI,CAACA,WAAU,OAAO,aAAa,aAAa,SAAS,CAAC,CAAC;AACzD,iBAAa,KAAK,EAAE,MAAM,GAAG,CAAC;AAChC,SAAO;AACT;;;ASvEA;;;ACAA;;;ACAA;AAOO,SAAS,kBAAkB,OAAyB;AACzD,SAAO;AAAA,IACL,KAAK,MAAM;AAAA,IACX,OAAO,MAAM,SAAS;AAAA,IACtB,KAAK,MAAM,OAAO;AAAA,EACpB;AACF;;;ACbA;;;ACAA;AAcA,IAAM,YAAY;AAEX,SAAS,SAAS,KAAwB;AAC/C,MAAI;AACF,UAAM,UAAU,IAAI,IAAI,GAAG;AAC3B,WAAO;AAAA,MACL,QAAQ,QAAQ;AAAA,MAChB,UAAU,QAAQ;AAAA,MAClB,UAAU,QAAQ;AAAA,MAClB,cAAc,QAAQ;AAAA,MACtB,MAAM,QAAQ;AAAA,IAChB;AAAA,EACF,SAAS,OAAP;AACA,UAAM,YAAY,IAAI,MAAM,SAAS;AACrC,QAAI,cAAc;AAChB,YAAM,IAAI,MAAM,qCAAqC,KAAK;AAE5D,UAAM,CAAC,GAAG,UAAU,cAAc,IAAI,IAAI,CAAC,GAAG,SAAS;AACvD,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,UAAU,YAAY;AAAA,MACtB,cAAc,IAAI,gBAAgB,YAAY;AAAA,MAC9C,MAAM,QAAQ;AAAA,IAChB;AAAA,EACF;AACF;;;ACxCA;AAIO,SAAS,UACd,GAC0C;AAC1C,MAAI,OAAO,MAAM;AAAU,WAAO;AAClC,QAAM,YAAY,EAAE,MAAM,eAAe;AACzC,MAAI,cAAc;AAAM,WAAO;AAC/B,SAAO;AAAA,IACL,OAAO,SAAS,UAAU,CAAC,CAAC;AAAA,IAC5B,QAAQ,SAAS,UAAU,CAAC,CAAC;AAAA,EAC/B;AACF;;;AFRO,SAAS,kBAAkB,OAAqC;AAErE,QAAM,MAAM,SAAS,MAAM,GAAG;AAI9B,MAAI,CAAC,IAAI,SAAS,MAAM,oBAAoB;AAAG;AAI/C,QAAM,YAAY,IAAI,aAAa,IAAI,MAAM;AAC7C,MAAI,cAAc;AAAM;AAIxB,QAAM,OAAO,UAAU,SAAS;AAChC,MAAI,SAAS;AAAM;AAKnB,QAAM,eAAe,IAAI,SAAS,MAAM,gCAAgC;AACxE,MAAI,iBAAiB;AAAM;AAI3B,SAAO;AAAA,IACL,KAAK,GAAG,IAAI,SAAS,IAAI;AAAA,IACzB,OAAO,MAAM,SAAS;AAAA,IACtB,KAAK,MAAM,OAAO;AAAA,IAClB,OAAO,KAAK;AAAA,IACZ,QAAQ,KAAK;AAAA,IACb,UAAU,SAAS,aAAa,CAAC,CAAC;AAAA,IAClC,WAAW,SAAS,aAAa,CAAC,CAAC;AAAA,EACrC;AACF;;;AGzCA;AAWO,SAAS,uBAAuB,OAAqC;AAC1E,QAAM,MAAM,SAAS,MAAM,GAAG;AAI9B,MAAI,IAAI,KAAK,WAAW;AAAG;AAM3B,QAAM,SAAS,IAAI,gBAAgB,IAAI,KAAK,MAAM,CAAC,CAAC;AACpD,QAAM,OAAO,UAAU,OAAO,IAAI,MAAM,CAAC;AACzC,QAAM,UAAU,UAAU,OAAO,IAAI,SAAS,CAAC;AAC/C,MAAI,CAAC,QAAQ,CAAC;AAAS;AAKvB,SAAO;AAAA,IACL,KAAK,GAAG,IAAI,SAAS,IAAI;AAAA,IACzB,OAAO,MAAM,SAAS;AAAA,IACtB,KAAK,MAAM,OAAO;AAAA,IAClB,OAAO,KAAK;AAAA,IACZ,QAAQ,KAAK;AAAA,IACb,UAAU,QAAQ;AAAA,IAClB,WAAW,QAAQ;AAAA,EACrB;AACF;;;ALnCO,IAAM,eAAe;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AACF;;;ADMO,SAAS,iBAAiB,OAAyB;AACxD,aAAW,eAAe,cAAc;AACtC,UAAM,YAAY,YAAY,KAAK;AACnC,QAAI,CAAC;AAAW;AAChB,WAAO;AAAA,MACL;AAAA,QACE,MAAM;AAAA,QACN,GAAG;AAAA,QACH,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACA,QAAM,IAAI,MAAM,4DAA4D;AAC9E;;;AVpBO,SAAS,sBACd,kBACA,QAAmB,CAAC,GACT;AACX,QAAM,WAAsB,CAAC;AAC7B,aAAW,mBAAmB,kBAAkB;AAC9C,aAAS,KAAK,GAAG,qBAAqB,iBAAiB,KAAK,CAAC;AAAA,EAC/D;AACA,QAAM,cAAc,kBAAkB,QAAQ;AAC9C,SAAO;AACT;AAEA,SAAS,qBACP,iBACA,QAAmB,CAAC,GACT;AACX,UAAQ,gBAAgB,MAAM;AAAA,IAC5B,KAAK;AACH,aAAO,sBAAsB,gBAAgB,UAAU;AAAA,QACrD,GAAG;AAAA,QACH,QAAQ;AAAA,MACV,CAAC;AAAA,IACH,KAAK;AACH,aAAO,sBAAsB,gBAAgB,UAAU;AAAA,QACrD,GAAG;AAAA,QACH,QAAQ;AAAA,MACV,CAAC;AAAA,IACH,KAAK;AACH,aAAO,CAAC,EAAE,MAAM,IAAI,gBAAgB,cAAc,CAAC;AAAA,IACrD,KAAK;AACH,aAAO,CAAC,EAAE,MAAM,gBAAgB,OAAO,MAAM,KAAK,CAAC;AAAA,IACrD,KAAK;AACH,aAAO,iBAAiB,eAAe;AAAA,IACzC,KAAK,cAAc;AACjB,aAAO,CAAC,EAAE,MAAM,gBAAgB,OAAO,GAAG,OAAO,MAAM,KAAK,CAAC;AAAA,IAC/D;AAAA,IACA,KAAK;AACH,aAAO;AAAA,QACL;AAAA,UACE,MAAM;AAAA,UACN,MAAM,gBAAgB;AAAA,UACtB;AAAA;AAAA;AAAA;AAAA,YAIE,gBAAgB,SAAS,OAAO,SAAY,gBAAgB;AAAA;AAAA,UAC9D,UAAU,sBAAsB,gBAAgB,UAAU,KAAK;AAAA,QACjE;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAO,sBAAsB,gBAAgB,UAAU;AAAA,QACrD,GAAG;AAAA,QACH,MAAM;AAAA,MACR,CAAC;AAAA,IACH,KAAK;AACH,aAAO,CAAC,EAAE,MAAM,gBAAgB,OAAO,GAAG,MAAM,CAAC;AAAA,IACnD,KAAK;AAAA,IACL,KAAK;AACH,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF,KAAK;AAQH,aAAO,CAAC,EAAE,MAAM,KAAK,CAAC;AAAA,IACxB,KAAK;AAUH,YAAM,IAAI,MAAM,+BAA+B;AAAA,EACnD;AACA,oBAAkB,eAAe;AACnC;;;ADrFO,SAAS,aAAaC,UAA6B;AACxD,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,OAAOA,SAAQ;AAAA,MACf,UAAU,sBAAsBA,SAAQ,QAAQ;AAAA,IAClD;AAAA,EACF;AACF;;;AkBbA;AAIO,SAAS,UAAUC,UAA0B;AAClD,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAUA,SAAQ,MAAM,MAAM,IAAI,EAAE,IAAI,CAAC,UAAU;AAAA,QACjD,MAAM;AAAA,QACN,UAAU,CAAC,EAAE,MAAM,KAAK,CAAC;AAAA,MAC3B,EAAE;AAAA,IACJ;AAAA,EACF;AACF;;;ACfA;;;ACAA;;;ACAA;;;ACAA;AAOO,SAAS,mBACd,OACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GACW;AACX,UAAQ,MAAM,MAAM;AAAA,IAClB,KAAK;AACH,UAAI,YAAY,QAAQ,YAAY,OAAO;AACzC,eAAO;AAAA,UACL;AAAA,YACE,MAAM;AAAA,YACN;AAAA,YACA;AAAA,YACA,UAAU,sBAAsB,MAAM,QAAQ;AAAA,UAChD;AAAA,QACF;AAAA,MACF,WAAW,SAAS;AAClB,eAAO;AAAA,UACL;AAAA,YACE,MAAM;AAAA,YACN;AAAA,YACA,UAAU,sBAAsB,MAAM,QAAQ;AAAA,UAChD;AAAA,QACF;AAAA,MACF,OAAO;AACL,eAAO;AAAA,UACL;AAAA,YACE,MAAM;AAAA,YACN;AAAA,YACA,UAAU,sBAAsB,MAAM,QAAQ;AAAA,UAChD;AAAA,QACF;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAO,UAAU,OAAO,QAAQ,CAAC;AAAA,IACnC;AAuBE,aAAO,aAAa,KAAK;AAAA,EAC7B;AACF;;;ADjEO,SAAS,cACdC,WACA,SACW;AACX,QAAM,WAAsB,CAAC;AAC7B,aAAW,SAASA,UAAS,UAAU;AACrC,aAAS;AAAA,MACP,GAAG,mBAAmB,OAAO,EAAE,GAAG,SAAS,SAASA,UAAS,QAAQ,CAAC;AAAA,IACxE;AAAA,EACF;AACA,SAAO;AACT;;;ADXO,SAAS,UAAUC,OAAY,QAAQ,GAAc;AAE1D,QAAM,WAAsB,CAAC;AAC7B,aAAWC,aAAYD,MAAK,UAAU;AACpC,aAAS;AAAA,MACP,GAAG,cAAcC,WAAU,EAAE,OAAO,SAAS,CAAC,CAACD,MAAK,QAAQ,CAAC;AAAA,IAC/D;AAAA,EACF;AACA,SAAO;AACT;;;AGdA;AAOA,SAAS,aAAa,UAA8B;AAClD,MAAI,SAAS,WAAW;AAAG,WAAO;AAClC,MAAI,EAAE,UAAU,SAAS,CAAC,MAAM,SAAS,CAAC,EAAE,SAAS;AAAI,WAAO;AAChE,MAAI,EAAE,UAAU,SAAS,CAAC,MAAM,SAAS,CAAC,EAAE,SAAS;AAAI,WAAO;AAChE,MAAI,EAAE,UAAU,SAAS,CAAC,MAAM,SAAS,CAAC,EAAE,SAAS;AACnD,WAAO;AACT,SAAO;AACT;AAEA,IAAM,OAAO;AAEb,SAAS,aAAa,UAA8B;AAClD,MAAI,SAAS,WAAW;AAAG,WAAO;AAClC,MAAI,EAAE,UAAU,SAAS,CAAC,MAAM,SAAS,CAAC,EAAE,SAAS;AAAM,WAAO;AAClE,SAAO;AACT;AAQO,SAAS,eAAeE,UAA+B;AAC5D,QAAM,WAAW,sBAAsBA,SAAQ,QAAQ;AACvD,MAAI,aAAa,QAAQ,GAAG;AAC1B,UAAM,eAAe,SAAS,CAAC;AAC/B,UAAM,oBAAuC;AAAA,MAC3C,GAAG;AAAA,MACH,MAAM;AAAA,IACR;AACA,WAAO,CAAC,iBAAiB;AAAA,EAC3B;AACA,MAAI,aAAa,QAAQ,GAAG;AAC1B,WAAO;AAAA,MACL;AAAA,QACE,MAAM;AAAA,QACN,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,EACF;AACF;;;ACvDA;AAUO,SAAS,WAAW,OAA8B;AACvD,MAAI,MAAM,SAAS;AACjB,UAAM,IAAI,MAAM,gDAAgD;AAClE,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,SAAS,MAAM,MAAM,IAAI,CAAC,WAAW;AAAA,QACnC,OAAO,SAAS;AAAA,MAClB,EAAE;AAAA,MACF,UAAU,MAAM,SAAS,IAAI,aAAa;AAAA,IAC5C;AAAA,EACF;AACF;AAEA,SAAS,cAAc,KAAgC;AACrD,MAAI,IAAI,SAAS;AAAY,UAAM,IAAI,MAAM,qBAAqB;AAClE,SAAO,EAAE,MAAM,aAAa,UAAU,IAAI,SAAS,IAAI,cAAc,EAAE;AACzE;AAEA,SAAS,eAAe,MAAmC;AACzD,MAAI,KAAK,SAAS;AAAa,UAAM,IAAI,MAAM,sBAAsB;AACrE,SAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,MACR;AAAA,QACE,MAAM;AAAA,QACN,UAAU,sBAAsB,KAAK,QAAQ;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AACF;;;ACxCA;AAEO,SAAS,qBAAgC;AAC9C,SAAO;AAAA,IACL;AAAA,MACE,MAAM;AAAA,MACN,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,IACzB;AAAA,EACF;AACF;;;A9BKO,SAAS,cAAc,UAAwC;AACpE,QAAM,WAAsB,CAAC;AAC7B,aAAWC,YAAW,UAAU;AAC9B,aAAS,KAAK,GAAG,aAAaA,QAAO,CAAC;AAAA,EACxC;AACA,SAAO;AACT;AAEO,SAAS,aAAaA,UAAqC;AAChE,UAAQA,SAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aAAO,gBAAgBA,QAAO;AAAA,IAChC,KAAK;AACH,aAAO,eAAeA,QAAO;AAAA,IAC/B,KAAK;AAKH,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE,KAAK;AACH,aAAO,wBAAwBA,QAAO;AAAA,IACxC,KAAK;AACH,aAAO,aAAaA,QAAO;AAAA,IAC7B,KAAK;AACH,aAAO,UAAUA,QAAO;AAAA,IAC1B,KAAK;AACH,aAAO,UAAUA,QAAO;AAAA,IAC1B,KAAK;AAIH,aAAO,eAAeA,QAAO;AAAA,IAC/B,KAAK;AACH,aAAO,WAAWA,QAAO;AAAA,IAC3B,KAAK;AACH,aAAO,mBAAmB;AAAA,IAC5B,KAAK;AAIH,aAAO,CAAC;AAAA,EACZ;AACA,oBAAkBA,QAAO;AAC3B;;;A+B1DA;;;ACAA;;;ACAA;;;ACAA;AA8IO,IAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeT,SAAU,MAAM,MAAM,SAAS,SAAS;AACtC,QAAI,OAAO,SAAS,cAAc,OAAO,YAAY,YAAY;AAC/D,gBAAU;AACV,gBAAU;AACV,aAAO;AAAA,IACT;AAEA,iBAAa,MAAM,MAAM,UAAU,OAAO;AAM1C,aAAS,SAASC,OAAM,SAAS;AAC/B,YAAM,SAAS,QAAQ,QAAQ,SAAS,CAAC;AACzC,aAAO;AAAA,QACLA;AAAA,QACA,SAAS,OAAO,SAAS,QAAQA,KAAI,IAAI;AAAA,QACzC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;;;AF3KJ,IAAMC,OAAM,CAAC,EAAE;AASR,SAAS,YAAYC,OAAM;AAEhC,QAAM,QAAQ,uBAAO,OAAO,IAAI;AAEhC,MAAI,CAACA,SAAQ,CAACA,MAAK,MAAM;AACvB,UAAM,IAAI,MAAM,sCAAsC;AAAA,EACxD;AAEA,QAAMA,OAAM,cAAc,CAACC,gBAAe;AACxC,UAAM,KAAK,MAAMA,YAAW,UAAU;AACtC,QAAI,MAAM,CAACF,KAAI,KAAK,OAAO,EAAE,GAAG;AAC9B,YAAM,EAAE,IAAIE;AAAA,IACd;AAAA,EACF,CAAC;AAED,SAAOA;AAQP,WAASA,YAAW,YAAY;AAC9B,UAAM,KAAK,MAAM,UAAU;AAC3B,WAAO,MAAMF,KAAI,KAAK,OAAO,EAAE,IAAI,MAAM,EAAE,IAAI;AAAA,EACjD;AACF;AAMA,SAAS,MAAM,OAAO;AACpB,SAAO,OAAO,SAAS,EAAE,EAAE,YAAY;AACzC;;;AD/BO,SAAS,qBAAqB,MAAkB;AACrD,QAAMG,cAAa,YAAY,IAAI;AAEnC,QAAY,MAAc,CAAC,GAAGC,QAAO,MAAM;AACzC,UAAMC,QAAO;AACb,UAAM,SAAS;AACf,QACEA,MAAK,SAAS,gBACd,WAAW,QACX,OAAOD,WAAU,UACjB;AACA,aAAO,SAAS,OAAOA,QAAO,CAAC;AAC/B,aAAO,CAAC,MAAMA,MAAK;AAAA,IACrB;AAEA,QAAIC,MAAK,SAAS,oBAAoBA,MAAK,SAAS,iBAAiB;AACnE,YAAM,aACJ,gBAAgBA,SAAQ,OAAOA,MAAK,eAAe,WAC/CA,MAAK,aACL;AACN,YAAM,MAAMF,YAAW,UAAU;AAEjC,UAAI,OAAO,WAAW,QAAQ,OAAOC,WAAU,UAAU;AACvD,cAAM,cACJC,MAAK,SAAS,mBACV,EAAE,MAAM,SAAS,KAAK,IAAI,KAAK,OAAO,IAAI,OAAO,KAAKA,MAAK,IAAI,IAC/D;AAAA,UACE,MAAM;AAAA,UACN,KAAK,IAAI;AAAA,UACT,OAAO,IAAI;AAAA,UACX,UAAUA,MAAK;AAAA,QACjB;AAEN,eAAO,SAASD,MAAK,IAAI;AACzB,eAAO,CAAC,MAAMA,MAAK;AAAA,MACrB;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;AtJjDA,IAAM,SAAS,QAAQ,EAAE,IAAI,oBAAW,EAAE,IAAI,SAAS;AAEhD,SAAS,WAAW,UAAkB;AAC3C,QAAM,MAAM,OAAO,MAAM,QAAQ;AAIjC,uBAAqB,GAAG;AACxB,SAAO;AACT;AAKO,SAASE,OAAM,UAA6B;AACjD,QAAM,MAAM,WAAW,QAAQ;AAQ/B,MAAI,IAAI,SAAS,WAAW,GAAG;AAC7B,WAAO,CAAC,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC;AAAA,EACzD;AAEA,SAAO,cAAc,IAAI,QAA6B;AACxD;;;A0JrCA;;;ACAA;AAOA,SAAS,kBAAkBC,UAA8C;AACvE,SACEA,SAAQ,SAAS,uBACjBA,SAAQ,SAAS,yBACjBA,SAAQ,SAAS;AAErB;AAEO,SAAS,2BAA2B,UAAqB;AAC9D,QAAM,qBAAgC,CAAC;AAMvC,MAAI,gBAAgB;AAEpB,aAAWA,YAAW,UAAU;AAK9B,QAAI,CAAC,kBAAkBA,QAAO,GAAG;AAC/B,yBAAmB,KAAKA,QAAO;AAC/B,sBAAgB;AAChB;AAAA,IACF;AAmBA,UAAM,YACJA,SAAQ,QAAQ,gBAAgB,IAAI,gBAAgB,IAAIA,SAAQ;AAClE,uBAAmB,KAAK,EAAE,GAAGA,UAAS,OAAO,UAAU,CAAC;AACxD,oBAAgB;AAAA,EAClB;AAEA,SAAO;AACT;;;AC3DA;;;ACAA;;;ACAA;;;ACAA;AAOO,SAAS,kBAAkB,UAAwC;AAIxE,MAAI,SAAS,SAAS;AACpB,UAAM,IAAI;AAAA,MACR,+DAA+D,KAAK;AAAA,QAClE;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAKF,SAAO,SAAS,SAAS,IAAI,CAAC,YAAY,QAAQ,IAAI,EAAE,KAAK,EAAE;AACjE;;;ADTO,SAAS,mBAAmB,WAAqC;AACtE,QAAM,QAAkB,CAAC;AAIzB,MAAI,YAAY;AAChB,aAAW,YAAY,UAAU,UAAU;AAIzC,UAAM,aAAa,kBAAkB,QAAQ;AAK7C,UAAM,QAAQ,WAAW,MAAM,SAAS;AACxC,QAAI;AAAO,kBAAY,KAAK,IAAI,WAAW,MAAM,CAAC,EAAE,SAAS,CAAC;AAI9D,UAAM,KAAK,UAAU;AAAA,EACvB;AAKA,QAAM,QAAQ,GAAG,IAAI,OAAO,SAAS,IAAI,UAAU,UAAU;AAC7D,QAAM,KAAK,GAAG,IAAI,OAAO,SAAS,GAAG;AACrC,SAAO,GAAG,MAAM,KAAK,IAAI;AAAA;AAAA;AAC3B;;;AE5CA;;;ACAA;;;ACAA;AAMO,SAAS,yBAAyB,OAAmC;AAC1E,SAAO,MAAM;AACf;;;ACRA;AAwBO,SAAS,yBACd,OACoB;AACpB,MAAI,MAAM,IAAI,WAAW,GAAG;AAAG,WAAO;AACtC,QAAM,EAAE,SAAS,IAAI,SAAS,MAAM,GAAG;AAIvC,MAAI,SAAS,MAAM,oBAAoB,KAAK,MAAM,SAAS,MAAM;AAC/D,WAAO,GAAG,MAAM,YAAY,MAAM,SAAS,MAAM;AACrD;;;AClCA;AASO,SAAS,8BACd,OACoB;AACpB,MAAI,MAAM,SAAS,MAAM,UAAU,MAAM,YAAY,MAAM;AACzD,WAAO,GAAG,MAAM,eAAe,MAAM,YAAY,MAAM,kBAAkB,MAAM,SAAS,MAAM;AAClG;;;AHRA,IAAM,iBAAiB;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AACF;AAEO,SAAS,qBAAqB,OAAmC;AACtE,aAAW,iBAAiB,gBAAgB;AAC1C,UAAM,MAAM,cAAc,KAAK;AAC/B,QAAI,OAAO,QAAQ,UAAU;AAO3B,UAAI,QAAQ;AAAI,eAAO;AACvB,aAAO,KAAK,MAAM,QAAQ,MACxB,OAAO,MAAM,UAAU,WAAW,KAAK,MAAM,WAAW;AAAA,IAE5D;AAAA,EACF;AAKA,QAAM,IAAI,MAAM,oBAAoB;AACtC;;;AD7BO,SAAS,oBAAoBC,UAAoC;AACtE,SAAO,qBAAqBA,QAAO;AACrC;;;AKNA;;;ACAA;AAAA,SAAS,WAAW,cAAc,QAAQC,kBAAiB;;;ACA3D;;;ACAA;AAwBO,SAAS,eACd,cACA,aACA;AACA,QAAM,mBAAmB,YAAY;AAAA,IACnC,CAAC,SAAS,CAAC,aAAa,SAAS,IAAI;AAAA,EACvC;AACA,QAAM,oBAAoB,UAAU,gBAAgB;AACpD,SAAO,EAAE,kBAAkB;AAC7B;;;ACjCA;AAWO,SAAS,kBACd,cACA,aACkE;AAKlE,QAAM,mBAAmB,CAAC,GAAG,YAAY;AAKzC,QAAM,sBAAsB,aAAa;AAAA,IACvC,CAAC,SAAS,CAAC,YAAY,SAAS,IAAI;AAAA,EACtC;AAKA,QAAM,uBAAkC,CAAC;AAUzC,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAK5C,QAAI,oBAAoB,WAAW;AAAG;AAItC,UAAM,eAAe,iBAAiB,IAAI;AAC1C,QAAI,iBAAiB,QAAW;AAC9B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAKA,yBAAqB,KAAK,YAAY;AAWtC,UAAMC,SAAQ,oBAAoB,QAAQ,YAAY;AACtD,QAAIA,WAAU,IAAI;AAChB,0BAAoB,OAAOA,QAAO,CAAC;AAAA,IACrC;AAAA,EACF;AAEA,SAAO,EAAE,sBAAsB,iBAAiB;AAClD;;;AFvDO,SAAS,UAAU,cAAyB,aAAwB;AAazE,QAAM,EAAE,sBAAsB,iBAAiB,IAAI;AAAA,IACjD;AAAA,IACA;AAAA,EACF;AAQA,QAAM,EAAE,kBAAkB,IAAI,eAAe,kBAAkB,WAAW;AAC1E,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,KAAK;AAAA,IACL,kBAAkB,CAAC,GAAG,kBAAkB,GAAG,iBAAiB;AAAA,EAC9D;AACF;;;AGrDA;AAAA,SAAS,WAAAC,gBAAe;;;ACAxB;;;ACAA;;;ACAA;;;ACAA;AAWO,SAAS,oBAAoB;AAAA,EAClC,MAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAAC;AACF,GAA8B;AAC5B,MAAI,CAAC,OAAOD,KAAI,KAAK,CAAC,aAAaA,KAAI,KAAKA,MAAK;AAAM,WAAO;AAC9D,MAAI,CAAC,OAAO,QAAQ,KAAK,CAAC,aAAa,QAAQ,KAAKA,MAAK;AAAM,WAAO;AACtE,QAAM,OAAOC,QAAO,GAAG,EAAE,MAAM,GAAGD,MAAK,OAAO,SAAS,OAAO,CAAC;AAC/D,SAAO;AACT;;;ACrBA;AAIO,SAAS,0BAA0B;AAAA,EACxC,MAAAE;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAAC;AACF,GAA8B;AAC5B,MAAI,CAAC,UAAUD,KAAI;AAAG,WAAO;AAC7B,MAAIA,MAAK,SAAS;AAAU,WAAO;AACnC,EAAAA;AACA,QAAM,aAAaA,MAAK,SAAS,CAAC;AAClC,MAAI,OAAO,UAAU,KAAK,aAAa,UAAU,GAAG;AAElD,IAAAA,MAAK,SAAS,OAAO,GAAG,CAAC;AAEzB,QAAI,OAAO,QAAQ,KAAK,aAAa,QAAQ,GAAG;AAC9C,eAAS,OAAO,GAAG,SAAS,OAAO,WAAW;AAAA,IAChD,OAAO;AACL,YAAM,OAAOC,QAAO,GAAG,EAAE,MAAM,WAAW,KAAK,CAAC;AAAA,IAClD;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,SAAS,wBAAwB;AAAA,EACtC,MAAAD;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAAC;AACF,GAA8B;AAC5B,MAAI,CAAC,UAAUD,KAAI;AAAG,WAAO;AAC7B,MAAIA,MAAK,SAAS;AAAU,WAAO;AACnC,EAAAA;AACA,QAAM,YAAYA,MAAK,SAASA,MAAK,SAAS,SAAS,CAAC;AACxD,MAAI,OAAO,SAAS,KAAK,aAAa,SAAS,GAAG;AAEhD,IAAAA,MAAK,SAAS,OAAOA,MAAK,SAAS,SAAS,GAAG,CAAC;AAEhD,QAAI,OAAO,QAAQ,KAAK,aAAa,QAAQ,GAAG;AAC9C,eAAS,OAAO,GAAG,UAAU,OAAO,SAAS;AAAA,IAC/C,OAAO;AACL,YAAM,OAAOC,SAAQ,GAAG,GAAG,EAAE,MAAM,UAAU,KAAK,CAAC;AAAA,IACrD;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;AClDA;AAGO,SAAS,qBAAqB,EAAE,MAAAC,MAAK,GAA8B;AACxE,MAAI,CAAC,UAAUA,KAAI;AAAG,WAAO;AAC7B,MAAIA,MAAK,SAAS;AAAQ,WAAO;AACjC,MAAIA,MAAK,SAAS,SAAS;AAAG,WAAO;AACrC,EAAAA,MAAK,SAAS,KAAK,EAAE,MAAM,GAAG,CAAC;AAC/B,SAAO;AACT;;;ACTA;AAqBO,SAAS,4BAA4B;AAAA,EAC1C,MAAAC;AAAA,EACA;AAAA,EACA,OAAAC;AACF,GAA8B;AAC5B,MAAI,CAAC,OAAOD,KAAI;AAAG,WAAO;AAC1B,MAAI,aAAaA,KAAI;AAAG,WAAO;AAI/B,MAAIA,MAAK;AAAM,WAAO;AACtB,QAAM,QAAQA,MAAK,KAAK,MAAM,mBAAmB;AACjD,MAAI,CAAC;AAAO,WAAO;AACnB,MAAI,MAAM,CAAC,EAAE,WAAW,KAAK,MAAM,CAAC,EAAE,WAAW;AAAG,WAAO;AAC3D,QAAM,eAAuB;AAAA,IAC3B,EAAE,MAAM,MAAM,CAAC,EAAE;AAAA,IACjB,EAAE,GAAGA,OAAM,MAAM,MAAM,CAAC,EAAE;AAAA,IAC1B,EAAE,MAAM,MAAM,CAAC,EAAE;AAAA,EACnB,EAAE,OAAO,CAACE,UAASA,MAAK,SAAS,EAAE;AACnC,QAAM,OAAOD,QAAO,GAAG,GAAG,YAAY;AACtC,SAAO;AACT;;;AC1CA;AAGO,SAAS,qBAAqB;AAAA,EACnC,OAAAE;AAAA,EACA;AAAA,EACA,MAAAC;AAAA,EACA;AACF,GAA8B;AAC5B,MAAID,WAAU,MAAM,SAAS;AAAG,WAAO;AACvC,MAAI,MAAM,UAAU;AAAG,WAAO;AAC9B,MAAI,CAAC,OAAOC,KAAI;AAAG,WAAO;AAC1B,MAAI,CAAC,aAAaA,KAAI;AAAG,WAAO;AAChC,MAAI,UAAU,UAAU,MAAM,KAAK,OAAO,SAAS,QAAQ;AACzD,UAAM,OAAO,MAAM,SAAS,GAAG,CAAC;AAChC,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;AClBA;AAGO,SAAS,uBAAuB;AAAA,EACrC,OAAAC;AAAA,EACA;AAAA,EACA,MAAAC;AAAA,EACA;AACF,GAA8B;AAC5B,MAAID,WAAU;AAAG,WAAO;AACxB,MAAI,MAAM,WAAW;AAAG,WAAO;AAC/B,MAAI,CAAC,OAAOC,KAAI;AAAG,WAAO;AAC1B,MAAI,CAAC,aAAaA,KAAI;AAAG,WAAO;AAChC,MAAI,UAAU,UAAU,MAAM,KAAK,OAAO,SAAS,QAAQ;AACzD,UAAM,OAAO,GAAG,CAAC;AACjB,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;ANPO,IAAM,cAA6D;AAAA,EACxE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ADFO,SAAS,qBAAqB,kBAAoC;AACvE,aAAW,cAAc,aAAa;AACpC,UAAM,YAAY,WAAW,gBAAgB;AAC7C,QAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;ADnBA,IAAM,aAAa;AAEZ,SAAS,eACd,OACA,QACS;AACT,MAAI,eAAe;AACnB,MAAI;AACJ,MAAI,OAAO;AACX,QAAM,aAAa,MAAM,SAAS,KAAK;AACvC,KAAG;AACD,gBAAY;AACZ,WAAO,OAAO;AACd,QAAI,OAAO;AACT,YAAM,IAAI;AAAA,QACR,mBAAmB;AAAA,MACrB;AACF;AAAa,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAClD,cAAMC,QAAa,MAAM,CAAC;AAK1B,YAAI,UAAUA,KAAI,GAAG;AACnB,gBAAM,oBAAoB;AAAA,YACxBA,MAAK;AAAA,YACLA;AAAA,UACF;AACA,cAAI,mBAAmB;AACrB,wBAAY;AACZ,2BAAe;AACf,kBAAM;AAAA,UACR;AAAA,QACF;AAIA,cAAM,WAA6B,MAAM,IAAI,CAAC;AAC9C,cAAM,WAA6B,MAAM,IAAI,CAAC;AAC9C,cAAM,UAA4B;AAAA,UAChC;AAAA,UACA,MAAAA;AAAA,UACA;AAAA,UACA;AAAA,UACA,OAAO;AAAA,UACP;AAAA,QACF;AAKA,YAAI,qBAAqB,OAAO,GAAG;AACjC,sBAAY;AACZ,yBAAe;AACf,gBAAM;AAAA,QACR;AAAA,MACF;AAAA,EACF,SAAS;AACT,SAAO;AACT;;;ADpDA,IAAM,oBAAoB,CAAC,aAAmC;AAC5D,SAAO,SAAS,IAAI,CAAC,YAAY;AAC/B,QAAIC,SAAQ,UAAU,OAAO,KAAK,QAAQ,SAAS,UAAU;AAC3D,aAAO;AAAA,QACL,GAAG;AAAA,QACH,UAAU,kBAAkB,QAAQ,QAAqB;AAAA,MAC3D;AAAA,IACF,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AAKO,SAAS,cAAc,UAAqB;AAKjD,QAAM,OAAoB;AAAA,IACxB,MAAM;AAAA,IACN,UAAU,kBAAkB,QAAQ;AAAA,EACtC;AACA,iBAAe,CAAC,IAAI,GAAG,MAAS;AAChC,SAAO,KAAK;AACd;;;AUxCA;AAAA,SAAS,QAAQC,kBAAiB;;;ACAlC;AAEO,SAAS,kBAAkBC,OAAoB;AACpD,MAAI,MAAM;AACV,aAAW,SAASA,MAAK,KAAK,SAAS,OAAO,GAAG;AAC/C,UAAM,KAAK,IAAI,KAAK,MAAM,CAAC,EAAE,MAAM;AAAA,EACrC;AACA,MAAI,QAAQ;AAAG,WAAO,KAAKA,MAAK,KAAK,QAAQ,QAAQ,KAAK;AAC1D,SAAO,GAAG,IAAI,OAAO,MAAM,CAAC,KAAKA,MAAK,QAAQ,IAAI,OAAO,MAAM,CAAC;AAClE;;;ACTA;AAMA,SAAS,YAAY,OAAuB;AAC1C,SAAO,MAAM,QAAQ,MAAM,KAAK;AAClC;AAEO,SAAS,gBAAgB,QAA+B;AAC7D,QAAM,oBAAoB,qBAAqB,OAAO,QAAqB;AAC3E,MAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,WAAO;AAAA,MACL,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AACF,MAAI,OAAO,OAAO,UAAU,YAAY,OAAO,MAAM,SAAS,GAAG;AAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcE,IAAI;AAAA,QACF,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF,MAAM,OAAO,SAAS,YAAY,OAAO,KAAK;AAAA;AAAA,EAElD,OAAO;AACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAcE,IAAI;AAAA,QACF,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF,MAAM,OAAO;AAAA;AAAA,EAEjB;AACF;;;AC7DA;AAGO,SAAS,qBAAqBC,OAAoB;AACvD,SAAO,WAAWA,MAAK,IAAI;AAC7B;;;AHIO,SAAS,iBAAiB,SAA0B;AACzD,MAAIC,WAAU,OAAO,OAAO,GAAG;AAM7B,QAAI,QAAQ;AAAM,aAAO,kBAAkB,OAAO;AAIlD,WAAO,qBAAqB,OAAO;AAAA,EACrC;AACA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK,UAAU;AACb,aAAO,gBAAgB,OAAO;AAAA,IAChC;AAAA,IACA,KAAK;AACH,aAAO,qBAAqB,OAAO;AAAA,IACrC;AACE,wBAAkB,OAAO;AAAA,EAC7B;AACF;;;AdJO,SAAS,cACd,eACA,eAA0B,CAAC,GAC3B,gBAA2B,CAAC,GACpB;AAWR,QAAM,WAAW,cAAc,aAAa;AAC5C,QAAM,aAAuB,CAAC;AAW9B,MAAI,cAAc,UAAU,cAAc,oBAAoB,SAAS,CAAC,CAAC,CAAC;AAU1E,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AAIxC,UAAM,UAAU,SAAS,CAAC;AAe1B,QAAIC,WAAU,OAAO,OAAO,KAAK,aAAa,OAAO,GAAG;AACtD,iBAAW,KAAK,QAAQ,IAAI;AAC5B;AAAA,IACF;AAQA,eAAW,KAAK,gCAAgC,YAAY,GAAG,CAAC;AAKhE,eAAW,KAAK,iBAAiB,OAAO,CAAC;AASzC,UAAM,YAAY,aAAa,UAAU,GAAG,aAAa;AACzD,UAAM,eAAe,UAAU,YAAY,kBAAkB,SAAS;AACtE,eAAW,KAAK,gCAAgC,aAAa,MAAM,CAAC;AAKpE,kBAAc;AAAA,EAChB;AACA,SAAO,WAAW,KAAK,EAAE;AAC3B;AAQA,SAAS,aACP,UACAC,QACA,eACW;AAaX,WAAS,IAAIA,SAAQ,GAAG,IAAI,SAAS,QAAQ,KAAK;AAChD,UAAM,UAAU,SAAS,CAAC;AAC1B,QAAI,aAAa,OAAO;AAAG;AAC3B,QAAI,aAAa,UAAU,OAAO,KAAK,QAAQ,SAAS;AACtD;AACF,WAAO,oBAAoB,OAAO;AAAA,EACpC;AACA,SAAO;AACT;;;AkBvJA;AAYO,SAAS,eAAeC,UAA+B;AAC5D,QAAM,QAAkB,CAAC;AACzB,QAAM,KAAK,kBAAkBA,SAAQ,SAAS,CAAC,CAAC,CAAC;AACjD,QAAM,KAAK,iBAAiBA,SAAQ,OAAO,CAAC;AAC5C,EAAAA,SAAQ,SAAS,MAAM,CAAC,EAAE,QAAQ,CAAC,QAAQ;AACzC,UAAM,KAAK,kBAAkB,GAAG,CAAC;AAAA,EACnC,CAAC;AACD,SAAO,GAAG,MAAM,KAAK,IAAI;AAAA;AAAA;AAC3B;AAEA,SAAS,iBAAiB,SAA0C;AAClE,QAAM,YAAY,QAAQ,MAAM,CAAC,WAAW,OAAO,UAAU,MAAM;AAMnE,MAAI,WAAW;AACb,WAAO,IAAI,QAAQ,IAAI,MAAM,KAAK,EAAE,KAAK,GAAG;AAAA,EAC9C;AAMA,SAAO,IAAI,QAAQ,IAAI,CAAC,WAAW,eAAe,OAAO,KAAK,CAAC,EAAE,KAAK,GAAG;AAC3E;AAEA,SAAS,eAAe,OAAyB;AAC/C,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,EACX;AACF;AAEA,SAAS,kBAAkBA,UAAkC;AAC3D,oBAAkBA,UAAS,WAAW;AACtC,SAAO,IAAIA,SAAQ,SAAS,IAAI,kBAAkB,EAAE,KAAK,GAAG;AAC9D;AAEA,SAAS,mBAAmBA,UAAmC;AAC7D,oBAAkBA,UAAS,YAAY;AACvC;AAAA,IACEA,SAAQ,SAAS,WAAW;AAAA,IAC5B,gDAAgD,KAAK;AAAA,MACnDA,SAAQ;AAAA,IACV;AAAA,EACF;AACA,SAAOA,SAAQ,SAAS,IAAI,qBAAqB,EAAE,KAAK;AAC1D;AAEA,SAAS,sBAAsBA,UAAsC;AACnE,oBAAkBA,UAAS,eAAe;AAC1C,SAAO,cAAcA,SAAQ,QAAqB;AACpD;;;A3B9DA,IAAM,mBAAmB;AAElB,SAAS,iBAAiBC,UAAkB,QAA0B;AAC3E,UAAQA,SAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aAAO,IAAI,cAAcA,SAAQ,QAAqB,MACpDA,SAAQ;AAAA,IAEZ,KAAK,eAAe;AAClB,YAAM,QAAQ,kBAAkBA,SAAQ,QAAqB;AAC7D,aAAO,GAAG,MACP,MAAM,IAAI,EACV,IAAI,CAAC,SAAS,KAAK,OAAO,KAAK,CAAC,EAChC,KAAK,IAAI;AAAA;AAAA;AAAA,IACd;AAAA,IACA,KAAK;AACH,aAAO,mBAAmBA,QAAO;AAAA,IACnC,KAAK;AACH,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF,KAAK;AACH,aAAO,GAAG,IAAI,OAAOA,SAAQ,KAAK,KAAK;AAAA,QACrCA,SAAQ;AAAA,MACV;AAAA;AAAA;AAAA,IACF,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO,GAAG,cAAcA,SAAQ,QAAqB;AAAA;AAAA;AAAA,IAIvD,KAAK;AACH,aAAO,eAAeA,QAAO;AAAA,IAC/B,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACH,YAAM,IAAI;AAAA,QACR,6GAA6GA,SAAQ;AAAA,MACvH;AAAA,IAIF,KAAK,uBAAuB;AAC1B,YAAMC,UAAS,IAAI,OAAOD,SAAQ,QAAQ,gBAAgB;AAC1D,aAAO,GAAGC,YAAW,cAAcD,SAAQ,QAAqB;AAAA;AAAA;AAAA,IAClE;AAAA,IACA,KAAK,qBAAqB;AACxB,YAAMC,UAAS,IAAI,OAAOD,SAAQ,QAAQ,gBAAgB;AAC1D,aAAO,GAAGC,UAAS,OAAOD,SAAQ,KAAK,MAAM;AAAA,QAC3CA,SAAQ;AAAA,MACV;AAAA;AAAA;AAAA,IACF;AAAA,IACA,KAAK,kBAAkB;AACrB,YAAMC,UAAS,IAAI,OAAOD,SAAQ,QAAQ,gBAAgB;AAC1D,UAAI,OAAO,cAAcA,SAAQ,QAAqB;AACtD,UAAI,KAAK,KAAK,MAAM,IAAI;AACtB,eAAO;AAAA,MACT;AACA,aAAO,GAAGC,aAAYD,SAAQ,UAAU,MAAM,QAAQ;AAAA;AAAA;AAAA,IACxD;AAAA,IACA,KAAK;AACH,aAAO,oBAAoBA,QAAO;AAAA,IACpC,KAAK;AACH,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,EACJ;AACA,oBAAkBA,QAAO;AAC3B;;;AD1EO,SAAS,kBAAkB,UAA6B;AAC7D,QAAM,WAAqB,CAAC;AAM5B,MAAI,SAAmB,CAAC;AAExB,aAAWE,YAAW,UAAU;AAC9B,QAAIA,SAAQ,SAAS,qBAAqB;AAKxC,aAAOA,SAAQ,KAAK,KAAK,OAAOA,SAAQ,KAAK,KAAK,KAAK;AACvD,eAAS,OAAO,MAAM,GAAGA,SAAQ,QAAQ,CAAC;AAAA,IAC5C,WACEA,SAAQ,SAAS,yBACjBA,SAAQ,SAAS,kBACjB;AAKA,eAAS,OAAO,MAAM,GAAGA,SAAQ,KAAK;AAAA,IACxC,OAAO;AAKL,eAAS,CAAC;AAAA,IACZ;AAEA,aAAS,KAAK,iBAAiBA,UAAS,MAAM,CAAC;AAAA,EACjD;AAOA,QAAM,SAAS,SAAS,KAAK,EAAE;AAK/B,MAAI,OAAO,KAAK,MAAM;AAAI,WAAO;AAMjC,SAAO,2BAA2B,uBAAuB,MAAM,CAAC,EAAE,KAAK;AACzE;AAMA,SAAS,uBAAuB,OAAuB;AACrD,SAAO,MAAM,QAAQ,UAAU,YAAY;AAC7C;AAOA,SAAS,2BAA2B,OAAuB;AACzD,SAAO,MAAM,QAAQ,aAAa,CAAC,UAAU;AAC3C,UAAM,eAAe,MAAM;AAC3B,UAAM,QAAQ,KAAK,OAAO,eAAe,KAAK,CAAC;AAC/C,WAAO,SAAS,MAAM,KAAK,EAAE,KAAK,QAAQ,EAAE,KAAK,MAAM,IAAI;AAAA,EAC7D,CAAC;AACH;;;AF1EO,SAASC,WAAU,UAA6B;AACrD,QAAM,qBAAqB,2BAA2B,QAAQ;AAC9D,SAAO,kBAAkB,kBAAkB;AAC7C;;;A+BPA;;;ACAA;;;ACAA;AA6BO,IAAM,eAAe,CAC1B,OACG;AACH,SAAO,EAAE,GAAG;AACd;;;ACjCA;;;ACAA;AAAA,SAAS,WAAW,eAAe;AACnC,SAAS,cAAc;AACvB,SAAS,sBAAsB;;;ACF/B;;;ACAA;AAAO,SAAS,QAAW,OAAkC;AAC3D,SAAO,CAAC,CAAC;AACX;;;ADWO,SAAS,eACd,YACAC,UACwC;AACxC,QAAM,MAAMA,SACT,IAAI,CAAC,WAAW,OAAO,eAAe,QAAQ,EAC9C,OAAO,OAAO;AACjB,SAAO,SAAU,OAA2B;AAC1C,UAAM,SAAkB,CAAC;AACzB,eAAW,MAAM,KAAK;AACpB,YAAM,eAAe,GAAG,KAAK;AAC7B,aAAO,KAAK,GAAG,YAAY;AAAA,IAC7B;AACA,QAAI;AAAY,aAAO,KAAK,GAAG,WAAW,KAAK,CAAC;AAChD,WAAO;AAAA,EACT;AACF;;;AE7BA;AAAA,SAAS,gBAAgB;AAoB+B;AARjD,SAAS,eACdC,UAC2B;AAC3B,QAAM,MAAMA,SAAQ,IAAI,CAAC,WAAW,OAAO,cAAc,EAAE,OAAO,OAAO;AAKzE,MAAI,wBAAwB,CAAC,UAAyB,oBAAC,YAAU,GAAG,OAAO;AAK3E,aAAW,MAAM,KAAK;AAKpB,UAAM,qBAAqB;AAE3B,4BAAwB,CAAC,UAAyB;AAShD,aAAO,GAAG;AAAA,QACR,YAAY;AAAA,QACZ,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AAoCT;;;ACpFA;AA0DA,SAAS,mBAGPC,UACAC,MAC+D;AAC/D,QAAM,MAAqE,CAAC;AAC5E,aAAW,UAAUD,UAAS;AAC5B,UAAM,UAAU,OAAO,gBAAgBC,IAAG;AAC1C,QAAI;AAAS,UAAI,KAAK,OAAO;AAAA,EAC/B;AACA,SAAO;AACT;AAYA,SAAS,gBACP,KACA,YACA;AACA,SAAO,SAAU,OAAU;AACzB,eAAW,MAAM,KAAK;AACpB,UAAI,GAAG,KAAK;AAAG;AAAA,IACjB;AACA,iBAAa,KAAK;AAAA,EACpB;AACF;AAKO,IAAM,kBAA8C,CACzD,YACAD,aACG;AACH,QAAM,MAAM,mBAAmBA,UAAS,WAAW;AACnD,SAAO,gBAAgB,KAAK,UAAU;AACxC;AAKO,IAAM,gBAA0C,CACrD,YACAA,aACG;AACH,QAAM,MAAM,mBAAmBA,UAAS,SAAS;AACjD,SAAO,gBAAgB,KAAK,UAAU;AACxC;AAKO,IAAM,gBAA0C,CACrD,YACAA,aACG;AACH,QAAM,MAAM,mBAAmBA,UAAS,SAAS;AACjD,SAAO,gBAAgB,KAAK,UAAU;AACxC;AAKO,IAAM,eAAwC,CAAC,YAAYA,aAAY;AAC5E,QAAM,MAAM,mBAAmBA,UAAS,QAAQ;AAChD,SAAO,gBAAgB,KAAK,UAAU;AACxC;;;ACrIA;AAkBO,SAAS,oBACd,YACAE,UAC6C;AAC7C,QAAM,MAAMA,SACT,IAAI,CAAC,WAAW,OAAO,eAAe,aAAa,EACnD,OAAO,OAAO;AACjB,SAAO,SAASC,eACd,oBACa;AACb,eAAW,MAAM,KAAK;AACpB,YAAM,SAAS,GAAG,kBAAkB;AACpC,UAAI;AAAQ,eAAO;AAAA,IACrB;AACA,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI;AAAA,QACR,qBAAqB,mBAAmB,QAAQ;AAAA,MAClD;AAAA,IACF;AACA,WAAO,WAAW,kBAAkB;AAAA,EACtC;AACF;;;ACvCA;AAAA,SAAS,oBAAoB;AAgBtB,SAAS,iBACd,YACAC,UAC0C;AAC1C,MAAI,eAAe,QAAW;AAC5B,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AAQA,QAAM,MAAMA,SACT,IAAI,CAAC,WAAW,OAAO,eAAe,UAAU,EAChD,OAAO,OAAO,EACd,QAAQ;AAEX,SAAO,SAAU,iBAAiB;AAChC,QAAI,QAAQ,WAAW;AAAA,MACrB,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASH,YAAY,CAAC;AAAA,IACf,CAAC;AACD,eAAW,MAAM,KAAK;AACpB,YAAM,gBAAgB,GAAG;AAAA,QACvB,GAAG;AAAA,QACH,UAAU;AAAA,MACZ,CAAC;AACD,UAAI,eAAe;AACjB,gBAAQ;AAAA,MACV;AAAA,IACF;AACA,YAAQ,aAAa,OAAO,gBAAgB,UAAU;AACtD,WAAO;AAAA,EACT;AACF;;;AC5DA;AAkBO,SAAS,wBACd,YACAC,UAC6D;AAC7D,MAAI;AAAY,WAAO;AACvB,QAAM,MAAMA,SACT,IAAI,CAAC,WAAW,OAAO,eAAe,iBAAiB,EACvD,OAAO,OAAO;AACjB,MAAI,IAAI,WAAW;AAAG,WAAO;AAC7B,SAAO,SACL,wBACa;AACb,QAAI,IAAI,SAAS,GAAG;AAClB,YAAM,IAAI;AAAA,QACR,8DAA8D,IAAI;AAAA,MACpE;AAAA,IACF;AACA,UAAM,KAAK,IAAI,CAAC;AAChB,QAAI,MAAM;AAAM,YAAM,IAAI,MAAM,2BAA2B;AAC3D,WAAO,GAAG,sBAAsB;AAAA,EAClC;AACF;;;ACvCA;AAAA,OAAO,YAAY;AAEZ,IAAM,YAAY,OAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ARmG5B,gBAAAC,YAAA;AA9EF,SAAS,aAAa,eAA2C;AACtE,QAAM,SAAS,eAAe;AAwB9B,YAAU,MAAM;AACd,WAAO,UAAU,QAAQ,EAAE,OAAO,KAAK,CAAC;AAAA,EAC1C,GAAG,CAAC,CAAC;AAEL,QAAM,EAAE,SAAAC,SAAQ,IAAI,OAAO;AAE3B,QAAM,YAA2B;AAAA,IAC/B,OAAO;AAAA,MACL,GAAG;AAAA,MACH,UAAU,eAAe,cAAc,UAAUA,QAAO;AAAA,MACxD,eAAe,oBAAoB,cAAc,eAAeA,QAAO;AAAA,MACvE,YAAY,iBAAiB,cAAc,YAAYA,QAAO;AAAA,MAC9D,mBAAmB;AAAA,QACjB,cAAc;AAAA,QACdA;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,WAAW,gBAAgB,cAAc,WAAWA,QAAO;AAAA,MAC3D,SAAS,cAAc,cAAc,SAASA,QAAO;AAAA,MACrD,SAAS,cAAc,cAAc,SAASA,QAAO;AAAA,MACrD,QAAQ,aAAa,cAAc,QAAQA,QAAO;AAAA,IACpD;AAAA,IACA,OAAO,OAAO,aAAa;AAAA,EAC7B;AAEA,QAAM,eAAe,QAAQ,MAAM,eAAeA,QAAO,GAAG,CAACA,QAAO,CAAC;AAuBrE,SAAO,gBAAAD,KAAC,gBAAc,GAAG,WAAW;AACtC;;;AStGA;;;ACAA;AAeO,SAAS,oBAGd,QACA,WACAE,UAC4B;AAC5B,QAAM,iBAAiB,OAAO,SAAS;AACvC,QAAM,gBAAgBA,SAAQ,OAAO,CAAC,WAAW,OAAO,SAAS,SAAS,CAAC;AAC3E,SAAO,SAAS,kBAAkBC,OAAqB;AACrD,eAAW,UAAU,eAAe;AAGlC,YAAM,SAAS,OAAO,SAAS,SAAS,IAAIA,KAAI;AAChD,UAAI,OAAO,WAAW;AAAW,eAAO;AAAA,IAC1C;AAGA,WAAO,eAAeA,KAAI;AAAA,EAC5B;AACF;;;ACnCA;AAeO,SAAS,iBAUd,QAAoB,WAAcC,UAA6B;AAC/D,QAAM,iBAAiB,OAAO,SAAS;AACvC,QAAM,gBAAgBA,SAAQ,OAAO,CAAC,WAAW,OAAO,SAAS,SAAS,CAAC;AAC3E,SAAO,SAAS,kBAAkB,MAAyC;AACzE,QAAI,YAAY;AAChB,UAAM,wBAAwC,CAAC;AAC/C,eAAW,UAAU,eAAe;AAElC,YAAM,WAAW,OAAO,SAAS,SAAS,IAAI,GAAG,IAAI;AACrD,UAAI,OAAO,aAAa,YAAY;AAClC,8BAAsB,KAAK,QAAQ;AAAA,MACrC,WAAW,aAAa,MAAM;AAC5B,oBAAY;AACZ;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,WAAW;AAEd,qBAAe,GAAG,IAAI;AAAA,IACxB;AACA,0BAAsB,QAAQ,CAAC,aAAa,SAAS,CAAC;AAAA,EACxD;AACF;;;AFzCO,SAAS,eACd,WACA;AAKA,SAAO,CACL,gBACA,YACuB;AACvB,UAAM,SAAS;AAMf,UAAMC,WAAU,UAAU;AAAA,MAAI,CAAC,WAC7B,OAAO,QAAQ,SAAS,EAAE,cAAc,CAAC,MAAM,EAAE,CAAC;AAAA,IACpD;AACA,WAAO,OAAO,EAAE,SAAAA,SAAQ;AAKxB,WAAO,WAAW,cAAc,SAAS,OAAO,WAAW,MAAM;AACjE,WAAO,UAAU,aAAa,SAAS,OAAO,UAAU,MAAM;AAC9D,WAAO,eACL,kBAAkB,SAAS,OAAO,eAAe,MAAM;AAEzD,WAAO,OAAO,QAAQ;AAAA;AAAA;AAAA;AAAA,MAIpB,eAAe,iBAAiB,QAAQ,iBAAiBA,QAAO;AAAA,MAChE,gBAAgB,iBAAiB,QAAQ,kBAAkBA,QAAO;AAAA,MAClE,eAAe,iBAAiB,QAAQ,iBAAiBA,QAAO;AAAA,MAChE,gBAAgB,iBAAiB,QAAQ,kBAAkBA,QAAO;AAAA,MAClE,aAAa,iBAAiB,QAAQ,eAAeA,QAAO;AAAA,MAC5D,gBAAgB,iBAAiB,QAAQ,kBAAkBA,QAAO;AAAA,MAClE,YAAY,iBAAiB,QAAQ,cAAcA,QAAO;AAAA,MAC1D,YAAY,iBAAiB,QAAQ,cAAcA,QAAO;AAAA;AAAA;AAAA;AAAA,MAI1D,UAAU,oBAAoB,QAAQ,YAAYA,QAAO;AAAA,MACzD,QAAQ,oBAAoB,QAAQ,UAAUA,QAAO;AAAA,MACrD,UAAU,oBAAoB,QAAQ,YAAYA,QAAO;AAAA,MACzD,SAAS,oBAAoB,QAAQ,WAAWA,QAAO;AAAA,MACvD,cAAc,oBAAoB,QAAQ,gBAAgBA,QAAO;AAAA,IACnE,CAAC;AAED,WAAO;AAAA,EACT;AACF;;;AVrDO,IAAM,aAAa,CACxB,oBACG;AACH,QAAM,MAAM,gBAAgB,IAAI,CAAC,WAAW,OAAO,EAAE;AACrD,QAAMC,YAAW,eAAkB,GAAG;AAEtC,QAAM,cAAc,EAAE,UAAAA,WAAU,aAAa;AAC7C,SAAO;AACT;;;AafA;AAAO,IAAM,UAAU;;;ACAvB;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;;;ACAA;AAAA,SAAiB,WAAAC,gBAAyB;AAC1C,SAAS,mBAAmB;AAarB,SAAS,SAAS,QAAgB,IAAkC;AACzE,MAAI,CAACA,SAAQ,UAAU,EAAE;AAAG,WAAO;AACnC,SAAO,YAAY,SAAS,QAAQ,EAAE;AACxC;;;ACjBA;AA+BO,SAAS,SACd,IACA,YAC0B;AAC1B,SAAO,GAAG,KAAK,MAAM,UAAU;AACjC;AAKO,SAAS,SACd,IACA,MACA,MAC0B;AAC1B,SAAO,GAAG,KAAK,MAAM,MAAM,IAAI;AACjC;;;AC/CA;AAAA,IAAM,eAAe;AAErB,IAAI,aAAkC;AAM/B,SAAS,QAAQ;AAItB,MAAI,eAAe;AAAW,WAAO;AACrC,QAAM,EAAE,UAAU,IAAI,OAAO;AAC7B,eAAa,aAAa,KAAK,SAAS;AACxC,SAAO;AACT;;;AChBA;AAIO,SAAS,UAAU,GAAiC;AACzD,IAAE,eAAe;AACjB,IAAE,gBAAgB;AACpB;;;ACPA;AAAA,SAAmB,UAAAC,SAA4B,YAAY;;;ACA3D;AAAA,SAAS,WAAAC,gBAAqB;AAavB,SAAS,uBACd,WACyB;AACzB,MAAI,OAAO,cAAc;AAAY,WAAO;AAC5C,MAAI,OAAO,cAAc;AACvB,WAAO,CAACC,UAAeD,SAAQ,UAAUC,KAAI,KAAKA,MAAK,SAAS;AAClE,MAAI,MAAM,QAAQ,SAAS;AACzB,WAAO,CAACA,UACND,SAAQ,UAAUC,KAAI,KAAK,UAAU,SAASA,MAAK,IAAI;AAC3D,QAAM,IAAI;AAAA,IACR,+DAA+D;AAAA,EACjE;AACF;;;ADbO,SAAS,cACd,QACA,WACA,EAAE,KAAK,OAAO,UAAU,IAAuB,CAAC,GACtB;AAE1B,MAAI,OAAO;AAAM;AACjB,QAAM,SAAS,SAAS,QAAQ,EAAE;AAClC,QAAM,QAAQ,uBAAuB,SAAS;AAO9C,MAAI,KAAK,OAAO,MAAM,GAAG;AACvB,UAAM,qBAAqBC,QAAO,KAAK,QAAQ,MAAM;AACrD,QAAI,sBAAsB,MAAM,mBAAmB,CAAC,CAAC,GAAG;AACtD,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAOA,QAAO,MAAM,QAAQ,EAAE,IAAI,QAAQ,MAAM,CAAC;AACnD;AAEO,SAAS,qBAAqB,MAAwC;AAC3E,QAAM,QAAQ,cAAc,GAAG,IAAI;AACnC,SAAO,QAAQ,CAAC;AAClB;;;AExCA;AAuBE,gBAAAC,YAAA;AAJK,IAAM,aAAa,CAAC;AAAA,EACzB,cAAc;AAAA,EACd,GAAG;AACL,MACE,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,OAAM;AAAA,IACN,QAAO;AAAA,IACP;AAAA,IACA,QAAO;AAAA,IACP,MAAK;AAAA,IACL,eAAc;AAAA,IACd,gBAAe;AAAA,IACf,SAAQ;AAAA,IACP,GAAG;AAAA;AACN;;;AClCF;;;ACAA;AAAA,SAAS,aAAa;AAEf,SAAS,YACd,WACoB;AACpB,MAAI,aAAa;AAAM,WAAO;AAC9B,SAAO,MAAM,YAAY,SAAS;AACpC;;;ACPA;AAAA,SAAS,WAAAC,gBAAqB;AAiBvB,SAAS,oBACd,MAC2B;AAC3B,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO,CAACC,UACNC,SAAQ,UAAUD,KAAI,KAAK,KAAK,SAASA,MAAK,IAAI;AAAA,EACtD,OAAO;AACL,WAAO,CAACA,UACNC,SAAQ,UAAUD,KAAI,KAAK,QAAQA,MAAK;AAAA,EAC5C;AACF;;;AC3BA;AAAA,SAAS,UAAAE,eAAc;AAehB,SAAS,eACd,QACA,WACS;AACT,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,CAAC,YAAY,SAAS;AAAG,WAAO;AACpC,QAAM,QAAQ,cAAc,QAAQ,WAAW,EAAE,IAAI,UAAU,CAAC;AAChE,SAAO,CAAC,CAAC,SAASC,QAAO,MAAM,QAAQ,UAAU,QAAQ,MAAM,CAAC,CAAC;AACnE;;;ACvBA;AAAA,SAAS,UAAAC,eAAc;;;ACAvB;AAAA,SAAS,UAAAC,eAAc;AAehB,SAAS,iBACd,QACA,WACS;AACT,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,CAAC,YAAY,SAAS;AAAG,WAAO;AACpC,QAAM,QAAQ,cAAc,QAAQ,WAAW,EAAE,IAAI,UAAU,CAAC;AAChE,SAAO,CAAC,CAAC,SAASC,QAAO,QAAQ,QAAQ,UAAU,QAAQ,MAAM,CAAC,CAAC;AACrE;;;ACvBA;;;ACAA;AAAA,SAAS,gBAAgB;AACzB,SAAS,UAAAC,SAAQ,WAAWC,eAAc,SAAAC,QAAO,kBAAkB;AAI5D,IAAM,UAAU,SAAS,GAAG;AAC5B,IAAM,eAAe,SAAS,aAAa;AAE3C,SAAS,+BACd,QACA,SACA;AACA,SAAO,CAAC,MAA6D;AAOnE,QAAI,CAAC,QAAQ,EAAE,WAAW,KAAK,CAAC,aAAa,EAAE,WAAW;AAAG,aAAO;AAKpE,UAAM,EAAE,UAAU,IAAI;AACtB,QAAI,cAAc;AAAM,aAAO;AAC/B,QAAIC,OAAM,WAAW,SAAS;AAAG,aAAO;AAKxC,UAAM,wBAAwB;AAAA,MAC5B;AAAA,MACA,CAACC;AAAA;AAAA;AAAA;AAAA;AAAA,QAKCC,cAAa,UAAUD,KAAI,KAC3B,OAAO,eAAe,qBAAqBA,KAAI;AAAA;AAAA,IACnD;AACA,QAAI,CAAC;AAAuB,aAAO;AAQnC,UAAM,QAAQ;AAAA,MACZ,QAAQE,QAAO,MAAM,QAAQ,sBAAsB,CAAC,CAAC;AAAA,MACrD,OAAO,UAAU;AAAA,IACnB;AACA,UAAMC,QAAOD,QAAO,OAAO,QAAQ,KAAK;AACxC,UAAM,SAAS,QAAQC,KAAI;AAC3B,QAAI,CAAC;AAAQ,aAAO;AAKpB,cAAU,CAAC;AAKX,UAAM,cAAc;AAAA,MAClB,QAAQD,QAAO,MAAM,QAAQ,sBAAsB,CAAC,CAAC;AAAA,MACrD,OAAO,UAAU;AAAA,IACnB;AACA,eAAW,OAAO,QAAQ,EAAE,IAAI,YAAY,CAAC;AAK7C,WAAO;AACP,WAAO;AAAA,EACT;AACF;;;AC7EA;;;ACAA;AAAA,SAAS,YAAAE,iBAAgB;AAIlB,SAAS,eAAe,QAAgB;AAC7C,QAAM,iBAAiB,OAAO;AAAA,IAC5B;AAAA,IACA,MAAM,IAAI,YAAY;AAAA,EACxB;AACA,SAAOC,UAAS,cAAc;AAChC;;;ADiBO,SAAS,oBAAoB,iBAAyC;AAO3E,MAAI,YAAoC;AAExC,SAAO,SAAS,gBACd,OACA;AAIA,QAAI,aAAa,MAAM;AACrB,kBAAY,OAAO,QAAQ,eAAe,EAAE,IAAI,CAAC,CAAC,UAAU,EAAE,MAAM;AAAA,QAClE,eAAe,QAAQ;AAAA,QACvB;AAAA,MACF,CAAC;AAAA,IACH;AACA,eAAW,CAAC,YAAY,MAAM,KAAK,WAAW;AAC5C,UAAI,WAAW,MAAM,WAAW,GAAG;AAKjC,cAAM,WAAW,OAAO;AACxB,YAAI,aAAa,QAAQ,aAAa,QAAW;AAC/C,gBAAM,eAAe;AACrB,gBAAM,gBAAgB;AACtB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;;;AEhEA;AAAA,SAAS,UAAAC,SAAc,cAAAC,mBAAkB;AAqBlC,SAAS,mBAAmB,QAAgBC,OAAY;AAC7D,EAAAF,QAAO,mBAAmB,QAAQ,MAAM;AACtC,IAAAC,YAAW;AAAA,MACT;AAAA;AAAA,MAEA,EAAE,6CAA6C,MAAM;AAAA,MACrD,EAAE,IAAIC,MAAK;AAAA,IACb;AACA,IAAAD,YAAW;AAAA,MACT;AAAA;AAAA,MAEA,EAAE,6CAA6C,KAAK;AAAA,MACpD,EAAE,IAAIC,MAAK;AAAA,IACb;AAAA,EACF,CAAC;AACH;;;ACpCA;AAAA,SAAqB,UAAAC,eAAyB;AA+BvC,SAAS,kBACd,QACA,OACA,WACS;AACT,QAAM,CAAC,EAAEC,KAAI,IAAI;AAEjB,QAAM,YAAYD,QAAO,SAAY,QAAQ,EAAE,IAAIC,MAAK,CAAC;AACzD,MAAI,aAAa,UAAU,WAAW,KAAK;AAAG,WAAO;AAErD,QAAM,YAAYD,QAAO,KAAQ,QAAQ,EAAE,IAAIC,MAAK,CAAC;AACrD,MAAI,aAAa,UAAU,OAAO,SAAS;AAAG,WAAO;AAErD,SAAO;AACT;;;AC7CA;AAAA,SAAS,UAAAC,UAAc,cAAAC,mBAAkB;AAKlC,SAAS,qBAAqB,QAAgBC,OAAY;AAC/D,EAAAD,YAAW,OAAO,QAAQD,SAAO,MAAM,QAAQE,KAAI,CAAC;AACtD;AAKO,SAAS,mBAAmB,QAAgBA,OAAY;AAC7D,EAAAD,YAAW,OAAO,QAAQD,SAAO,IAAI,QAAQE,KAAI,CAAC;AACpD;;;ACdA;;;ACAA;AAoCO,SAAS,oBACd,YACA,eACA;AACA,MAAI,OAAO,kBAAkB;AAAY,WAAO;AAChD,SAAO,cAAc,UAAU;AACjC;;;AC1CA;;;ACAA;AAAA,SAAS,UAAAC,UAAQ,WAAAC,UAAmB,QAAAC,OAAM,cAAAC,mBAAkB;AAarD,SAAS,kBACd,QACAC,UACA,EAAE,KAAK,OAAO,UAAU,IAA8B,CAAC,GAC9C;AAIT,MAAI,MAAM;AAAM,WAAO;AAIvB,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,CAACC,UAASC,SAAQ,UAAUD,KAAI,KAAK,OAAO,SAASA,KAAI;AAAA,EAC3D;AACA,MAAI,SAAS,MAAM;AAMjB,UAAM,YAAY,OAAO;AACzB,IAAAE,SAAO,mBAAmB,QAAQ,MAAM;AACtC,MAAAC,YAAW,YAAY,QAAQJ,UAAS,EAAE,GAAG,CAAC;AAC9C,UAAI,WAAW;AACb,QAAAI,YAAW,OAAO,QAAQ,SAAS;AACnC,QAAAA,YAAW,KAAK,MAAM;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH,OAAO;AAKL,UAAM,WAAWC,MAAK,KAAK,MAAM,CAAC,CAAC;AACnC,IAAAF,SAAO,mBAAmB,QAAQ,MAAM;AACtC,MAAAC,YAAW,YAAY,QAAQJ,UAAS,EAAE,IAAI,SAAS,CAAC;AACxD,MAAAI,YAAW,OAAO,QAAQD,SAAO,MAAM,QAAQ,QAAQ,CAAC;AAAA,IAC1D,CAAC;AAAA,EACH;AACA,SAAO;AACT;;;ACvDA;AAAA,SAAS,UAAAG,UAAkC,cAAAC,mBAAkB;AActD,SAAS,cACd,QACA,eACA,IACA;AACA,EAAAC,SAAO,mBAAmB,QAAQ,MAAM;AACtC,UAAM,gBAAgBA,SAAO,KAAK,QAAQ,EAAE;AAC5C,UAAM,cAAc,oBAAoB,cAAc,CAAC,GAAG,aAAa;AAKvE,IAAAC,YAAW,UAAU,QAAQ,aAAkB,EAAE,GAAG,CAAC;AACrD,IAAAA,YAAW,YAAY,QAAQ,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;AAAA,EACnD,CAAC;AACH;;;AC7BA;AAAA,SAAS,UAAAC,UAAkC,cAAAC,mBAAkB;AAatD,SAAS,gBACd,QACAC,UACA,SACA;AACA,QAAM,UAAU,MAAM,KAAKF,SAAO,MAAS,QAAQ,OAAO,CAAC;AAC3D,MAAI,QAAQ,WAAW;AAAG,WAAO;AACjC,aAAW,SAAS,SAAS;AAC3B,UAAM,CAACG,KAAI,IAAI;AACf,IAAAF,YAAW,SAAS,QAAQC,SAAQC,KAAI,GAAG,EAAE,IAAI,MAAM,CAAC,EAAE,CAAC;AAAA,EAC7D;AACA,SAAO;AACT;;;ACzBA;;;ACAA;;;ACAA;AAEO,SAAS,QACd,QACA,GACA;AACA,QAAM,gBAAgB,EAAE;AACxB,QAAM,EAAE,MAAM,IAAI;AAElB,UAAQ,IAAI,cAAc,QAAQ,WAAW,CAAC;AAO9C,MAAI,MAAM,SAAS;AAAG,WAAO;AAC7B,MAAI,MAAM,CAAC,MAAM;AAAc,WAAO;AAKtC,QAAMC,QAAO,cAAc,QAAQ,YAAY;AAC/C,MAAI,CAACC,OAAMD,KAAI;AAAG,WAAO;AAKzB,IAAE,eAAe;AACjB,IAAE,gBAAgB;AAClB,SAAO,OAAO,WAAWA,KAAI;AAC7B,SAAO;AACT;AACA,SAASC,OAAM,GAAoB;AACjC,MAAI;AACJ,MAAI;AACF,UAAM,IAAI,IAAI,CAAC;AAAA,EACjB,SAAS,GAAP;AACA,WAAO;AAAA,EACT;AACA,SACE,IAAI,aAAa,WACjB,IAAI,aAAa,YACjB,IAAI,aAAa;AAErB;;;AC7CA;;;ACAA;AAAA,SAAiB,cAAAC,mBAAkB;AAK5B,SAAS,SACd,QACA,EAAE,MAAM,MAAM,GACd,EAAE,GAAG,GACL;AACA,QAAM,OAAO,cAAc,QAAQ,UAAU,EAAE,GAAG,CAAC;AACnD,MAAI,CAAC;AAAM,WAAO;AAClB,EAAAC,YAAW,SAAwB,QAAQ,EAAE,MAAM,MAAM,GAAG,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC;AAC3E,SAAO;AACT;;;ACdA;AAAA,SAAS,UAAAC,UAAQ,SAAAC,QAAO,QAAAC,OAAM,cAAAC,mBAAkB;AAEzC,SAAS,WACd,QACA,MACAC,QAAe,MACf,EAAE,SAAS,KAAK,IAA0B,CAAC,GAC3C;AAIA,QAAM,YAAY,OAAO,aAAa;AAAA,IACpC,QAAQJ,SAAO,MAAM,QAAQ,CAAC,CAAC,CAAC;AAAA,IAChC,OAAOA,SAAO,MAAM,QAAQ,CAAC,CAAC,CAAC;AAAA,EACjC;AACA,MAAIC,OAAM,YAAY,SAAS,GAAG;AAIhC,IAAAE,YAAW;AAAA,MACT;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN;AAAA,QACA,UAAU,CAAC,EAAE,MAAAC,MAAK,CAAC;AAAA,MACrB;AAAA,MACA,EAAE,QAAQ,IAAI,UAAU;AAAA,IAC1B;AAIA,QAAI,UAAU,OAAO,WAAW;AAC9B,YAAM,QAAQJ,SAAO,KAAK,QAAQ,OAAO,SAAS;AAClD,MAAAG,YAAW,OAAO,QAAQ,MAAM,CAAC,CAAC;AAAA,IACpC;AAAA,EACF,OAAO;AAIL,IAAAA,YAAW;AAAA,MACT;AAAA,MACA,EAAE,MAAM,UAAU,MAAM,UAAU,CAAC,EAAE;AAAA,MACrC;AAAA,QACE,OAAO;AAAA,QACP,OAAO,CAACE,UAASH,MAAK,OAAOG,KAAI,KAAKL,SAAO,SAAS,QAAQK,KAAI;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AACF;;;AChDA;AAAA,SAAiB,cAAAC,mBAAkB;AAI5B,SAAS,WAAW,QAAgB,EAAE,GAAG,GAAsB;AACpE,QAAM,OAAO,cAAc,QAAQ,UAAU,EAAE,GAAG,CAAC;AACnD,MAAI,CAAC;AAAM,WAAO;AAClB,EAAAC,YAAW,YAAY,QAAQ,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC;AAC9C,SAAO;AACT;;;AHDO,SAAS,oBAAoB,QAAgB;AAClD,SAAO;AAAA,IACL,YAAY,SAAS,YAAY,MAAM;AAAA,IACvC,YAAY,SAAS,YAAY,MAAM;AAAA,IACvC,UAAU,SAAS,UAAU,MAAM;AAAA,EACrC;AACF;;;AIdA;AAAA,SAAiB,WAAAC,UAA0B,cAAAC,oBAAkB;AAuBtD,SAAS,cAAc,QAAgB,OAAiC;AAC7E,MAAI,CAACD,SAAQ,UAAU,MAAM,CAAC,CAAC;AAAG,WAAO;AACzC,MAAI,MAAM,CAAC,EAAE,SAAS;AAAU,WAAO;AACvC,QAAM,WAAW,MAAM,CAAC,EAAE;AAC1B,WAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,UAAM,QAAQ,SAAS,CAAC;AACxB,QAAI,CAACA,SAAQ,UAAU,KAAK,KAAK,MAAM,SAAS;AAAU;AAC1D,IAAAC,aAAW,YAAY,QAAQ,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;AACvD,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;AClCA;AAAA,SAAS,YAAY;AACrB,SAAS,aAAAC,YAAW,UAAAC,eAAc;AAClC,SAAS,mBAAmB;;;ACF5B;;;ACAA;AAAA,OAAO,YAAY;AAuBZ,IAAM,oBAAoB,CAC/B,EAAE,UAAU,CAAC,EAAE,IAAyC,EAAE,SAAS,CAAC,EAAE,MACnE;AACH,SAAO,OAAoB,CAAC,KAAK,SAAS;AAAA,IACxC;AAAA,IACA,UAAU,IAAY,QAAsB;AAC1C,UAAI,CAAC,WAAwB;AAAA,QAC3B,SAAS;AAAA,UACP,GAAG,MAAM;AAAA,UACT,CAAC,EAAE,GAAG;AAAA,QACR;AAAA,MACF,EAAE;AAAA,IACJ;AAAA,IACA,UAAU,IAAoB;AAC5B,YAAM,SAAS,IAAI,EAAE,QAAQ,EAAE;AAC/B,UAAI,WAAW,QAAW;AACxB,cAAM,IAAI,MAAM,4BAA4B,2BAA2B;AAAA,MACzE;AACA,aAAO;AAAA,IACT;AAAA,EACF,EAAE;AACJ;;;AC5CA;AAAA,SAAS,kBAAAC,uBAAsB;AAcxB,SAAS,UAAU,KAAqB;AAC7C,QAAM,SAASA,gBAAe;AAK9B,QAAMC,UAAS,OAAO,OAAO,eAAe,CAAC,UAAU,MAAM,QAAQ,GAAG,CAAC;AACzE,MAAI,IAAI,SAAS,GAAG,GAAG;AACrB,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,IACF;AAAA,EACF,OAAO;AACL,WAAOA;AAAA,EACT;AACF;;;AFTO,SAAS,UAAU,QAAgB,IAAYC,SAAgB;AACpE,QAAM,QAAQ,OAAO,OAAO,eAAe,SAAS;AACpD,QAAM,UAAU,IAAIA,OAAM;AAC5B;;;AGvBA;;;ACAA;AAAA,SAAS,eAAe,gBAAgB;;;ACAxC;AAAA,SAAS,oBAAoB;AAWtB,SAAS,OAAO,EAAE,SAAS,GAAkC;AAClE,SAAO,aAAa,UAAU,SAAS,IAAI;AAC7C;;;ADiEI,SAQU,OAAAC,MARV;AArEG,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO3B,CAAC;AACH;AAEO,IAAM,eAAe,cAAqB,CAAC,CAAU;AA4BrD,SAAS,OAAO,EAAE,SAAS,GAAkC;AAClE,QAAM,CAAC,QAAQ,SAAS,IAAI,SAAuB,CAAC,CAAC;AAKrD,WAAS,UAAU,OAAc;AAC/B,cAAU,CAACC,YAAW;AACpB,aAAO;AAAA,QACL,GAAGA;AAAA,QACH,CAAC,MAAM,IAAI,GAAG;AAAA,MAChB;AAAA,IACF,CAAC;AAAA,EACH;AAKA,WAAS,WAAW,WAAmB;AACrC,cAAU,CAACA,YAAW;AACpB,YAAM,aAAa,EAAE,GAAGA,QAAO;AAC/B,aAAO,WAAW,SAAS;AAC3B,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAMA,SACE;AAAA,IAAC,cAAc;AAAA,IAAd;AAAA,MACC,OAAO,EAAE,QAAQ,WAAW,WAAW,WAAW;AAAA,MAEjD;AAAA;AAAA,QACA,OAAO,QAAQ,MAAM,EAAE,IAAI,CAAC,CAAC,EAAE,KAAK,MAAM;AACzC,iBACE,gBAAAD,KAAC,UACC,0BAAAA,KAAC,aAAa,UAAb,EAAsB,OAAO,OAC5B,0BAAAA,KAAC,MAAM,WAAN,EAAgB,GACnB,KAHW,MAAM,IAInB;AAAA,QAEJ,CAAC;AAAA;AAAA;AAAA,EACH;AAEJ;;;AE7FA;AAAA,SAA4B,kBAAkB;AAuDvC,SAAS,SAAS,MAAc;AACrC,QAAM,EAAE,WAAW,YAAY,OAAO,IAAI,WAAW,aAAa;AAkElE,WAAS,KAAK,WAAqD;AACjE,UAAM,QAAe,EAAE,MAAM,UAAU;AACvC,cAAU,KAAK;AAAA,EACjB;AAKA,WAAS,QAAQ;AACf,eAAW,IAAI;AAAA,EACjB;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO,OAAO,IAAI;AAAA,IAClB;AAAA,EACF;AACF;;;AC5IA;AAAA,OAAOE,aAAY;AAEZ,IAAM,UAAUA,QAAO,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyB1B,IAAM,QAAQA,QAAO,MAAM;AAAA;AAAA;AAAA;AAQ3B,IAAM,eAAeA,QAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAclC,IAAM,mBAAmBA,QAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACjD7C;AAAA,OAAOC,cAAY;AACnB,SAAS,eAAAC,oBAAmB;AAC5B,SAAS,kBAAAC,uBAAsB;;;ACF/B;;;ACAA;;;ACAA;AAAA,SAAgB,cAAc;;;ACA9B;AAAA,OAAOC,aAAY;AAEZ,IAAM,aAAaA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADU7B,gBAAAC,YAAA;AAFF,SAAS,UAAU,EAAE,MAAM,GAA0B;AAC1D,QAAM,MAAM,OAAuB,IAAI;AACvC,SAAO,gBAAAA,KAAC,cAAW,KAAU,SAAS,OAAO;AAC/C;;;AEbA;;;ACAA;AASO,IAAM,MAAM;AAAA,EACjB,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,OAAO;AACT;AAEA,IAAM,WAAW;AAAA,EACf,OAAO,IAAI;AAAA,EACX,KAAK,IAAI;AAAA,EACT,KAAK,IAAI;AAAA,EACT,MAAM,IAAI;AAAA,EACV,KAAK,IAAI;AAAA,EACT,KAAK,IAAI;AAAA,EACT,OAAO,IAAI;AAAA,EACX,OAAO,GAAG,IAAI,MAAM,IAAI;AAC1B;AAEA,IAAM,UAAU;AAAA,EACd,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO,IAAI;AAAA,EACX,OAAO;AACT;AAEA,SAAS,KAAQ,KAAU,OAAgB;AACzC,QAAMC,SAAgB,IAAI,UAAU,CAAC,OAAU,OAAO,KAAK;AAC3D,MAAIA,WAAU,IAAI;AAChB,QAAI,OAAOA,QAAO,CAAC;AAAA,EACrB;AACF;AAEA,SAAS,UAAU,UAAoB;AACrC,QAAM,SAAS,CAAC;AAChB,SAAO,QAAQ,QAAQ,EAAE,QAAQ,CAAC,CAACC,MAAK,MAAM,MAAM;AAClD,QAAI,SAAS,SAASA,IAAG,GAAG;AAC1B,aAAO,KAAK,MAAM;AAClB,WAAK,UAAUA,IAAG;AAAA,IACpB;AAAA,EACF,CAAC;AACD,SAAO,KAAK,GAAG,SAAS,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AACnD,SAAO,OAAO,KAAK,EAAE;AACvB;AAEA,SAAS,SAAS,UAAoB;AACpC,QAAM,SAAS,CAAC;AAChB,SAAO,QAAQ,OAAO,EAAE,QAAQ,CAAC,CAACA,MAAK,MAAM,MAAM;AACjD,QAAI,SAAS,SAASA,IAAG,GAAG;AAC1B,aAAO,KAAK,MAAM;AAClB,WAAK,UAAUA,IAAG;AAAA,IACpB;AAAA,EACF,CAAC;AACD,SAAO,KAAK,GAAG,SAAS,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;AACnD,SAAO,OAAO,KAAK,GAAG;AACxB;AAEO,SAAS,aAAa,UAAkB;AAC7C,QAAM,WAAW,SAAS,YAAY,EAAE,MAAM,GAAG;AACjD,MAAI,MAAM,GAAG;AACX,WAAO,UAAU,QAAQ;AAAA,EAC3B,OAAO;AACL,WAAO,SAAS,QAAQ;AAAA,EAC1B;AACF;;;AC7EA;AAAA,SAAS,UAAAC,eAAc;AACvB,SAAS,kBAAAC,uBAAsB;;;ACD/B;;;ACAA;;;ACAA;;;ACAA;AAMO,SAAS,aAAa,YAA+B;AAC1D,QAAM,SAAS,WAAW,sBAAsB;AAChD,SAAO;AAAA,IACL,KAAK,OAAO;AAAA,IACZ,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO;AAAA,IACf,MAAM,OAAO;AAAA,IACb,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO;AAAA,EACjB;AACF;;;ADPO,SAAS,gBAAgB,YAA+B;AAC7D,QAAM,OAAO,aAAa,UAAU;AACpC,QAAM,EAAE,QAAQ,IAAI;AACpB,SAAO,OAAO,OAAO,MAAM;AAAA,IACzB,KAAK,KAAK,MAAM;AAAA,IAChB,QAAQ,KAAK,SAAS;AAAA,EACxB,CAAC;AACH;;;AEhBA;;;ACAA;AAMO,SAAS,mBAAyB;AAMvC,QAAM,QACJ,SAAS,gBAAgB,eAAe,SAAS,KAAK;AACxD,SAAO;AAAA,IACL,KAAK;AAAA,IACL,OAAO;AAAA,IACP,QAAQ,OAAO;AAAA,IACf,MAAM;AAAA,IACN;AAAA,IACA,QAAQ,OAAO;AAAA,EACjB;AACF;;;ADbO,SAAS,sBAA4B;AAC1C,QAAM,OAAO,iBAAiB;AAC9B,SAAO,OAAO,OAAO,MAAM;AAAA,IACzB,KAAK,OAAO;AAAA,IACZ,QAAQ,OAAO,UAAU,KAAK;AAAA,EAChC,CAAC;AACH;;;AEfA;AAAA,OAAO,eAAe;AAkBf,SAAS,qCAGd,mBACA,qBACyC;AACzC,QAAM,aAAa,UAAU,mBAAmB,CAAC,UAAU;AACzD,UAAM,mBACJ,iBAAiB,cAAc,QAAQ,MAAM;AAC/C,UAAM,YAAY,mBACd,oBAAoB,gBAAgB,IACpC;AACJ,WAAO;AAAA,EACT,CAAC;AACD,SAAO;AACT;;;ACjCA;AAAA,SAAS,aAAAC,kBAAiB;;;ACA1B;AAWA,OAAO,cAAc;AACrB,SAAS,YAAAC,iBAAgB;AAalB,SAAS,oBACd,eAAe,KACgB;AAC/B,QAAM,CAAC,SAAS,QAAQ,IAAIA,UAAS,CAAC;AAEtC,QAAM,UAAU;AAAA,IACd,MAAM;AACJ,eAAS,CAACC,aAAYA,WAAU,CAAC;AAAA,IACnC;AAAA,IACA;AAAA,IACA,EAAE,UAAU,KAAK;AAAA,EACnB;AAEA,SAAO,OAAO,OAAO,SAAS,EAAE,QAAQ,CAAC;AAC3C;;;ADtBO,SAAS,gBAA+C;AAI7D,QAAM,UAAU,oBAAoB;AAKpC,EAAAC,WAAU,MAAM;AACd,YAAQ;AACR,WAAO,iBAAiB,UAAU,OAAO;AACzC,WAAO,iBAAiB,UAAU,OAAO;AACzC,WAAO,MAAM;AACX,aAAO,oBAAoB,UAAU,OAAO;AAC5C,aAAO,oBAAoB,UAAU,OAAO;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SAAO;AACT;;;ANCO,SAAS,sBAId,mBACA,IAKA;AACA,QAAM,UAAU,cAAc;AAC9B,QAAM,aAAa;AAAA,IACjB;AAAA,IACA,CAACC,aAAY,gBAAgBA,QAAO;AAAA,EACtC;AACA,SAAO,GAAG,YAAY,oBAAoB,GAAG,OAAO;AACtD;;;AQvDA;AAsCO,SAAS,mBAId,mBACA,IAKA;AACA,QAAM,UAAU,cAAc;AAC9B,QAAM,aAAa;AAAA,IACjB;AAAA,IACA,CAACC,aAAY,aAAaA,QAAO;AAAA,EACnC;AACA,SAAO,GAAG,YAAY,iBAAiB,GAAG,OAAO;AACnD;;;ACvDA;AAWO,SAAS,eACd,KACA,WACA,KACA,EAAE,SAAS,EAAE,IAAyB,CAAC,GACvC;AACA,MAAI,OAAO;AAAM,WAAO,EAAE,GAAG,KAAK,MAAM,MAAM;AAC9C,QAAM,QAAQ,IAAI,OAAO,IAAI;AAC7B,MAAI,SAAS,UAAU,QAAQ;AAAQ,WAAO;AAC9C,SAAO,EAAE,GAAG,KAAK,MAAM,UAAU,QAAQ,IAAI,QAAQ,OAAO;AAC9D;;;ACrBA;;;ACAA;AAAA,OAAOC,aAAY;;;ACAnB;AAAA,OAAOC,aAAY;AAaZ,IAAM,SAASC,QAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADT/B,IAAM,gBAAgBC,QAAO,MAAM;AAAA;AAAA;AAAA;AAInC,IAAM,yBAAyBA,QAAO,KAAK;AAAA;AAAA;AAAA;AAK3C,IAAM,qBAAqBA,QAAO,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AEbhD;AAAA,OAAOC,aAAY;;;ACAnB;AAAA,OAAOC,aAAY;AAgBZ,IAAM,aAAaC,QAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADZnC,IAAM,YAAYC,QAAO,KAAK;AAAA;AAAA;AAI9B,IAAM,kBAAkBA,QAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AERhD;AAAA,OAAOC,aAAY;AAOZ,IAAM,QAAQC,QAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAc3B,IAAM,YAAYA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyC9B,IAAM,eAAeA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC9DxC;AAAA,OAAOC,aAAY;AAEZ,IAAM,oBAAoBA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyCtC,IAAM,WAAWA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAO7B,IAAM,2BAA2BA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAM7C,IAAM,kBAAkBA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQpC,IAAM,iBAAiBA,QAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AChE1C;AAAA,SAAS,mBAAmB;AAE5B,SAAS,eAAAC,oBAAmB;AAuBD,SAQvB,UARuB,OAAAC,MASrB,QAAAC,aATqB;AAhBpB,SAAS,SAAS;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM,YAAY,SAAS,MAAM;AAEjC,QAAM,UAAU,YAAY,MAAM;AAChC,QAAI,KAAK,WAAW;AAClB,YAAM,YAAY,KAAK;AACvB,gBAAU,KAAK,MAAM,gBAAAD,KAAC,aAAU,MAAY,OAAO,UAAU,OAAO,CAAE;AAAA,IACxE,WAAW,KAAK,QAAQ;AACtB,WAAK,OAAO,MAAM;AAClB,MAAAE,aAAY,MAAM,MAAM;AACxB,YAAM;AAAA,IACR;AAAA,EACF,GAAG,CAAC,QAAQ,IAAI,CAAC;AACjB,SACE,gBAAAF,KAAA,YACE,0BAAAC,MAAC,aAAU,SACT;AAAA,oBAAAD,KAAC,SAAI,WAAU,UACb,0BAAAA,KAAC,KAAK,MAAL,EAAU,GACb;AAAA,IACA,gBAAAA,KAAC,SAAI,WAAU,WAAW,eAAK,OAAM;AAAA,IACrC,gBAAAA,KAAC,SAAI,WAAU,YACZ,eAAK,SAAS,aAAa,KAAK,MAAM,IAAI,QAC7C;AAAA,KACF,GACF;AAEJ;;;AnBnBI,qBAAAG,WACE,OAAAC,MADF,QAAAC,aAAA;AAhBG,SAAS,KAAK;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AACF,GAIG;AACD,QAAM,SAASC,gBAAe;AAC9B,QAAM,MAAMC,QAAuB,IAAI;AACvC,QAAM,QAAQ,sBAAsB,EAAE,KAAK,KAAK,KAAK,GAAG,CAAC,EAAE,MAAAC,MAAK,MAAM;AACpE,WAAO,EAAE,MAAMA,MAAK,OAAO,GAAG,KAAKA,MAAK,MAAMA,MAAK,OAAO;AAAA,EAC5D,CAAC;AAED,SACE,gBAAAH,MAAAF,WAAA,EACE;AAAA,oBAAAC,KAAC,aAAU,OAAc;AAAA,IACzB,gBAAAA,KAAC,SAAM,KAAU,OACd,gBAAM,IAAI,CAAC,MAAMK,WAAU;AAC1B,UAAI,SAAS,WAAW;AACtB,eAAO,gBAAAL,KAAC,kBAAkBK,MAAO;AAAA,MACnC,OAAO;AACL,eACE,gBAAAL;AAAA,UAAC;AAAA;AAAA,YAEC;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA;AAAA,UAJKK;AAAA,QAKP;AAAA,MAEJ;AAAA,IACF,CAAC,GACH;AAAA,KACF;AAEJ;;;AoB/CA;;;ACAA;;;ACAA;AAAA,SAAqB,eAAAC,oBAAmB;;;ACAxC;AAAA,OAAOC,cAAY;AA0Cf,SAQY,OAAAC,MARZ,QAAAC,aAAA;AAxCG,SAAS,QAAQ,MAA4B;AAClD,SAAO,KAAK,sBAAsB;AACpC;AAEA,IAAM,WAAWF,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkB7B,IAAM,UAAUA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAOtB,SAAS,QAAQ;AAAA,EACtB;AAAA,EACA;AAAA,EACA;AACF,GAIG;AACD,QAAM,OAAO,QAAQ,IAAI;AACzB,SACE,gBAAAE;AAAA,IAAC;AAAA;AAAA,MACC,OAAO;AAAA,QACL,MAAM,KAAK;AAAA,QACX,KAAK,QAAQ,KAAK;AAAA,MACpB;AAAA,MAEC;AAAA;AAAA,QAEA,SAAS,gBAAAD,KAAC,WAAS,kBAAO,IAAa;AAAA;AAAA;AAAA,EAC1C;AAEJ;;;ACrDA;AAAA,OAAOE,cAAY;AAiBf,gBAAAC,YAAA;AAbJ,IAAM,YAAYC,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUxB,SAAS,SAAS,EAAE,KAAK,GAA0B;AACxD,QAAM,OAAO,QAAQ,IAAI;AACzB,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,OAAO;AAAA,QACL,MAAM,QAAQ,KAAK,OAAO,KAAK,QAAQ;AAAA,QACvC,KAAK,QAAQ,KAAK;AAAA,MACpB;AAAA;AAAA,EACF;AAEJ;;;AF0BQ,gBAAAE,aAAA;AAvBD,SAAS,WACd;AAAA,EACE;AAAA,EACA;AACF,GAIA,OAA6B,CAAC,GAC9B;AACA,QAAM,QAAQ,SAAS,eAAe;AACtC,QAAM,WAAW,SAAS,kBAAkB;AAK5C,QAAM,eAAeC,aAAY,CAAC,MAA+B;AAC/D,UAAM,OAAO,EAAE;AAIf,QAAI,UAAU,QAAW;AACvB,YAAM,KAAK,MACT,gBAAAD;AAAA,QAAC;AAAA;AAAA,UACC;AAAA,UACA,QAAQ,OAAO,WAAW,aAAa,OAAO,IAAI;AAAA,UAClD;AAAA;AAAA,MACF,CACD;AACD,eAAS,KAAK,MAAM,gBAAAA,MAAC,YAAS,MAAY,CAAE;AAAA,IAC9C;AAAA,EACF,GAAG,IAAI;AAKP,QAAM,eAAeC,aAAY,MAAM;AACrC,UAAM,MAAM;AACZ,aAAS,MAAM;AAAA,EACjB,GAAG,IAAI;AACP,SAAO,EAAE,cAAc,aAAa;AACtC;;;AGpEA;AAAA,OAAOC,cAAY;AACnB,SAAS,eAAAC,cAAa,UAAAC,SAAQ,YAAAC,iBAAgB;AAC9C,SAAS,kBAAAC,uBAAsB;;;ACF/B;AAAA,OAAOC,cAAY;AAEZ,IAAM,aAAaA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU/B,IAAM,eAAeA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAMjC,IAAM,YAAYA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAM9B,IAAM,YAAYA,SAAO,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAehC,IAAM,SAASA,SAAO,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAa7B,IAAM,cAAcA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBhC,IAAM,iBAAiBA,SAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAczC,IAAM,gBAAgBA,SAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADfzC,gBAAAC,OAgBA,QAAAC,aAhBA;AAhDN,IAAM,oBAAoBC,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAMhC,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AAAA,EACA,SAAAC;AACF,GAIG;AACD,QAAM,SAAS,SAAS,QAAQ;AAChC,QAAM,QAAQ;AAAA,IACZ,EAAE,YAAY,cAAc;AAAA,IAC5B,CAAC,EAAE,YAAAC,aAAY,eAAAC,eAAc,MAAM;AACjC,aAAO;AAAA,QACL,MAAMA,eAAc;AAAA,QACpB,KAAKD,YAAW,MAAMA,YAAW;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAASE,gBAAe;AAE9B,QAAM,CAAC,MAAM,OAAO,IAAIC,UAAiBJ,SAAQ,IAAI;AACrD,QAAM,CAAC,OAAO,QAAQ,IAAII,UAAiBJ,SAAQ,SAAS,EAAE;AAE9D,QAAM,UAAUK,QAAO,EAAE,MAAM,MAAM,CAAC;AACtC,UAAQ,UAAU,EAAE,MAAM,MAAM;AAEhC,QAAM,mBAAmBC,aAEvB,CAAC,MAAM;AACP,YAAQ,EAAE,OAAO,KAAK;AAAA,EACxB,GAAG,CAAC,CAAC;AAEL,QAAM,oBAAoBA,aAExB,CAAC,MAAM;AACP,aAAS,EAAE,OAAO,KAAK;AAAA,EACzB,GAAG,CAAC,CAAC;AAEL,QAAM,mBAAmBA,aAAY,MAAM;AACzC,WAAO,KAAK,MACV,gBAAAT;AAAA,MAAC;AAAA;AAAA,QACC;AAAA,QACA;AAAA,QACA,SAASG;AAAA;AAAA,IACX,CACD;AAAA,EACH,GAAG,CAAC,YAAY,eAAeA,QAAO,CAAC;AAEvC,QAAM,eAAeM,aAAY,MAAM;AACrC,UAAM,EAAE,MAAAC,OAAM,OAAAC,OAAM,IAAI,QAAQ;AAChC,WAAO,OAAO,SAAS,EAAE,MAAAD,OAAM,OAAAC,OAAM,GAAG,EAAE,IAAIR,SAAQ,CAAC;AACvD,qBAAiB;AAAA,EACnB,GAAG,CAAC,gBAAgB,CAAC;AAErB,SACE,gBAAAF,MAAC,qBAAkB,iBAAiB,OAAO,OACzC;AAAA,oBAAAA,MAAC,cACC;AAAA,sBAAAD,MAAC,gBAAa,yBAAW;AAAA,MACzB,gBAAAA,MAAC,aAAU,IAAG,YAAW,OAAO,MAAM,UAAU,kBAAkB;AAAA,OACpE;AAAA,IACA,gBAAAC,MAAC,cACC;AAAA,sBAAAD,MAAC,gBAAa,0BAAY;AAAA,MAC1B,gBAAAA,MAAC,UAAO,MAAK,QAAO,OAAO,OAAO,UAAU,mBAAmB;AAAA,MAC/D,gBAAAA,MAAC,aAAU,+CAAiC;AAAA,OAC9C;AAAA,IACA,gBAAAA,MAAC,cACC,0BAAAA,MAAC,kBAAe,SAAS,cAAc,wBAAU,GACnD;AAAA,IACA,gBAAAA,MAAC,cACC,0BAAAA,MAAC,iBAAc,SAAS,kBAAkB,oBAAM,GAClD;AAAA,KACF;AAEJ;;;AEpGA;AAMI,gBAAAY,aAAA;AAFG,IAAM,mBAAmB,CAAC,UAC/B,gBAAAA,MAAC,cAAY,GAAG,OACd,0BAAAA,MAAC,UAAK,GAAE,iFAAgF,GAC1F;AAGK,IAAM,cAAc,CAAC,UAC1B,gBAAAA,MAAC,cAAY,GAAG,OACd,0BAAAA,MAAC,UAAK,GAAE,mJAAkJ,GAC5J;AAGK,IAAM,aAAa,CAAC,UACzB,gBAAAA,MAAC,cAAY,GAAG,OACd,0BAAAA,MAAC,UAAK,GAAE,0DAAyD,GACnE;;;AlC8HM,gBAAAC,OAkBA,QAAAC,aAlBA;AArIR,IAAMC,iBAAgBC,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsFnC,SAASC,UAAS,GAAmD;AACnE,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,CAAC;AACrB,WAAO,EAAE,UAAU,IAAI,UAAU,UAAU,IAAI,SAAS;AAAA,EAC1D,SAAS,GAAP;AACA,WAAO,EAAE,UAAU,IAAI,UAAU,GAAG;AAAA,EACtC;AACF;AAEO,SAAS,aAAa;AAAA,EAC3B;AAAA,EACA;AAAA,EACA,SAAAC;AACF,GAIG;AACD,QAAM,SAAS,SAAS,QAAQ;AAChC,QAAM,SAASC,gBAAe;AAC9B,QAAM,MAAMF,UAASC,SAAQ,IAAI;AACjC,QAAM,QAAQ;AAAA,IACZ,EAAE,YAAY,cAAc;AAAA,IAC5B,CAAC,EAAE,YAAAE,aAAY,eAAAC,eAAc,MAAM;AACjC,aAAO;AAAA,QACL,MAAMA,eAAc;AAAA,QACpB,KAAKD,YAAW,MAAMA,YAAW;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAAgB,WAAW,EAAE,OAAO,cAAc,CAAC;AACzD,QAAM,cAAc,WAAW,EAAE,OAAO,YAAY,CAAC;AAErD,QAAME,cAAaC,aAAY,MAAM;AACnC,WAAO,OAAO,WAAW,EAAE,IAAIL,SAAQ,CAAC;AAAA,EAC1C,GAAG,CAAC,MAAM,CAAC;AAEX,QAAM,iBAAiBK,aAAY,MAAM;AAMvC,gBAAY,aAAa;AACzB,WAAO,KAAK,MAAM;AAChB,aACE,gBAAAV;AAAA,QAAC;AAAA;AAAA,UACC;AAAA,UACA;AAAA,UACA,SAASK;AAAA;AAAA,MACX;AAAA,IAEJ,CAAC;AAAA,EACH,GAAG,CAAC,YAAY,eAAeA,QAAO,CAAC;AAEvC,SACE,gBAAAJ,MAACC,gBAAA,EAAc,iBAAiB,OAAO,OACrC;AAAA,oBAAAD;AAAA,MAAC;AAAA;AAAA,QACC,WAAU;AAAA,QACV,MAAMI,SAAQ;AAAA,QACd,QAAO;AAAA,QACP,KAAI;AAAA,QAEJ;AAAA,0BAAAL,MAAC,oBAAiB;AAAA,UAClB,gBAAAC,MAAC,SAAI,WAAU,SACb;AAAA,4BAAAD,MAAC,SAAI,WAAU,cAAc,cAAI,UAAS;AAAA,YACzC,IAAI,aAAa,MAAM,IAAI,aAAa,MAAM,OAC7C,gBAAAA,MAAC,SAAI,WAAU,cAAc,cAAI,UAAS;AAAA,YAE3CK,SAAQ,SAAS,QAAQA,SAAQ,UAAU,KAAK,OAC/C,gBAAAL,MAAC,SAAI,WAAU,aAAa,UAAAK,SAAQ,OAAM;AAAA,aAE9C;AAAA;AAAA;AAAA,IACF;AAAA,IACA,gBAAAJ,MAAC,UAAK,WAAU,WACd;AAAA,sBAAAD;AAAA,QAAC;AAAA;AAAA,UACC,WAAU;AAAA,UACV,SAASS;AAAA,UACT,cAAc,cAAc;AAAA,UAC5B,cAAc,cAAc;AAAA,UAE5B,0BAAAT,MAAC,eAAY;AAAA;AAAA,MACf;AAAA,MACA,gBAAAA;AAAA,QAAC;AAAA;AAAA,UACC,WAAU;AAAA,UACV,cAAc,YAAY;AAAA,UAC1B,cAAc,YAAY;AAAA,UAC1B,SAAS;AAAA,UAET,0BAAAA,MAAC,cAAW;AAAA;AAAA,MACd;AAAA,OACF;AAAA,KACF;AAEJ;;;AmCjMA;AAAA,SAAoB,UAAAW,eAAc;AA0B5B,gBAAAC,aAAA;AArBC,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AACF,GAIG;AACD,QAAM,cAAcC,QAAO,IAAI;AAC/B,QAAM,OAAO;AAAA,IACX,EAAE,QAAQ,WAAW,UAAU,YAAY;AAAA,IAC3C,CAAC,OAAO,aAAa;AACnB,UAAI,MAAM,UAAU,QAAQ,MAAM,YAAY;AAAM,eAAO,EAAE,MAAM,KAAM;AACzE,aAAO,eAAe,MAAM,UAAU,UAAU;AAAA,QAC9C,MAAM,MAAM,OAAO;AAAA,QACnB,KAAK,MAAM,OAAO,MAAM,MAAM,OAAO,SAAS;AAAA,MAChD,CAAC;AAAA,IACH;AAAA,EACF;AACA,SACE,gBAAAD,MAAC,gBAAa,KAAK,aAAa,OAAO,MACrC,0BAAAA,MAAC,oBAAiB,OAAO,EAAE,OAAO,WAAW,IAAI,GAAG,GACtD;AAEJ;;;A5C+BU,gBAAAE,OAaN,QAAAC,aAbM;AA/CH,SAAS,OAAO;AAAA,EACrB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAiD;AAC/C,QAAM,eAAeC,QAAwB,IAAI;AACjD,QAAM,YAAYA,QAA0B,IAAI;AAChD,QAAM,WAAW,YAAY;AAC7B,QAAMC,UAAS,UAAUF,SAAQ,IAAI;AACrC,QAAM,SAAS,SAAS,QAAQ;AAWhC,EAAAG,WAAU,MAAM;AACd,UAAM,SAAS,UAAU;AACzB,UAAM,YAAY,aAAa;AAC/B,QAAI,CAAC,UAAU,CAAC;AAAW;AAgB3B,QAAI,UAAU;AAMZ,iBAAW,MAAM;AACf,eAAO,KAAK,MACV,gBAAAL;AAAA,UAAC;AAAA;AAAA,YACC,YAAY;AAAA,YACZ,eAAe;AAAA,YACf,SAASE;AAAA;AAAA,QACX,CACD;AAAA,MACH,CAAC;AAAA,IACH,OAAO;AACL,aAAO,MAAM;AAAA,IACf;AAAA,EACF,GAAG,CAAC,UAAUA,QAAO,CAAC;AAEtB,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,WAAW,KAAK,EAAE,cAAc,SAAS,CAAC;AAAA,MAC1C,MAAMC,SAAQ;AAAA,MACd,QAAQA,SAAQ;AAAA,MACf,GAAG;AAAA,MACJ,KAAK;AAAA,MAGL;AAAA,wBAAAF,MAAC,SAAM,KAAK,cAAc,iBAAiB,OAAO;AAAA,QACjDI,SAAQ,WAAW,aAClB,gBAAAJ;AAAA,UAAC;AAAA;AAAA,YACC;AAAA,YACA,UAAUI,QAAO,YAAYA,QAAO;AAAA;AAAA,QACtC,IACE;AAAA,QACJ,gBAAAJ,MAAC,UAAM,UAAS;AAAA,QAEhB,gBAAAA,MAAC,SAAM,iBAAiB,OAAO;AAAA;AAAA;AAAA,EACjC;AAEJ;;;AP/Cc,gBAAAM,aAAA;AAhBP,IAAM,eAAe;AAAA,EAC1B,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,SAAS,oBAAoB,MAAM;AAC1C,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,SAASC,UAAS;AAChB,cAAIA,SAAQ,SAAS;AAAU,mBAAO;AAAA,QACxC;AAAA,QACA,eAAe,SAAS,eAAe,MAAM;AAAA,MAC/C;AAAA,MACA,eAAe;AAAA,QACb,SAAS,SAAS,SAAS,MAAM;AAAA,QACjC,eAAe,CAAC,EAAE,SAAAA,UAAS,YAAY,SAAS,MAAM;AACpD,cAAIA,SAAQ,SAAS,UAAU;AAC7B,mBACE,gBAAAD,MAAC,UAAO,SAASC,UAAS,YACvB,UACH;AAAA,UAEJ;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AoDvDA;AAAA,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;;;ACAnC;AAAA,SAAiB,WAAAC,WAAoB,QAAAC,aAAY;AAI1C,SAAS,aACd,QACA,GACA,GACA;AACA,MAAI,CAAC,KAAK,CAAC;AAAG,WAAO;AAKrB,MAAIC,MAAK,OAAO,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AAAG,WAAO;AACpC,QAAM,eAAe;AAAA,IACnB;AAAA,IACA,CAAC,OAAOC,UAAQ,UAAU,EAAE,KAAK,OAAO,SAAS,EAAE;AAAA,IACnD,EAAE,IAAI,EAAE,CAAC,EAAE;AAAA,EACb;AACA,QAAM,eAAe;AAAA,IACnB;AAAA,IACA,CAAC,OAAO;AACN,aAAOA,UAAQ,UAAU,EAAE,KAAK,OAAO,SAAS,EAAE;AAAA,IACpD;AAAA,IACA,EAAE,IAAI,EAAE,CAAC,EAAE;AAAA,EACb;AAIA,MAAI,CAAC,gBAAgB,CAAC;AAAc,WAAO;AAK3C,MACE,gBACA,gBACAD,MAAK,OAAO,aAAa,CAAC,GAAG,aAAa,CAAC,CAAC;AAE5C,WAAO;AACT,SAAO;AACT;;;ADLO,IAAM,qBAAqB;AAAA,EAChC,CAAC,WAAW;AACV,WAAO,eAAe;AACtB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,iBAAiB;AACf,cAAI,OAAO,aAAa;AAAM,mBAAO;AACrC,gBAAM,QAAQE,SAAO,KAAK,QAAQ,OAAO,SAAS;AAClD,gBAAM,YAAYA,SAAO,SAAS,QAAQ,EAAE,MAAM,SAAS,CAAC;AAC5D,cAAI,aAAa,QAAQ,OAAO,SAAS;AAAG,mBAAO;AACnD,UAAAC,aAAW,KAAK,QAAQ,EAAE,MAAM,aAAa,SAAS,KAAK,CAAC;AAC5D,iBAAO;AAAA,QACT;AAAA,QACA,gBAAgB;AACd,cAAI,OAAO,aAAa;AAAM,mBAAO;AACrC,gBAAM,QAAQD,SAAO,KAAK,QAAQ,OAAO,SAAS;AAClD,gBAAM,YAAYA,SAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,CAAC;AACxD,cAAI,aAAa,QAAQ,OAAO,SAAS;AAAG,mBAAO;AACnD,UAAAC,aAAW,KAAK,QAAQ,EAAE,MAAM,YAAY,CAAC;AAC7C,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AE9DA;AACA,SAAqB,WAAAC,WAAe,cAAAC,oBAAkB;;;ACDtD;AAAA,OAAOC,cAAY;AAEZ,IAAM,cAAcA,SAAO,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD0F3B,gBAAAC,aAAA;AA7DnB,SAAS,oBAAoBC,OAAY;AACvC,SACEC,UAAQ,UAAUD,KAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAQrBA,MAAK,SAAS,eACbA,MAAK,SAAS,gBACdA,MAAK,SAAS,WACdA,MAAK,SAAS,qBACdA,MAAK,SAAS,oBACdA,MAAK,SAAS,yBACdA,MAAK,SAAS,uBACdA,MAAK,SAAS;AAEpB;AAEO,IAAM,mBAAmB;AAAA,EAC9B,CAAC,WAAW;AACV,WAAO,qBAAqB;AAC5B,WAAO,mBAAmB;AAAA,MACxB,QAAQ,MAAM;AACZ,QAAAE,aAAW;AAAA,UACT;AAAA,UACA,EAAE,MAAM,eAAe,UAAU,CAAC,EAAE;AAAA,UACpC,EAAE,OAAO,oBAAoB;AAAA,QAC/B;AAAA,MACF;AAAA,MACA,SAAS,MAAM;AACb,QAAAA,aAAW,UAAU,QAAQ;AAAA,UAC3B,OAAO,CAACF,OAAMG,UAAS,oBAAoBH,KAAI,KAAKG,MAAK,SAAS;AAAA,QACpE,CAAC;AAAA,MACH;AAAA,IACF;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,cAAc,OAAO;AACnB,gBAAM,CAACH,OAAMG,KAAI,IAAI;AACrB,cAAI,CAACF,UAAQ,UAAUD,KAAI;AAAG,mBAAO;AACrC,cAAIA,MAAK,SAAS;AAAe,mBAAO;AACxC,iBAAO,kBAA2B,QAAQ,CAACA,OAAMG,KAAI,GAAG,CAAC,GAAG,MAAM;AAChE,gBACEF,UAAQ,UAAU,EAAE,CAAC,CAAC,KACtBA,UAAQ,UAAU,EAAE,CAAC,CAAC,KACtB,EAAE,CAAC,EAAE,SAAS,iBACd,EAAE,CAAC,EAAE,SAAS,eACd;AACA,cAAAC,aAAW,WAAW,QAAQ,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;AAAA,YAC5C;AACA,mBAAO;AAAA,UACT,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,eAAe;AAAA,QACb,eAAe,CAAC,EAAE,SAAAE,UAAS,YAAY,SAAS,MAAM;AACpD,cAAIA,SAAQ,SAAS,eAAe;AAClC,mBAAO,gBAAAL,MAAC,eAAa,GAAG,YAAa,UAAS;AAAA,UAChD;AAAA,QACF;AAAA,QACA,WAAW,oBAAoB;AAAA,UAC7B,WAAW,OAAO,iBAAiB;AAAA,UACnC,WAAW,OAAO,iBAAiB;AAAA,QACrC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;AEtGA;AAAA,SAAS,UAAAM,UAAQ,WAAAC,WAAS,cAAAC,oBAAkB;;;ACA5C;AAAA,SAAgB,WAAW,gBAAgB;AAC3C,SAAS,WAAAC,WAAS,QAAAC,aAAyB;AA2B3C,SAAS,eAAe,OAAiB;AACvC,MAAI,SAAS;AACb,QAAM,cAAwB,CAAC;AAC/B,aAAW,QAAQ,OAAO;AACxB,gBAAY,KAAK,MAAM;AACvB,aAAS,SAAS,KAAK;AAAA,EACzB;AACA,SAAO;AACT;AAMO,SAAS,SACd,WACS;AACT,QAAM,CAACC,OAAMC,KAAI,IAAI;AAErB,MAAI,CAACH,UAAQ,UAAUE,KAAI;AAAG,WAAO,CAAC;AACtC,MAAIA,MAAK,SAAS;AAAc,WAAO,CAAC;AAExC,QAAM,OAAkC,UAAUA,MAAK,QAAQ;AAE/D,MAAI,SAAS;AAAW,WAAO,CAAC;AAkBhC,QAAM,mBAAmBA,MAAK;AAE9B,QAAM,YAAY,iBAAiB,IAAI,CAACA,UAAS,GAAGD,MAAK,OAAOC,KAAI;AAAA,CAAK;AAEzE,QAAME,QAAO,UAAU,KAAK,EAAE;AAE9B,QAAM,cAAwB,eAAe,SAAS;AAQtD,WAAS,mBAAmBC,SAAgB;AAC1C,aAAS,IAAI,YAAY,QAAQ,KAAK,GAAG,KAAK;AAC5C,YAAM,aAAa,YAAY,CAAC;AAChC,UAAI,cAAcA,SAAQ;AACxB,eAAO;AAAA,UACL,MAAM,CAAC,GAAGF,OAAM,CAAC;AAAA,UACjB,QAAQE,UAAS;AAAA,QACnB;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI,MAAM,wDAAwD;AAAA,EAC1E;AAEA,QAAM,SAA6C,CAAC;AAEpD,QAAM,SAAS,SAASD,OAAM,IAAI;AAOlC,MAAI,SAAS;AAQb,aAAW,SAAS,QAAQ;AAC1B,QAAI,OAAO,UAAU,UAAU;AAC7B,gBAAU,MAAM;AAAA,IAClB,OAAO;AACL,YAAM,SAAS,mBAAmB,MAAM;AACxC,YAAM,QAAQ,mBAAmB,SAAS,MAAM,MAAM;AACtD,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,QACA,YAAY,MAAM;AAAA,MACpB,CAAC;AACD,gBAAU,MAAM;AAAA,IAClB;AAAA,EACF;AAEA,SAAO;AACT;;;AClIA;;;ACAA;AAMO,SAAS,gBACd,QACA,EAAE,SAAS,GACX;AACA,oBAAkB,QAAQ;AAAA,IACxB,MAAM;AAAA,IACN;AAAA,IACA,UAAU,CAAC,EAAE,MAAM,mBAAmB,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,CAAC;AAAA,EAClE,CAAC;AACH;;;ACfA;AAAA,SAAiB,WAAAE,WAAS,cAAAC,oBAAkB;AAUrC,SAAS,qBACd,QACA,UACA,UAA6B,CAAC,GACrB;AACT,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,CAAC,OAAOC,UAAQ,UAAU,EAAE,KAAK,GAAG,SAAS;AAAA,IAC7C,EAAE,IAAI,QAAQ,GAAG;AAAA,EACnB;AACA,MAAI,CAAC;AAAO,WAAO;AACnB,EAAAC,aAAW,SAAS,QAAQ,EAAE,SAAS,GAAG,EAAE,IAAI,MAAM,CAAC,EAAE,CAAC;AAC1D,SAAO;AACT;;;AFhBO,SAAS,uBAAuB,QAAgB;AACrD,SAAO;AAAA,IACL,iBAAiB,SAAS,iBAAiB,MAAM;AAAA,IACjD,sBAAsB,SAAS,sBAAsB,MAAM;AAAA,EAC7D;AACF;;;AGZA;AAOA,IAAM,eAAe,EAAE,OAAO,WAAW,WAAW,SAAS;AAC7D,IAAM,WAAW,EAAE,SAAS,MAAM;AAClC,IAAM,cAAc,EAAE,OAAO,UAAU;AACvC,IAAM,gBAAgB,EAAE,OAAO,UAAU;AACzC,IAAM,aAAa,EAAE,OAAO,UAAU;AACtC,IAAM,eAAe,EAAE,OAAO,UAAU;AACxC,IAAM,gBAAgB,EAAE,OAAO,UAAU;AACzC,IAAM,WAAW,EAAE,OAAO,UAAU;AACpC,IAAM,YAAY,EAAE,YAAY,OAAO;AACvC,IAAM,cAAc,EAAE,WAAW,SAAS;AAInC,IAAM,cAA2B;AAAA,EACtC,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,OAAO;AAAA,EACP,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,aAAa;AAAA,EACb,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,UAAU;AAAA,EACV,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,aAAa;AAAA,EACb,UAAU,EAAE,GAAG,eAAe,GAAG,UAAU;AAAA,EAC3C,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,UAAU;AAAA,EACV,WAAW;AAAA,EACX,MAAM;AAAA,EACN,QAAQ;AACV;;;AClDA;AAiDO,IAAM,eAAkC;AAAA,EAC7C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;ACzDA;AAAA,SAAiB,WAAAC,WAAS,QAAAC,OAAiB,cAAAC,oBAAkB;AAEtD,SAASC,eAAc,QAAgB,OAAiC;AAC7E,MAAI,CAACH,UAAQ,UAAU,MAAM,CAAC,CAAC;AAAG,WAAO;AAWzC,MAAI,MAAM,CAAC,EAAE,SAAS,mBAAmB;AACvC,eAAW,CAAC,OAAOI,KAAI,KAAKH,MAAK,SAAS,QAAQ,MAAM,CAAC,CAAC,GAAG;AAC3D,UAAI,CAACD,UAAQ,UAAU,KAAK;AAAG;AAC/B,UAAI,OAAO,OAAO,KAAK,GAAG;AACxB,QAAAE,aAAW,YAAY,QAAQ,EAAE,IAAIE,MAAK,CAAC;AAC3C,eAAO;AAAA,MACT,OAAO;AACL,QAAAF,aAAW,YAAY,QAAQ,EAAE,IAAIE,MAAK,CAAC;AAC3C,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAWA,MAAI,MAAM,CAAC,EAAE,SAAS,cAAc;AAClC,eAAW,CAAC,OAAOA,KAAI,KAAKH,MAAK,SAAS,QAAQ,MAAM,CAAC,CAAC,GAAG;AAC3D,UAAI,CAACD,UAAQ,UAAU,KAAK;AAAG;AAC/B,UAAI,MAAM,SAAS;AAAmB;AACtC,UAAI,MAAM,SAAS,cAAc;AAM/B,QAAAE,aAAW,YAAY,QAAQ,EAAE,IAAIE,MAAK,CAAC;AAC3C,eAAO;AAAA,MACT,WAAW,OAAO,OAAO,KAAK,GAAG;AAC/B,QAAAF,aAAW,YAAY,QAAQ,EAAE,IAAIE,MAAK,CAAC;AAC3C,eAAO;AAAA,MACT,OAAO;AACL,QAAAF,aAAW,YAAY,QAAQ,EAAE,IAAIE,MAAK,CAAC;AAC3C,QAAAF,aAAW,YAAY,QAAQ;AAAA,UAC7B,MAAM;AAAA,UACN,UAAU,CAAC,EAAE,MAAMD,MAAK,OAAO,KAAK,EAAE,CAAC;AAAA,QACzC,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;;;AC9DA;;;ACAA;AAAA,SAAS,eAAAI,cAAa,UAAAC,eAAc;AACpC,SAAS,eAAAC,oBAAmB;;;ACD5B;AAMI,gBAAAC,aAAA;AAFG,IAAM,kBAAkB,CAAC,UAC9B,gBAAAA,MAAC,cAAY,GAAG,OACd,0BAAAA,MAAC,UAAK,GAAE,gBAAe,GACzB;;;ACPF;AAAA,OAAOC,cAAY;AAEZ,IAAM,aAAaA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqB/B,IAAM,qBAAqBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAMvC,IAAM,qBAAqBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BxC,IAAM,iBAAiBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFjCtB,gBAAAC,OAed,QAAAC,aAfc;AAdb,SAAS,UAAU;AAAA,EACxB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAoD;AAClD,QAAM,MAAMC,QAAuB,IAAI;AACvC,QAAM,WAAWC,aAAY;AAC7B,QAAM,WAAW,SAAS,qBAAqB;AAC/C,QAAM,UAAUC,aAAY,MAAM;AAChC,QAAI,SAAS;AAAO,eAAS,MAAM;AACnC,UAAM,OAAO,IAAI;AACjB,QAAI,SAAS;AAAM;AACnB,UAAM,QAAwB,aAAa,IAAI,CAAC,aAAa;AAC3D,aAAO;AAAA,QACL,MAAM,MAAM,gBAAAL,MAAC,UAAK;AAAA,QAClB,OAAO;AAAA,QACP,QAAQ,CAAC,WAAW;AAClB,iBAAO,UAAU,qBAAqB,UAAU,EAAE,IAAIE,SAAQ,CAAC;AAAA,QACjE;AAAA,MACF;AAAA,IACF,CAAC;AAED,aAAS,KAAK,MACZ,gBAAAF,MAAC,QAAK,MAAY,OAAc,OAAO,SAAS,OAAO,CACxD;AAAA,EACH,GAAG,CAACE,QAAO,CAAC;AAEZ,SACE,gBAAAD,MAAC,cAAW,WAAW,WAAW,eAAe,IAAK,GAAG,YACvD;AAAA,oBAAAA,MAAC,sBAAmB,iBAAiB,OAAO,SAAkB,KAC5D;AAAA,sBAAAD,MAAC,UAAM,UAAAE,SAAQ,UAAS;AAAA,MACxB,gBAAAF,MAAC,mBAAgB;AAAA,OACnB;AAAA,IACA,gBAAAA,MAAC,sBAAoB,UAAS;AAAA,KAChC;AAEJ;;;AG9CA;AAAA,SAAS,eAAAM,oBAAmB;AAYxB,gBAAAC,aAAA;AANG,SAAS,cAAc;AAAA,EAC5B;AAAA,EACA;AACF,GAAwD;AACtD,QAAM,WAAWC,aAAY;AAC7B,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,WAAW,WAAW,eAAe;AAAA,MACpC,GAAG;AAAA,MACJ,YAAW;AAAA,MAEV;AAAA;AAAA,EACH;AAEJ;;;AJRM,gBAAAE,aAAA;AAPC,SAAS,cAAc;AAAA,EAC5B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAA2E;AACzE,MAAIA,SAAQ,SAAS,cAAc;AACjC,WACE,gBAAAD,MAAC,aAAU,SAASC,UAAS,YAC1B,UACH;AAAA,EAEJ,WAAWA,SAAQ,SAAS,mBAAmB;AAC7C,WACE,gBAAAD,MAAC,iBAAc,SAASC,UAAS,YAC9B,UACH;AAAA,EAEJ;AACF;;;ARkEmB,gBAAAC,aAAA;AApEZ,IAAM,kBAAkB;AAAA,EAC7B,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,YAAY,uBAAuB,MAAM;AAEhD,aAAS,WAAoB;AAC3B,YAAM,EAAE,UAAU,IAAI;AACtB,UAAI,CAAC,YAAY,SAAS;AAAG,eAAO;AACpC,YAAM,iBAAiB,cAAc,QAAQ,YAAY;AACzD,UAAI,kBAAkB;AAAM,eAAO;AACnC,YAAM,gBAAgBC,SAAO,OAAO,QAAQ,eAAe,CAAC,CAAC;AAC7D,UAAI,kBAAkB,IAAI;AACxB,QAAAC,aAAW,YAAY,QAAQ,EAAE,IAAI,eAAe,CAAC,EAAE,CAAC;AACxD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAEA,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,gBAAgB;AAAA,QAChB,eAAe;AAAA,QACf,SAASC,UAAS;AAChB,cACEA,SAAQ,SAAS,gBACjBA,SAAQ,SAAS;AAEjB,mBAAO;AAAA,QACX;AAAA,QACA,OAAOA,UAAS;AACd,cACEA,SAAQ,SAAS,gBACjBA,SAAQ,QAAQ;AAEhB,mBAAO;AAAA,QACX;AAAA,QACA,SAASA,UAAS;AAChB,cAAIA,SAAQ,SAAS;AAAc,mBAAO;AAAA,QAC5C;AAAA,QACA,eAAe,SAASC,gBAAe,MAAM;AAAA,MAC/C;AAAA,MACA,eAAe;AAAA,QACb;AAAA,QACA,WAAW,oBAAoB;AAAA,UAC7B,WAAW,MACT,OAAO,UAAU,gBAAgB,EAAE,UAAU,OAAO,CAAC;AAAA,UACvD,SAAS,MAAM;AAKb,kBAAM,QAAQ;AAAA,cACZ;AAAA,cACA,CAAC,OAAOC,UAAQ,UAAU,EAAE,KAAK,GAAG,SAAS;AAAA,YAC/C;AACA,gBAAI,CAAC;AAAO,qBAAO;AACnB,YAAAH,aAAW,OAAO,QAAQ,MAAM,CAAC,CAAC;AAClC,mBAAO;AAAA,UACT;AAAA,QACF,CAAC;AAAA,QACD;AAAA,QACA,YAAY,CAAC,EAAE,MAAM,SAAS,MAAM;AAClC,gBAAM,QAAQ,KAAK,aACf,YAAY,KAAK,UAAU,KAAK,OAChC;AACJ,cAAI,UAAU,MAAM;AAClB,mBAAO;AAAA,UACT,OAAO;AACL,mBAAO,gBAAAF,MAAC,UAAK,OAAe,UAAS;AAAA,UACvC;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;Aa/FA;;;ACAA;AAAA,SAAiB,WAAAM,iBAAgC;;;ACAjD;AAAA,SAAiB,WAAAC,WAAoB,cAAAC,oBAAkB;AAMvD,SAAS,YAAYC,OAAyC;AAC5D,SAAOC,UAAQ,UAAUD,KAAI,KAAKA,MAAK,SAAS;AAClD;AAQO,SAAS,2BACd,QACA,OACS;AACT,SAAO,kBAAkB,QAAQ,OAAO,CAAC,GAAG,MAAM;AAChD,QAAI,CAAC,YAAY,EAAE,CAAC,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;AAAG,aAAO;AACrD,QAAI,EAAE,CAAC,EAAE,iBAAiB,EAAE,CAAC,EAAE,eAAe;AAC5C,MAAAE,aAAW,YAAY,QAAQ,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;AAC3C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;AC5BA;AAAA,SAAiB,WAAAC,WAA0B,cAAAC,oBAAkB;AAI7D,SAAS,OAAO,QAAgBC,OAAY;AAC1C,MAAI,CAACC,UAAQ,UAAUD,KAAI;AAAG,WAAO;AACrC,SAAO,OAAO,OAAOA,KAAI,KAAK,OAAO,SAASA,KAAI;AACpD;AAaO,SAAS,sBACd,QACA,OACS;AACT,MAAI,CAAC,OAAO,QAAQ,MAAM,CAAC,CAAC;AAAG,WAAO;AACtC,SAAO,kBAAkB,QAAQ,OAAO,CAAC,GAAG,MAAM;AAChD,QAAI,CAAC,OAAO,QAAQ,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,QAAQ,EAAE,CAAC,CAAC;AAAG,aAAO;AAC3D,IAAAE,aAAW;AAAA,MACT;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,eAAe;AAAA,QACf,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,MACzB;AAAA,MACA,EAAE,IAAI,EAAE,CAAC,EAAE;AAAA,IACb;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;AFjCO,SAASC,eAAc,QAAgB,OAAiC;AAC7E,QAAM,CAACC,OAAMC,KAAI,IAAI;AACrB,MAAI,CAACC,UAAQ,UAAUF,KAAI;AAAG,WAAO;AACrC,MAAI,sBAAsB,QAAQ,CAACA,OAAMC,KAAI,CAAC;AAAG,WAAO;AACxD,MAAI,2BAA2B,QAAQ,CAACD,OAAMC,KAAI,CAAC;AAAG,WAAO;AAC7D,SAAO;AACT;;;AGXA;AAAA,SAAS,QAAAE,aAAY;AACrB,SAAS,eAAAC,oBAAmB;;;ACD5B;AAAA,OAAOC,cAAY;AAEZ,IAAM,aAAaA,SAAO,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACFpC;AAAA,SAAkB,QAAAC,cAAY;AAQvB,SAAS,WAAWC,UAAkB;AAC3C,SACEA,SAAQ,SAAS,WAAW,KAC5BD,OAAK,OAAOC,SAAQ,SAAS,CAAC,CAAC,EAAE,WAAW;AAEhD;;;AFII,gBAAAC,aAAA;AARG,SAAS,UAAU;AAAA,EACxB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAoD;AAClD,QAAM,WAAWC,aAAY;AAC7B,QAAM,UAAU,WAAWD,QAAO;AAClC,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACE,GAAG;AAAA,MACJ,WAAWG,MAAK;AAAA,QACd,cAAc;AAAA,QACd,WAAW;AAAA,QACX,iBAAiB,CAAC,CAACF,SAAQ;AAAA,MAC7B,CAAC;AAAA,MAEA;AAAA;AAAA,EACH;AAEJ;;;AJ+BgB,gBAAAG,aAAA;AA7BT,IAAM,6BACX,aAAoD,CAAC,WAAW;AAC9D,SAAO,eAAe,sBAAsB,WAAW;AACvD,SAAO,uBAAuB;AAAA,IAC5B,kBAAkB,MAAM;AACtB,aAAO,eAAe;AAAA,QACpB,MAAM;AAAA,QACN;AAAA,UACE,MAAM;AAAA,QACR;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,CAAC,OAAO,sBAAsB;AAChC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,eAAe,SAASC,gBAAe,MAAM;AAAA,IAC/C;AAAA,IACA,eAAe;AAAA,MACb,eAAe,CAAC,EAAE,SAAAC,UAAS,YAAY,SAAS,MAAM;AACpD,gBAAQA,SAAQ,MAAM;AAAA,UACpB,KAAK,aAAa;AAChB,mBACE,gBAAAF,MAAC,aAAU,SAASE,UAAS,YAC1B,UACH;AAAA,UAEJ;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW,oBAAoB;AAAA,QAC7B,WAAW,OAAO,qBAAqB;AAAA,MACzC,CAAC;AAAA,IACH;AAAA,EACF;AACF,CAAC;;;AOvEH;;;ACAA;;;ACAA;AAaO,SAAS,sBACd,QACA,MACM;AACN,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,WAAO,eAAe,oBAAoB,KAAK,GAAG,IAAI;AAAA,EACxD,OAAO;AACL,WAAO,eAAe,oBAAoB,KAAK,IAAI;AAAA,EACrD;AACF;;;ACtBA;AAAA,SAAS,UAAAC,UAAQ,WAAAC,iBAAe;AA6CzB,SAAS,gBACd,QACA,gBACA,eACA,aACS;AAIT,QAAM,UAAU,MAAM;AAAA,IACpBC,SAAO,MAAe,QAAQ;AAAA,MAC5B,OAAO,CAACC,UACNC,UAAQ,UAAUD,KAAI,KACtB,OAAO,eAAe,qBAAqBA,KAAI;AAAA,IACnD,CAAC;AAAA,EACH;AAIA,MAAI,QAAQ,WAAW;AAAG,WAAO;AAQjC,QAAM,eACJ,eAAe,QAAQ,MAAM,CAAC,UAAU,eAAe,MAAM,CAAC,CAAC,CAAC;AAElE,MAAI,cAAc;AAKhB,IAAAD,SAAO,mBAAmB,QAAQ,MAAM;AACtC,iBAAW,SAAS,SAAS;AAC3B,sBAAc,QAAQ,EAAE,MAAM,YAAY,GAAG,MAAM,CAAC,CAAC;AAAA,MACvD;AAAA,IACF,CAAC;AAAA,EACH,OAAO;AAKL,IAAAA,SAAO,mBAAmB,QAAQ,MAAM;AACtC,iBAAW,SAAS,SAAS;AAC3B,sBAAc,QAAQ,eAAe,MAAM,CAAC,CAAC;AAAA,MAC/C;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT;;;ACjGA;AAOO,SAAS,iBAAiB,QAAgBG,UAA2B;AAC1E,SAAO,OAAO,eAAe,oBAAoB,SAASA,SAAQ,IAAI;AACxE;;;AHDO,SAAS,4BAA4B,QAAgB;AAC1D,SAAO;AAAA,IACL,qBAAqB,CAAC;AAAA,IACtB,uBAAuB,SAAS,uBAAuB,MAAM;AAAA,IAC7D,sBAAsB,SAAS,kBAAkB,MAAM;AAAA,IACvD,iBAAiB;AAAA,MACf;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ADLO,IAAM,uBACX,aAA8C,CAAC,WAAW;AACxD,SAAO,iBAAiB,4BAA4B,MAAM;AAC1D,SAAO;AAAA,IACL,MAAM;AAAA,EACR;AACF,CAAC;;;AKnBH;;;ACAA;;;ACAA;AAAA,SAAS,UAAAC,UAAQ,QAAAC,OAAM,SAAAC,QAAO,cAAAC,oBAAkB;AAKzC,SAAS,YAAY,QAAgB;AAC1C,QAAM,QAAQ,cAA8B,QAAQ,SAAS;AAC7D,MAAI,CAAC;AAAO,WAAO;AACnB,MAAI,CAAC,OAAO;AAAW,WAAO;AAC9B,MAAIC,OAAM,WAAW,OAAO,SAAS;AAAG,WAAO;AAC/C,MAAI,CAACC,SAAO,MAAM,QAAQ,OAAO,UAAU,QAAQ,MAAM,CAAC,CAAC;AAAG,WAAO;AACrE,QAAM,WAAWC,MAAK,KAAK,MAAM,CAAC,CAAC;AACnC,EAAAC,aAAW;AAAA,IACT;AAAA,IACA,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE;AAAA,IAC9C,EAAE,IAAI,SAAS;AAAA,EACjB;AACA,EAAAA,aAAW,OAAO,QAAQ;AAAA,IACxB,QAAQF,SAAO,MAAM,QAAQ,QAAQ;AAAA,IACrC,OAAOA,SAAO,MAAM,QAAQ,QAAQ;AAAA,EACtC,CAAC;AACD,SAAO;AACT;;;ACtBA;AAMA,SAAS,eACP,QACA,OACA,aACA;AACA,SAAO,eAAe;AAAA,IACpB,CAACG,aAAYA,SAAQ,SAAS,aAAaA,SAAQ,SAAS;AAAA,IAC5D,EAAE,MAAM,WAAW,MAAM;AAAA,IACzB;AAAA,EACF;AACF;AAEO,SAAS,qBAAqB,QAAgB;AACnD,SAAO;AAAA,IACL,gBAAgB,SAAS,gBAAgB,MAAM;AAAA,EACjD;AACF;;;ACtBA;AAAA,SAAS,WAAW;AACpB,OAAOC,cAAY;AAEnB,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQf,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;AAAA;AAKG,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;AAIG,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;AAIG,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;AAIG,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;AAIG,IAAM,MAAMA,SAAO,IAAI;AAAA,IAC1B;AAAA;AAAA;;;AJQmB,gBAAAC,aAAA;AA9BhB,IAAM,gBAAgB;AAAA,EAC3B,CAAC,WAAW;AACV,WAAO,eAAe,sBAAsB,SAAS;AACrD,WAAO,UAAU,qBAAqB,MAAM;AAC5C,UAAM,gBAAgB,oBAAoB;AAAA,MACxC,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,MAC1D,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,MAC1D,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,MAC1D,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,MAC1D,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,MAC1D,WAAW,SAAS,OAAO,QAAQ,gBAAgB,GAAG,IAAI;AAAA,IAC5D,CAAC;AACD,UAAM,sBAAsB,+BAA+B,QAAQ;AAAA,MACjE,KAAK,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,MACrD,MAAM,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,MACtD,OAAO,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,MACvD,QAAQ,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,MACxD,SAAS,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,MACzD,UAAU,SAAS,OAAO,QAAQ,gBAAgB,GAAG,KAAK;AAAA,IAC5D,CAAC;AACD,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,aAAa,SAAS,aAAa,MAAM;AAAA,MAC3C;AAAA,MACA,eAAe;AAAA,QACb,eAAe,CAAC,EAAE,SAAAC,UAAS,YAAY,SAAS,MAAM;AACpD,cAAIA,SAAQ,SAAS,WAAW;AAC9B,oBAAQA,SAAQ,OAAO;AAAA,cACrB,KAAK;AACH,uBAAO,gBAAAD,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC,KAAK;AACH,uBAAO,gBAAAA,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC,KAAK;AACH,uBAAO,gBAAAA,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC,KAAK;AACH,uBAAO,gBAAAA,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC,KAAK;AACH,uBAAO,gBAAAA,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC,KAAK;AACH,uBAAO,gBAAAA,MAAC,OAAK,GAAG,YAAa,UAAS;AAAA,cACxC;AACE,sBAAM,IAAI;AAAA,kBACR,4CAA4CC,SAAQ;AAAA,gBACtD;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,QACA,WAAW,CAAC,MAAM;AAChB,cAAI,cAAc,CAAC;AAAG,mBAAO;AAC7B,cAAI,oBAAoB,CAAC;AAAG,mBAAO;AACnC,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AKxEA;;;ACAA;AAAA,SAAS,eAAAC,oBAAmB;;;ACA5B;AAAA,OAAOC,cAAY;AAEZ,IAAM,kBAAkBA,SAAO,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADWtC,SAGI,OAAAC,OAHJ,QAAAC,aAAA;AANG,SAAS,eAAe;AAAA,EAC7B;AAAA,EACA;AACF,GAAyD;AACvD,QAAM,WAAWC,aAAY;AAC7B,SACE,gBAAAD,MAAC,SAAK,GAAG,YAAY,WAAS,MAC3B;AAAA;AAAA,IACD,gBAAAD,MAAC,SAAI,iBAAiB,OACpB,0BAAAA,MAAC,mBAAgB,WAAW,WAAW,eAAe,IAAI,GAC5D;AAAA,KACF;AAEJ;;;AEpBA;AAIA,SAAS,qBAAqB,QAAgB;AAC5C,SAAO,kBAAkB,QAAQ;AAAA,IAC/B,MAAM;AAAA,IACN,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,EACzB,CAAC;AACH;AAEO,SAAS,4BAA4B,QAAgB;AAC1D,SAAO;AAAA,IACL,sBAAsB,SAAS,sBAAsB,MAAM;AAAA,EAC7D;AACF;;;ACfA;;;AJuBqB,gBAAAG,aAAA;AAdd,IAAM,uBACX;AAAA,EACE,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,iBAAiB,4BAA4B,MAAM;AAC1D,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,OAAOC,UAAS;AACd,cAAIA,SAAQ,SAAS;AAAmB,mBAAO;AAAA,QACjD;AAAA,MACF;AAAA,MACA,eAAe;AAAA,QACb,eAAe,CAAC,UAAU;AACxB,cAAI,MAAM,QAAQ,SAAS,mBAAmB;AAC5C,mBAAO,gBAAAD,MAAC,kBAAgB,GAAG,OAAO;AAAA,UACpC;AAAA,QACF;AAAA,QACA,WAAW,oBAAoB;AAAA,UAC7B,WAAW,OAAO,eAAe;AAAA,QACnC,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AKhCF;AAAA,SAAS,UAAAE,UAAQ,cAAAC,oBAAkB;AACnC,SAAS,eAAAC,oBAAmB;;;ACD5B;AAIA,SAAS,KAAK,QAAgB;AAC5B;AACF;AAEO,SAAS,mBAAmB,QAAgB;AACjD,SAAO;AAAA,IACL,MAAM,SAAS,MAAM,MAAM;AAAA,EAC7B;AACF;;;ACZA;AAEO,SAASC,eAAc,QAAgB,OAAiC;AAC7E;AACA;AACA,SAAO;AACT;;;ACNA;;;ACAA;AAAA,SAAS,kBAAAC,wBAAsB;;;ACA/B;AAAA,OAAOC,cAAY;AAEZ,IAAM,cAAcA,SAAO,KAAK;AAAA;AAAA;AAAA;;;ACFvC;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAgB,YAAAC,iBAAgB;AAChC,SAAS,eAAAC,oBAAmB;;;ACF5B;AAAA,OAAOC,cAAY;AAMZ,IAAM,kBAAkBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcrC,IAAM,SAASA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACpBlC;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAmC,eAAAC,oBAAmB;AACtD,SAAiB,cAAAC,oBAAkB;AACnC,SAAS,eAAAC,cAAa,kBAAAC,uBAAsB;;;ACH5C;;;ACAA;AAAA,SAAS,aAAAC,kBAAiB;AAcnB,SAAS,mBAAmB;AAIjC,QAAM,UAAU,oBAAoB;AAKpC,EAAAC,WAAU,MAAM;AACd,YAAQ;AACR,WAAO,iBAAiB,UAAU,OAAO;AACzC,WAAO,MAAM;AACX,aAAO,oBAAoB,UAAU,OAAO;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SAAO;AACT;;;AChCA;AAAA,OAAOC,cAAY;AAEZ,IAAM,8BAA8BA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4BjD,IAAM,qBAAqBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC9B/C;;;ACAA;AAIO,SAAS,OAAO;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AACF,GAIW;AACT,MAAI,EAAE,OAAO;AAAM,UAAM,IAAI,MAAM,gCAAgC;AACnE,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC;AAC3C;;;ACfA;AACA,SAAS,eAAAC,oBAAmB;AAUrB,SAAS,cAAc,OAAe,SAA+B;AAC1E,UAAQ,KAAK,MAAM,KAAK;AACxB,QAAM,SAAS,QAAQ,QAAQ,QAAQ;AACvC,SAAO,EAAE,OAAO,QAAQ,KAAK,MAAM,QAAQ,MAAM,EAAE;AACrD;AAQO,SAAS,eAAe,QAAgB,SAA+B;AAC5E,WAAS,KAAK,MAAM,MAAM;AAC1B,QAAM,SAAS,QAAQ,QAAQ,QAAQ;AACvC,SAAO,EAAE,OAAO,KAAK,MAAM,SAAS,MAAM,GAAG,OAAO;AACtD;AAMO,SAAS,eAAe,MAAiB,QAA8B;AAC5E,QAAM,SAAS,KAAK,QAAQ,KAAK;AACjC,QAAM,eAAe,OAAO,QAAQ,OAAO;AAC3C,MAAI,UAAU,cAAc;AAC1B,QAAI,KAAK,QAAQ,OAAO,OAAO;AAC7B,aAAO,cAAc,OAAO,OAAO,IAAI;AAAA,IACzC;AAAA,EACF,OAAO;AACL,QAAI,KAAK,SAAS,OAAO,OAAO;AAC9B,aAAO,eAAe,OAAO,QAAQ,IAAI;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AAcO,SAAS,eACd,MACA,SACA,QACW;AACX,UAAQ,OAAO,MAAM;AAAA,IACnB,KAAK;AACH,aAAO,eAAe,SAAS,MAAM;AAAA,IACvC,KAAK;AACH,aAAO;AAAA,QACL,OAAO,KAAK,MAAM,QAAQ,QAAQ,OAAO,KAAK;AAAA,QAC9C,QAAQ,KAAK,MAAM,QAAQ,SAAS,OAAO,KAAK;AAAA,MAClD;AAAA,EACJ;AACF;AASO,SAAS,eAAe,QAAgB;AAC7C,QAAMC,WAAUD,aAAY,UAAU,QAAQ,MAAM;AACpD,QAAM,WAAW,iBAAiBC,QAAO;AACzC,QAAM,UACJ,SAAS,SAAS,WAAW,IAAI,SAAS,SAAS,YAAY;AACjE,SAAOA,SAAQ,cAAc;AAC/B;;;AN8II,qBAAAC,WAWM,OAAAC,OADF,QAAAC,cAVJ;AA5MJ,SAAS,+BACP,QACAC,UACS;AACT,QAAM,wBAAwBC,aAAY,UAAU,QAAQD,QAAO;AACnE,QAAM,aAAa,sBAAsB,cAAc,KAAK;AAC5D,MAAI,CAAC;AACH,UAAM,IAAI,MAAM,mDAAmD;AACrE,SAAO,WAAW,sBAAsB;AAC1C;AAEO,SAAS,mBAAmB;AAAA,EACjC,SAAAA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAOG;AACD,QAAM,SAASE,gBAAe;AAQ9B,mBAAiB;AAKjB,QAAM,cAAc,eAAe,MAAM;AAKzC,QAAM,QAAQ,KAAK;AACnB,QAAM,WAAW,KAAK,IAAI,QAAQ,OAAO,WAAW;AACpD,QAAM,WAAW,KAAK,IAAI,IAAI,QAAQ,KAAK;AAK3C,QAAM,cAAcC;AAAA,IAClB,CAAC,MAAwB;AACvB,gBAAU,CAAC;AACX,oBAAc,IAAI;AAKlB,YAAM,SAAS,EAAE;AAiBjB,YAAM,SAAS,+BAA+B,QAAQH,QAAO;AAC7D,YAAM,aAAa,OAAO;AAE1B,UAAI,WAAW,EAAE,GAAG,KAAK;AAKzB,YAAM,sBAAsB,CAACI,OAAkB;AAC7C,cAAM,YAAY,OAAO;AAAA,UACvB,OAAO,aAAaA,GAAE,UAAU;AAAA,UAChC,KAAK;AAAA,UACL,KAAK;AAAA,QACP,CAAC;AACD,mBAAW,cAAc,WAAW,OAAO;AAE3C,gBAAQ,QAAQ;AAAA,MAClB;AAKA,YAAM,oBAAoB,MAAM;AAC9B,iBAAS,oBAAoB,aAAa,mBAAmB;AAC7D,iBAAS,oBAAoB,WAAW,iBAAiB;AACzD,cAAMC,QAAOJ,aAAY,SAAS,QAAQD,QAAO;AAgBjD,cAAMM,QAAO;AAAA,UACX,OAAO,SAAS;AAAA,UAChB,QAAQ,SAAS;AAAA,QACnB;AASA,gBAAQA,KAAI;AACZ,QAAAC,aAAW,SAAS,QAAQD,OAAM,EAAE,IAAID,MAAK,CAAC;AAC9C,sBAAc,KAAK;AAAA,MACrB;AAKA,eAAS,iBAAiB,aAAa,mBAAmB;AAC1D,eAAS,iBAAiB,WAAW,iBAAiB;AAAA,IACxD;AAAA,IACA,CAAC,QAAQ,OAAO,QAAQ,QAAQ,KAAK,OAAOL,QAAO;AAAA,EACrD;AAWA,QAAM,eAAeG;AAAA,IACnB,CAAC,MAAwB;AACvB,gBAAU,CAAC;AACX,oBAAc,IAAI;AAClB,YAAM,SAAS,EAAE,eAAe,CAAC,EAAE;AACnC,YAAM,aAAa,KAAK;AAExB,UAAI,WAAW,EAAE,GAAG,KAAK;AAEzB,YAAM,sBAAsB,CAAC,OAAmB;AAE9C,cAAMC,KAAI,GAAG,eAAe,CAAC;AAE7B,cAAM,YAAY,OAAO;AAAA,UACvB,OAAO,aAAaA,GAAE,UAAU;AAAA,UAChC,KAAK;AAAA,UACL,KAAK;AAAA,QACP,CAAC;AACD,mBAAW,cAAc,WAAW,OAAO;AAE3C,gBAAQ,QAAQ;AAAA,MAClB;AACA,YAAM,qBAAqB,MAAM;AAC/B,iBAAS,oBAAoB,aAAa,mBAAmB;AAC7D,iBAAS,oBAAoB,YAAY,kBAAkB;AAC3D,cAAMC,QAAOJ,aAAY,SAAS,QAAQD,QAAO;AACjD,QAAAO,aAAW;AAAA,UACT;AAAA,UACA,EAAE,OAAO,SAAS,OAAO,QAAQ,SAAS,OAAO;AAAA,UACjD,EAAE,IAAIF,MAAK;AAAA,QACb;AACA,sBAAc,KAAK;AAAA,MACrB;AAEA,eAAS,iBAAiB,aAAa,mBAAmB;AAC1D,eAAS,iBAAiB,YAAY,kBAAkB;AAAA,IAC1D;AAAA,IACA,CAAC,QAAQ,OAAO,QAAQ,QAAQ,KAAK,OAAOL,QAAO;AAAA,EACrD;AAKA,QAAM,YAAYQ,MAAK;AAAA,IACrB,YAAY,QAAQ,YAAY,QAAQ;AAAA,IACxC,UAAU,SAAS,YAAY,QAAQ;AAAA,IACvC,WAAW,SAAS,YAAY,QAAQ;AAAA,IACxC,cAAc;AAAA,IACd,WAAW,SAAS,MAAM,KAAK,UAAU;AAAA,EAC3C,CAAC;AAED,SACE,gBAAAV,MAAAD,WAAA,EAKE,0BAAAC;AAAA,IAAC;AAAA;AAAA,MACC;AAAA,MACA;AAAA,MACA;AAAA,MAEA,0BAAAC,OAAC,sBACC;AAAA,wBAAAD,MAAC,UAAK,WAAU,oBAAmB;AAAA,QACnC,gBAAAA,MAAC,UAAK,WAAU,sBAAqB;AAAA,QACrC,gBAAAA,MAAC,UAAK,WAAU,qBAAoB;AAAA,SACtC;AAAA;AAAA,EACF,GACF;AAEJ;;;AOzPA;;;ACAA;AAAA,OAAOW,cAAY;AAEZ,IAAM,mBAAmBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADGzC,iBAAAC,cAAA;AAFG,SAAS,gBAAgB,EAAE,KAAK,GAAwB;AAC7D,SACE,gBAAAA,OAAC,oBACE;AAAA,SAAK;AAAA,IAAM;AAAA,IAAU,KAAK;AAAA,KAC7B;AAEJ;;;AETA;;;ACAA;AAAA,OAAOC,cAAY;AAEZ,IAAM,gBAAgBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACF1C;;;ACAA;AAAA,OAAOC,cAAY;AAMZ,IAAM,oBAAoBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAevC,IAAM,eAAeA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACrBzC;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAmC,eAAAC,oBAAmB;AACtD,SAAS,cAAAC,oBAAkB;AAC3B,SAAS,eAAAC,cAAa,kBAAAC,uBAAsB;AA+DxC,gBAAAC,aAAA;AA3CG,SAAS,kBAAkB;AAAA,EAChC,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAMG;AACD,QAAM,SAASC,gBAAe;AAC9B,QAAM,aAAa,eAAe,MAAM,SAAS,MAAM;AACvD,QAAM,UAAU,WAAW;AAAA,IACzB,OAAO,OAAO;AAAA,IACd,QAAQ,GAAG,WAAW,SAAS,WAAW;AAAA,EAC5C,CAAC;AAED,QAAM,UAAUC,aAAY,MAAM;AAChC,UAAMC,QAAOC,aAAY,SAAS,QAAQJ,QAAO;AACjD,UAAM,WAAW,eAAe,MAAM,SAAS,MAAM;AACrD,YAAQ,QAAQ;AAChB,IAAAK,aAAW,SAAS,QAAQ,UAAU,EAAE,IAAIF,MAAK,CAAC;AAAA,EACpD,GAAG,CAACH,UAAS,QAAQ,MAAM,OAAO,CAAC;AAEnC,QAAM,YACJ,OAAO,SAAS,UACZ,OACA,OAAO,SAAS,QAAQ,SAAS,OAAO,UAAU,QAAQ;AAEhE,QAAM,aAAa,CAAC;AAEpB,QAAM,aACJ,KAAK,UAAU,WAAW,SAAS,KAAK,WAAW,WAAW;AAEhE,QAAM,YAAYM,MAAK;AAAA,IACrB,cAAc;AAAA,IACd,cAAc,CAAC,cAAc;AAAA,EAC/B,CAAC;AAED,SACE,gBAAAP;AAAA,IAAC;AAAA;AAAA,MACC;AAAA,MACA,SAAS,aAAa,SAAY;AAAA,MAClC,cAAc,QAAQ;AAAA,MACtB,cAAc,QAAQ;AAAA,MAErB,iBAAO;AAAA;AAAA,EACV;AAEJ;;;AF9CU,gBAAAQ,aAAA;AAlBH,SAAS,uBAAuB;AAAA,EACrC,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAOG;AACD,SACE,gBAAAD,MAAC,qBACE,kBAAQ,IAAI,CAAC,QAAQ,MAAM;AAC1B,WACE,gBAAAA;AAAA,MAAC;AAAA;AAAA,QACC,SAASC;AAAA,QAET;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAJK;AAAA,IAKP;AAAA,EAEJ,CAAC,GACH;AAEJ;;;AGzCA;;;ACAA;AAAA,SAAS,eAAAC,oBAAmB;AAC5B,SAAS,kBAAAC,uBAAsB;;;ACD/B;AAMI,gBAAAC,OAKF,QAAAC,cALE;AAIG,IAAM,YAAY,CAAC,UACxB,gBAAAC,OAAC,cAAY,GAAG,OACd;AAAA,kBAAAC,MAAC,UAAK,OAAO,GAAG,QAAQ,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG;AAAA,EAC9C,gBAAAA,MAAC,UAAK,GAAE,oBAAmB;AAAA,GAC7B;AAGK,IAAM,aAAa,CAAC,UACzB,gBAAAD,OAAC,cAAY,GAAG,OACd;AAAA,kBAAAC,MAAC,UAAK,OAAO,GAAG,QAAQ,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG;AAAA,EAC9C,gBAAAA,MAAC,UAAK,GAAE,gDAA+C;AAAA,GACzD;;;ACrBF;AAAA,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;AACnC,SAAS,eAAAC,oBAAmB;AAKrB,SAAS,qBACd,QACAC,UACA;AAOA,MACE,CAACA,SAAQ,SACT,CAACA,SAAQ,UACT,CAACA,SAAQ,YACT,CAACA,SAAQ;AAET;AACF,QAAM,OAAO,EAAE,OAAOA,SAAQ,OAAO,QAAQA,SAAQ,OAAO;AAC5D,QAAM,UAAU,EAAE,OAAOA,SAAQ,UAAU,QAAQA,SAAQ,UAAU;AACrE,QAAMC,QAAOC,aAAY,SAAS,QAAQF,QAAO;AACjD,EAAAG,SAAO,mBAAmB,QAAQ,MAAM;AAStC,UAAM,WAAW,eAAe,MAAM,SAAS;AAAA,MAC7C,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV,CAAC;AACD,IAAAC,aAAW;AAAA,MACT;AAAA,MACA,EAAE,MAAM,gBAAgB,GAAG,SAAS;AAAA,MACpC,EAAE,IAAIH,MAAK;AAAA,IACb;AACA,IAAAG,aAAW;AAAA,MACT;AAAA,MACA,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE;AAAA,MAClC,EAAE,IAAIH,MAAK;AAAA,IACb;AAAA,EACF,CAAC;AACH;;;AFrBM,gBAAAI,aAAA;AAtBC,SAAS,qBAAqB;AAAA,EACnC,SAAAC;AACF,GAEG;AACD,QAAM,SAASC,gBAAe;AAC9B,QAAM,UAAU,WAAW;AAAA,IACzB,OAAO;AAAA,IACP,QAAQ;AAAA,EACV,CAAC;AAED,QAAM,gBAAgBC,aAAY,MAAM;AACtC,QAAIF,SAAQ,SAAS;AAAe;AACpC,yBAAqB,QAAQA,QAAO;AAAA,EACtC,GAAG,CAAC,QAAQA,QAAO,CAAC;AACpB,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,WAAWC,SAAQ,SAAS,iBAAiB,eAAe;AAAA,MAC5D,SAASA,SAAQ,SAAS,iBAAiB,SAAY;AAAA,MACvD,cAAc,QAAQ;AAAA,MACtB,cAAc,QAAQ;AAAA,MAEtB,0BAAAD,MAAC,cAAW;AAAA;AAAA,EACd;AAEJ;;;AGnCA;AAAA,SAAS,eAAAI,oBAAmB;AAC5B,SAAS,kBAAAC,uBAAsB;;;ACD/B;AAAA,SAAS,UAAAC,UAAQ,QAAAC,OAAM,cAAAC,oBAAkB;AACzC,SAAS,eAAAC,oBAAmB;AAMrB,SAAS,oBACd,QACAC,UACA;AAOA,MACE,CAACA,SAAQ,SACT,CAACA,SAAQ,UACT,CAACA,SAAQ,YACT,CAACA,SAAQ;AAET;AACF,QAAM,OAAO,EAAE,OAAOA,SAAQ,OAAO,QAAQA,SAAQ,OAAO;AAC5D,QAAM,UAAU,EAAE,OAAOA,SAAQ,UAAU,QAAQA,SAAQ,UAAU;AACrE,QAAMC,QAAOC,aAAY,SAAS,QAAQF,QAAO;AAEjD,EAAAG,SAAO,mBAAmB,QAAQ,MAAM;AAStC,UAAM,WAAW,eAAe,MAAM,SAAS;AAAA,MAC7C,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV,CAAC;AAYD,IAAAC,aAAW;AAAA,MACT;AAAA,MACA,EAAE,MAAM,eAAe,GAAG,SAAS;AAAA,MACnC,EAAE,IAAIH,MAAK;AAAA,IACb;AAQA,UAAM,cAAc;AAAA,MAClB;AAAA,MACA,CAACI,UAASF,SAAO,QAAQ,QAAQE,KAAI,KAAKA,MAAK,SAAS;AAAA,IAC1D;AACA,QAAI,CAAC;AAAa,YAAM,IAAI,MAAM,uBAAuB;AACzD,UAAM,CAAC,eAAe,UAAU,IAAI;AACpC,UAAM,WAAW,cAAc;AAC/B,UAAM,eAAe,cAAc,SAAS;AAC5C,UAAMC,SAAQL,MAAK,MAAM,EAAE,EAAE,CAAC;AAsB9B,UAAM,cAAc,SAAS,eAAe,CAAC;AAC7C,QACEK,WAAU,eAAe,KACzBC,MAAK,OAAO,WAAW,KACvB,YAAY,SAAS,IACrB;AACA,MAAAH,aAAW,YAAY,QAAQ;AAAA,QAC7B,IAAI,CAAC,GAAG,YAAY,eAAe,CAAC;AAAA,MACtC,CAAC;AAAA,IACH;AAIA,UAAM,eAAe,SAAS,CAAC;AAC/B,UAAM,qBACJE,WAAU,KAAKC,MAAK,OAAO,YAAY,KAAK,aAAa,SAAS;AACpE,QAAI,oBAAoB;AACtB,MAAAH,aAAW,YAAY,QAAQ,EAAE,IAAI,CAAC,GAAG,YAAY,CAAC,EAAE,CAAC;AAAA,IAC3D;AAIA,IAAAA,aAAW,UAAU,QAAQ;AAAA,MAC3B,IAAI,CAAC,GAAG,YAAY,qBAAqBE,SAAQ,IAAIA,MAAK;AAAA,IAC5D,CAAC;AAAA,EACH,CAAC;AACH;;;AD1FM,gBAAAE,aAAA;AAvBC,SAAS,sBAAsB;AAAA,EACpC,SAAAC;AACF,GAEG;AACD,QAAM,SAASC,gBAAe;AAC9B,QAAM,UAAU,WAAW;AAAA,IACzB,OAAO;AAAA,IACP,QAAQ;AAAA,EACV,CAAC;AAED,QAAM,eAAeC,aAAY,MAAM;AACrC,QAAIF,SAAQ,SAAS;AAAgB;AACrC,wBAAoB,QAAQA,QAAO;AAAA,EACrC,GAAG,CAAC,QAAQA,QAAO,CAAC;AAEpB,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,WAAWC,SAAQ,SAAS,gBAAgB,eAAe;AAAA,MAC3D,SAASA,SAAQ,SAAS,gBAAgB,SAAY;AAAA,MACtD,cAAc,QAAQ;AAAA,MACtB,cAAc,QAAQ;AAAA,MAEtB,0BAAAD,MAAC,aAAU;AAAA;AAAA,EACb;AAEJ;;;AJzBI,SACE,OAAAI,OADF,QAAAC,cAAA;AANG,SAAS,qBAAqB;AAAA,EACnC,SAAAC;AACF,GAEG;AACD,SACE,gBAAAD,OAAC,qBACC;AAAA,oBAAAD,MAAC,yBAAsB,SAASE,UAAS;AAAA,IACzC,gBAAAF,MAAC,wBAAqB,SAASE,UAAS;AAAA,KAC1C;AAEJ;;;ALkBI,SACE,OAAAC,OADF,QAAAC,cAAA;AAdG,SAAS,aAAa;AAAA,EAC3B,SAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAMG;AACD,SACE,gBAAAD,OAAC,iBACC;AAAA,oBAAAD,MAAC,wBAAqB,SAASE,UAAS;AAAA,IACxC,gBAAAF;AAAA,MAAC;AAAA;AAAA,QACC,SAASE;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,IACF;AAAA,KACF;AAEJ;;;AX8CI,SACE,OAAAC,OADF,QAAAC,cAAA;AA3DG,SAAS,kBAAkB;AAAA,EAChC,SAAAC;AAAA,EACA;AACF,GAGG;AACD,QAAMC,UAAS,UAAUD,SAAQ,GAAG;AACpC,QAAM,WAAWE,aAAY;AAC7B,QAAM,CAAC,YAAY,aAAa,IAAIC,UAAS,KAAK;AAClD,QAAM,CAAC,MAAM,OAAO,IAAIA;AAAA,IACtBH,SAAQ,YAAYA,SAAQ,aAAaA,SAAQ,SAASA,SAAQ,SAC9D,EAAE,OAAOA,SAAQ,OAAO,QAAQA,SAAQ,OAAO,IAC/C;AAAA,EACN;AAOA,QAAM,UACJA,SAAQ,YAAYA,SAAQ,YACxB,EAAE,OAAOA,SAAQ,UAAU,QAAQA,SAAQ,UAAU,IACrD;AAMN,QAAM,eAAe,YAAY,QAAQ;AAKzC,QAAM,YAAYI,MAAK;AAAA,IACrB,cAAc;AAAA,IACd,cAAc;AAAA,IACd,WAAW,SAAS,KAAK,SAAS,MAAM,KAAK,UAAU;AAAA,IACvD,YAAYH,QAAO,WAAW;AAAA,EAChC,CAAC;AAkBD,SACE,gBAAAF,OAAC,mBAAgB,WACf;AAAA,oBAAAD,MAAC,UAAO,KAAKG,QAAO,KAAK,OAAO,MAAM,OAAO,QAAQ,MAAM,QAAQ;AAAA,IAClE,eACC,gBAAAH;AAAA,MAAC;AAAA;AAAA,QACC,SAASE;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,IACF,IACE;AAAA,IAKH,cAAc,OAAO,gBAAAF,MAAC,mBAAgB,MAAY,IAAK;AAAA,IACvD,eACC,gBAAAA;AAAA,MAAC;AAAA;AAAA,QACC,SAASE;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,IACF,IACE;AAAA,KACN;AAEJ;;;AFxGI,SAEI,OAAAK,OAFJ,QAAAC,cAAA;AAPG,SAAS,WAAW;AAAA,EACzB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAqD;AACnD,QAAM,SAASC,iBAAe;AAC9B,SACE,gBAAAF,OAAC,SAAK,GAAG,YACP;AAAA,oBAAAD,MAAC,eAAY,iBAAiB,OAC5B,0BAAAA;AAAA,MAAC;AAAA;AAAA,QACC,SAASE;AAAA,QACT,SAAS,OAAO,MAAM;AAAA;AAAA,IACxB,GACF;AAAA,IACC;AAAA,KACH;AAEJ;;;AwBzBA;AAAA,SAAS,kBAAAE,wBAAsB;;;ACA/B;AAAA,OAAOC,cAAY;AAEZ,IAAM,eAAeA,SAAO,MAAM;AAAA;AAAA;;;ADarC,SAEI,OAAAC,OAFJ,QAAAC,cAAA;AAPG,SAAS,YAAY;AAAA,EAC1B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAsD;AACpD,QAAM,SAASC,iBAAe;AAC9B,SACE,gBAAAF,OAAC,UAAM,GAAG,YAAY,OAAO,EAAE,SAAS,eAAe,GACrD;AAAA,oBAAAD,MAAC,gBAAa,iBAAiB,OAC7B,0BAAAA;AAAA,MAAC;AAAA;AAAA,QACC,SAASE;AAAA,QACT,SAAS,OAAO,MAAM;AAAA;AAAA,IACxB,GACF;AAAA,IACC;AAAA,KACH;AAEJ;;;AzBXQ,gBAAAE,aAAA;AARD,SAASC,eAAc;AAAA,EAC5B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAA0E;AACxE,UAAQA,SAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aACE,gBAAAF,MAAC,cAAW,SAASE,UAAS,YAC3B,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,eAAY,SAASE,UAAS,YAC5B,UACH;AAAA,EAEN;AACF;;;AHTA,IAAM,kBAAqC;AAAA,EACzC,2BAA2B,EAAE,OAAO,IAAI,QAAQ,GAAG;AAAA,EACnD,qBAAqB,EAAE,OAAO,KAAK,QAAQ,IAAI;AAAA,EAC/C,cAAc,EAAE,OAAO,MAAM,QAAQ,KAAK;AAAA,EAC1C,mBAAmB;AAAA;AAAA;AAAA;AAAA,IAIjB,EAAE,MAAM,KAAK,OAAO,SAAS,MAAM,UAAU,OAAO,KAAK,QAAQ,IAAI;AAAA,IACrE,EAAE,MAAM,KAAK,OAAO,UAAU,MAAM,UAAU,OAAO,KAAK,QAAQ,IAAI;AAAA,IACtE,EAAE,MAAM,KAAK,OAAO,SAAS,MAAM,UAAU,OAAO,KAAK,QAAQ,IAAI;AAAA;AAAA;AAAA;AAAA,IAIrE,EAAE,MAAM,UAAK,OAAO,aAAa,MAAM,SAAS,OAAO,IAAI,EAAE;AAAA,IAC7D,EAAE,MAAM,QAAK,OAAO,aAAa,MAAM,SAAS,OAAO,IAAI;AAAA,IAC3D,EAAE,MAAM,QAAQ,OAAO,aAAa,MAAM,SAAS,OAAO,EAAE;AAAA,EAC9D;AAAA,EACA,oBAAoB;AAAA;AAAA;AAAA;AAAA,IAIlB;AAAA,MACE,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,OAAO;AAAA,MACP,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,IACV;AAAA;AAAA;AAAA;AAAA,IAIA,EAAE,MAAM,UAAK,OAAO,aAAa,MAAM,SAAS,OAAO,IAAI,EAAE;AAAA,IAC7D,EAAE,MAAM,QAAK,OAAO,aAAa,MAAM,SAAS,OAAO,IAAI;AAAA,IAC3D,EAAE,MAAM,QAAQ,OAAO,aAAa,MAAM,SAAS,OAAO,EAAE;AAAA,EAC9D;AACF;AAEO,IAAM;AAAA;AAAA,EACX;AAAA,IACE,CAAC,QAAQ,aAAa,EAAE,aAAa,MAAM;AACzC,YAAM,UAA6B;AAAA,QACjC,GAAG;AAAA,QACH,GAAG,YAAY;AAAA,MACjB;AACA,aAAO,QAAQ;AAAA,QACb,GAAG,mBAAmB,MAAM;AAAA,QAC5B,2BAA2B,QAAQ;AAAA,QACnC,qBAAqB,QAAQ;AAAA,QAC7B,cAAc,QAAQ;AAAA,QACtB,mBAAmB,QAAQ;AAAA,QAC3B,oBAAoB,QAAQ;AAAA,MAC9B;AACA,aAAO,OAAO,oBAAoB,CAAC,MAAM;AACvC,cAAM,EAAE,UAAU,IAAI;AACtB,YAAI,EAAE,SAAS,MAAM,EAAE,UAAU,IAAI;AACnC,UAAAC,aAAW,YAAY,QAAQ;AAAA,YAC7B,MAAM;AAAA,YACN,KAAK,EAAE;AAAA,YACP,KAAK,EAAE,KAAK;AAAA,YACZ,OAAO,EAAE,KAAK;AAAA,YACd,OAAO,EAAE,KAAK;AAAA,YACd,OAAO,EAAE;AAAA,YACT,QAAQ,EAAE;AAAA,YACV,UAAU,EAAE;AAAA,YACZ,WAAW,EAAE;AAAA,YACb,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,UACzB,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,cAAc;AAAA,YAClB,EAAE,OAAO,EAAE,OAAO,QAAQ,EAAE,OAAO;AAAA,YACnC,QAAQ,uBAAuB,QAAQ;AAAA,UACzC;AACA,UAAAA,aAAW,YAAY,QAAQ;AAAA,YAC7B,MAAM;AAAA,YACN,KAAK,EAAE;AAAA,YACP,KAAK,EAAE,KAAK;AAAA,YACZ,OAAO,EAAE,KAAK;AAAA,YACd,OAAO,EAAE,KAAK;AAAA,YACd,OAAO,YAAY;AAAA,YACnB,QAAQ,YAAY;AAAA,YACpB,UAAU,EAAE;AAAA,YACZ,WAAW,EAAE;AAAA,YACb,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,UACzB,CAAC;AAAA,QACH;AASA,YAAI,CAAC,WAAW;AACd,gBAAM,UAAUC,SAAO,IAAI,QAAQ,CAAC,CAAC;AACrC,UAAAD,aAAW,OAAO,QAAQ,OAAO;AACjC,UAAAE,aAAY,MAAM,MAAM;AAAA,QAC1B;AACA,eAAO;AAAA,MACT;AACA,aAAO,OAAO,2BAA2B,CAAC,MAAM;AAC9C,eAAO,OAAO,wBAEZ,EAAE,KAAK,EAAE,QAAQ,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC;AACpC,eAAO;AAAA,MACT;AAEA,aAAO,aAAa;AAAA,QAClB,MAAM;AAAA,QACN,QAAQ;AAAA,UACN,QAAQ,CAACC,aAAY;AACnB,gBAAI,CAAC,eAAe,cAAc,EAAE,SAASA,SAAQ,IAAI,GAAG;AAC1D,qBAAO;AAAA,YACT;AAAA,UACF;AAAA,UACA,UAAU,CAACA,aAAY;AACrB,gBAAIA,SAAQ,SAAS;AAAgB,qBAAO;AAAA,UAC9C;AAAA,UACA,eAAe,SAASC,gBAAe,MAAM;AAAA,QAC/C;AAAA,QACA,eAAe;AAAA,UACb,eAAAC;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA;;;A8B5JF;;;ACAA;AAAA,OAAOC,cAAY;AAEZ,IAAM,cAAcA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BjC,IAAM,iBAAiBA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC/B3C;;;AFyBc,SAEE,OAAAC,OAFF,QAAAC,cAAA;AAlBP,IAAM,mBAAmB;AAAA,EAC9B,CAAC,WAAW;AACV,QAAI,CAAC,OAAO;AACV,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AACF,WAAO,aAAa;AAAA,MAClB,kBAAkB,MAAM,OAAO,YAAY,WAAW,MAAM;AAAA,IAC9D;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,eAAe;AAAA,QACb,YAAY,CAAC,EAAE,MAAM,SAAS,MAAM;AAClC,cAAI,KAAK,MAAM;AACb;AAAA;AAAA;AAAA;AAAA,cAIE,gBAAAA,OAAC,eAAY,YAAY,OAEvB;AAAA,gCAAAD,MAAC,kBAAe,iBAAiB,OAAO,eAAC;AAAA,gBACxC;AAAA,gBAED,gBAAAA,MAAC,kBAAe,iBAAiB,OAAO,eAAC;AAAA,iBAC3C;AAAA;AAAA,UAEJ,OAAO;AACL,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,QACA,WAAW,oBAAoB;AAAA,UAC7B,SAAS,MAAM,OAAO,WAAW,iBAAiB;AAAA,QACpD,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACF;;;AG3CA;AAAA,SAAS,UAAAE,UAAQ,QAAAC,aAAY;;;ACA7B;;;ACAA;AAQO,SAAS,mBAAmB,QAAgB,aAAsB;AACvE,SAAO,OAAO,eAAe;AAAA,IAC3B,CAACC,aAAYA,SAAQ,SAAS;AAAA,IAC9B,CAACA,aAAY;AACX,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,WAAWA,WAAUA,SAAQ,QAAQ;AAAA,MAC9C;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;AAEO,SAAS,gBAAgB,QAAgB,aAAsB;AACpE,SAAO,OAAO,eAAe;AAAA,IAC3B,CAACA,aAAYA,SAAQ,SAAS;AAAA,IAC9B,CAACA,aAAY;AACX,aAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS,aAAaA,WAAUA,SAAQ,UAAU;AAAA,QAClD,OAAO,WAAWA,WAAUA,SAAQ,QAAQ;AAAA,MAC9C;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;AAEO,SAAS,qBAAqB,QAAgB,aAAsB;AACzE,SAAO,OAAO,eAAe;AAAA,IAC3B,CAACA,aAAYA,SAAQ,SAAS;AAAA,IAC9B,CAACA,aAAY;AACX,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,WAAWA,WAAUA,SAAQ,QAAQ;AAAA,MAC9C;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;;;AC9CA;AAMO,SAASC,QAAO,QAAgB;AACrC,SAAO;AAAA,IACL;AAAA,IACA,CAACC,WAAU,EAAE,OAAOA,MAAK,QAAQ,EAAE;AAAA,IACnC;AAAA,MACE,OAAO;AAAA,IACT;AAAA,EACF;AACF;;;ACdA;AAAA,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;AAO5B,SAASC,aAAY,QAAyB;AACnD,QAAM,QAAQ,cAA+B,QAAQ,UAAU;AAC/D,MAAI,CAAC;AAAO,WAAO;AACnB,QAAM,CAACC,UAASC,KAAI,IAAI;AAKxB,MAAIC,SAAO,QAAQ,QAAQF,QAAO,GAAG;AACnC,QAAIA,SAAQ,QAAQ,GAAG;AAIrB,MAAAG,aAAW,SAAS,QAAQ,EAAE,OAAOH,SAAQ,QAAQ,EAAE,GAAG,EAAE,IAAIC,MAAK,CAAC;AACtE,aAAO;AAAA,IACT,OAAO;AAIL,oBAAc,QAAQ,EAAE,MAAM,YAAY,GAAGA,KAAI;AACjD,aAAO;AAAA,IACT;AAAA,EACF;AAIA,EAAAE,aAAW,WAAW,QAAQ,EAAE,QAAQ,KAAK,CAAC;AAI9C,QAAM,YAAY,cAA+B,QAAQ,UAAU;AACnE,MAAI,CAAC;AAAW,WAAO;AAKvB,MAAI,UAAU,CAAC,EAAE,SAAS,oBAAoB,UAAU,CAAC,EAAE,YAAY,MAAM;AAC3E,IAAAA,aAAW,SAAS,QAAQ,EAAE,SAAS,MAAM,GAAG,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;AAAA,EACtE;AACA,SAAO;AACT;;;AC/CA;AAAA,SAAS,UAAAC,gBAAc;AAMhB,SAAS,QAAQ,QAAyB;AAC/C,QAAM,UAAU,MAAM;AAAA,IACpBC,SAAO,MAAuB,QAAQ;AAAA,MACpC,OAAO;AAAA,IACT,CAAC;AAAA,EACH;AAKA,aAAW,SAAS,SAAS;AAC3B,QAAI,MAAM,CAAC,EAAE,UAAU;AAAG,aAAO;AAAA,EACnC;AACA,SAAO;AAAA,IACL;AAAA,IACA,CAACC,WAAU,EAAE,OAAO,KAAK,IAAI,GAAGA,MAAK,QAAQ,CAAC,EAAE;AAAA,IAChD;AAAA,MACE,OAAO;AAAA,IACT;AAAA,EACF;AACF;;;AC1BA;AAAA,SAAiB,cAAAC,oBAAkB;AAM5B,SAAS,mBACd,QACA,EAAE,KAAK,OAAO,UAAU,IAAuB,CAAC,GAChD;AACA,QAAM,eAAe;AAAA,IACnB;AAAA,IACA;AAAA,IACA,EAAE,GAAG;AAAA,EACP;AACA,MAAI,CAAC;AAAc,WAAO;AAC1B,QAAM,cAAc,CAAC,aAAa,CAAC,EAAE;AACrC,EAAAC,aAAW;AAAA,IACT;AAAA,IACA,EAAE,SAAS,YAAY;AAAA,IACvB,EAAE,IAAI,aAAa,CAAC,EAAE;AAAA,EACxB;AACF;;;ALRO,SAAS,kBAAkB,QAAgB;AAChD,SAAO;AAAA,IACL,QAAQ,SAASC,SAAQ,MAAM;AAAA,IAC/B,SAAS,SAAS,SAAS,MAAM;AAAA,IACjC,sBAAsB,SAAS,sBAAsB,MAAM;AAAA,IAC3D,oBAAoB,SAAS,oBAAoB,MAAM;AAAA,IACvD,iBAAiB,SAAS,iBAAiB,MAAM;AAAA,IACjD,aAAa,SAASC,cAAa,MAAM;AAAA,IACzC,oBAAoB,SAAS,oBAAoB,MAAM;AAAA,EACzD;AACF;;;AMxBA;;;ACAA;AAAA,SAAiB,WAAAC,WAA0B,cAAAC,oBAAkB;AAM7D,IAAM,oBAAoB,oBAA4C;AAAA,EACpE;AACF,CAAC;AAyBM,SAAS,6BACd,QACA,OACS;AACT,QAAM,CAACC,OAAMC,KAAI,IAAI;AACrB,MAAI,CAACC,UAAQ,UAAUF,KAAI;AAAG,WAAO;AACrC,SAAO,kBAA2B,QAAQ,CAACA,OAAMC,KAAI,GAAG,CAAC,GAAG,MAAM;AAKhE,QAAI,CAAC,kBAAkB,EAAE,CAAC,CAAC;AAAG,aAAO;AAMrC,UAAM,iBAAiB,CAAC,kBAAkB,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE;AAIrE,QAAI,EAAE,CAAC,EAAE,mBAAmB,gBAAgB;AAC1C,MAAAE,aAAW,SAAS,QAAQ,EAAE,eAAe,GAAG,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC;AAC5D,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;ADtDO,SAASC,eAAc,QAAgB,OAAiC;AAC7E,QAAM,CAACC,KAAI,IAAI;AAIf,MAAI,CAAC,WAAWA,KAAI;AAAG,WAAO;AAC9B,SAAO,6BAA6B,QAAQ,KAAK;AACnD;;;AEbA;;;ACAA;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAS,aAAAC,kBAAiB;AAC1B,SAAS,eAAAC,cAAa,kBAAAC,wBAAsB;;;ACF5C;AAAA,OAAOC,cAAY;AAInB,IAAM,YAAYC,SAAO,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAOtB,IAAM,qBAAqBA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAY3C,IAAM,mBAAmBA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAW9B,UAAU,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgB9C,IAAM,gBAAgBA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADxBzC,gBAAAC,aAAA;AAhBG,SAAS,gBAAgB;AAAA,EAC9B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAA0D;AACxD,QAAM,SAASC,iBAAe;AAC9B,EAAAC,WAAU,MAAM;AACd,UAAMC,QAAOC,aAAY,SAAS,QAAQJ,QAAO;AACjD,iCAA6B,QAAQ,CAACA,UAASG,KAAI,CAAC;AAAA,EACtD,GAAG,CAAC,CAAC;AACL,QAAM,QAAQ;AAAA,IACZ,qBAAqBH,SAAQ;AAAA,IAC7B,mBAAmB,mBAAmBA,SAAQ;AAAA,EAChD;AACA,QAAM,YAAYK,MAAK,EAAE,oBAAoBL,SAAQ,eAAe,CAAC;AACrE,SACE,gBAAAD,MAAC,oBAAkB,GAAG,YAAY,WAAsB,OACrD,UACH;AAEJ;;;AE9BA;AAAA,SAAS,eAAAO,qBAAmB;AAC5B,SAAS,kBAAAC,wBAAsB;;;ACD/B;AAOE,SAYE,OAAAC,OAZF,QAAAC,cAAA;AADK,IAAM,gBAAgB,CAAC,UAC5B,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,OAAM;AAAA,IACN,QAAO;AAAA,IACP,aAAa;AAAA,IACb,QAAO;AAAA,IACP,MAAK;AAAA,IACL,eAAc;AAAA,IACd,gBAAe;AAAA,IACf,SAAQ;AAAA,IACP,GAAG;AAAA,IAEJ;AAAA,sBAAAD,MAAC,UAAK,GAAE,iBAAgB,QAAO,QAAO;AAAA,MACtC,gBAAAA,MAAC,UAAK,GAAG,GAAG,GAAG,GAAG,OAAO,IAAI,QAAQ,IAAI,IAAI,GAAG;AAAA;AAAA;AAClD;AAMK,IAAM,cAAc,CAAC,UAC1B,gBAAAC;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,WAAU;AAAA,IACV,OAAM;AAAA,IACN,QAAO;AAAA,IACP,aAAa;AAAA,IACb,QAAO;AAAA,IACP,MAAK;AAAA,IACL,eAAc;AAAA,IACd,gBAAe;AAAA,IACf,SAAQ;AAAA,IACP,GAAG;AAAA,IAEJ;AAAA,sBAAAD,MAAC,UAAK,GAAE,iBAAgB,QAAO,QAAO;AAAA,MACtC,gBAAAA,MAAC,UAAK,GAAE,iBAAgB,WAAU,eAAc;AAAA,MAChD,gBAAAA,MAAC,UAAK,GAAE,4DAA2D;AAAA;AAAA;AACrE;AAMK,IAAM,aAAa,CAAC,UACzB,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,SAAQ;AAAA,IACR,MAAK;AAAA,IACL,OAAM;AAAA,IACN,QAAO;AAAA,IACN,GAAG;AAAA,IAEJ,0BAAAA,MAAC,UAAK,GAAE,yDAAwD;AAAA;AAClE;;;ADvCE,SAGM,OAAAE,OAHN,QAAAC,cAAA;AAZG,SAAS,aAAa;AAAA,EAC3B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAuD;AACrD,QAAM,SAASC,iBAAe;AAC9B,QAAM,SAASC,cAAY,MAAM;AAC/B,WAAO,KAAK,mBAAmB,EAAE,IAAIF,SAAQ,CAAC;AAAA,EAChD,GAAG,CAAC,QAAQA,QAAO,CAAC;AAEpB,QAAM,QAAQ,EAAE,qBAAqBA,SAAQ,MAAM;AACnD,SACE,gBAAAD,OAAC,iBAAe,GAAG,YAAY,OAC7B;AAAA,oBAAAD,MAAC,SAAI,WAAU,oBAAmB,iBAAiB,OAChD,UAAAE,SAAQ,UACP,gBAAAF,MAAC,eAAY,SAAS,QAAQ,OAAO,EAAE,QAAQ,UAAU,GAAG,IAE5D,gBAAAA,MAAC,iBAAc,SAAS,QAAQ,OAAO,EAAE,QAAQ,UAAU,GAAG,GAElE;AAAA,IACC;AAAA,KACH;AAEJ;;;AEhCA;AAaI,SAEI,OAAAK,OAFJ,QAAAC,cAAA;AAPG,SAAS,kBAAkB;AAAA,EAChC,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAA4D;AAC1D,QAAM,QAAQ,EAAE,qBAAqBA,SAAQ,MAAM;AACnD,SACE,gBAAAD,OAAC,sBAAoB,GAAG,YAAY,OAClC;AAAA,oBAAAD,MAAC,SAAI,WAAU,oBAAmB,iBAAiB,OACjD,0BAAAA,MAAC,cAAW,GACd;AAAA,IACC;AAAA,KACH;AAEJ;;;ALLQ,gBAAAG,aAAA;AARD,SAASC,eAAc;AAAA,EAC5B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAmD;AACjD,UAAQA,SAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aACE,gBAAAF,MAAC,mBAAgB,SAASE,UAAS,YAChC,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,qBAAkB,SAASE,UAAS,YAClC,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,gBAAa,SAASE,UAAS,YAC7B,UACH;AAAA,EAEN;AACF;;;AMhCA;;;AfmBO,IAAM,kBAA6C;AAAA,EACxD;AAAA,EACA;AAAA,EACA;AACF;AAEO,IAAM,aAAa,oBAAqC,eAAe;AAEvE,IAAM,aAAa;AAAA,EACxB,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,eAAe,sBAAsB,eAAe;AAC3D,UAAMC,QAAQ,OAAO,OAAO,kBAAkB,MAAM;AACpD,UAAM,gBAAgB,oBAAoB;AAAA,MACxC,KAAKA,MAAK;AAAA,MACV,aAAaA,MAAK;AAAA,MAClB,WAAW,SAASA,MAAK,oBAAoB,IAAI;AAAA,MACjD,WAAW,SAASA,MAAK,sBAAsB,IAAI;AAAA,MACnD,WAAW,SAASA,MAAK,iBAAiB,IAAI;AAAA,IAChD,CAAC;AAED,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,eAAe,CAAC,UAAUC,eAAc,QAAQ,KAAK;AAAA,QACrD,aAAaD,MAAK;AAAA,QAClB,gBAAgB,CAAC,SAAS;AASxB,cAAI,SAAS;AAAa,mBAAO;AACjC,cAAI,CAAC,iBAAiB,QAAQ,UAAU;AAAG,mBAAO;AAClD,gBAAME,YAAW,cAA+B,QAAQ,UAAU;AAClE,cAAI,CAACA;AAAU,mBAAO;AACtB,gBAAM,eAAeA,UAAS,CAAC;AAK/B,cAAI,CAACC,MAAK,YAAY,YAAY,GAAG;AACnC,mBAAO,qBAAqB,iBAAiB;AAC7C,mBAAO;AAAA,UACT;AACA,gBAAM,kBAAkBA,MAAK,SAAS,YAAY;AAClD,gBAAM,mBAAmBC,SAAO,KAAK,QAAQ,eAAe;AAC5D,cAAI,WAAW,iBAAiB,CAAC,CAAC;AAAG,mBAAO;AAK5C,iBAAO,qBAAqB,iBAAiB;AAC7C,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,eAAe;AAAA,QACb,eAAAC;AAAA,QACA,UAAU,GAAG;AACX,cAAI,CAACD,SAAO,MAAM,QAAQ,EAAE,OAAO,WAAW,CAAC;AAAG,mBAAO;AACzD,iBAAO,cAAc,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AgBtFA;AAAA,SAAS,QAAAE,aAAY;;;ACArB;;;ACAA;AAAA,SAAS,UAAAC,UAAQ,SAAAC,QAAa,cAAAC,oBAAkB;;;ACAhD;AAAA,SAAS,UAAAC,gBAAqB;AAkBvB,SAAS,kBACd,QACAC,QACA,eACA,aACA;AACA,QAAM,aAAaD,SAAO,OAAO,QAAQC,QAAO;AAAA,IAC9C,MAAM;AAAA,IACN,UAAU;AAAA,EACZ,CAAC;AACD,QAAM,WACJ,gBAAgB,SACZA,SACAD,SAAO,OAAO,QAAQC,QAAO;AAAA,IAC3B,MAAM;AAAA,IACN,UAAU;AAAA,EACZ,CAAC;AACP,MAAI,CAAC;AACH,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AACF,MAAI,CAAC;AACH,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AACF,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AACF;;;AC/CA;AAAA,SAAS,UAAAC,UAAQ,WAAAC,iBAAsB;AAchC,SAAS,0BACd,QACAC,QACe;AAIf,QAAM,aAAa;AAAA,IACjB;AAAA,IACA,CAACC,UACCC,UAAQ,UAAUD,KAAI,KACtB,CAACE,SAAO,OAAO,QAAQF,KAAI,KAC3BE,SAAO,QAAQ,QAAQF,KAAI;AAAA,EAC/B;AACA,MAAI,cAAc;AAAM,WAAO;AAC/B,QAAM,QAAQ;AAAA,IACZ,QAAQE,SAAO,MAAM,QAAQ,WAAW,CAAC,CAAC;AAAA,IAC1C,OAAOH;AAAA,EACT;AACA,SAAOG,SAAO,OAAO,QAAQ,KAAK;AACpC;;;AF3BO,SAAS,iBACd,QACAC,OACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GACkB;AAClB,MAAI,OAAO,cAAc;AAAM,WAAO;AACtC,MAAIC,OAAM,WAAW,OAAO,SAAS;AAAG,WAAO;AAC/C,MAAID,UAAS;AAAe,WAAO;AAKnC,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA,OAAO,UAAU;AAAA,EACnB;AACA,QAAM,aAAa,GAAG,mBAAmBA;AAIzC,QAAM,QAAQ,WAAW,MAAM,MAAM;AACrC,MAAI,SAAS;AAAM,WAAO;AAC1B,MAAI,MAAM,WAAW;AACnB,UAAM,IAAI;AAAA,MACR,qEACE,MAAM,SAAS;AAAA,IAEnB;AAMF,SAAO,MAAM;AAKX,QAAI,OAAO,cAAc;AAAM,aAAO;AACtC,QAAIC,OAAM,WAAW,OAAO,SAAS;AAAG,aAAO;AAK/C,UAAM,sBAAsB;AAAA,MAC1B;AAAA,MACA,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOjB,MAAM,CAAC,EAAE;AAAA,IACX;AACA,IAAAC,aAAW,OAAO,QAAQ,EAAE,IAAI,oBAAoB,CAAC;AAKrD,UAAM,sBAAsB;AAAA,MAC1B;AAAA,MACA,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOjB,MAAM,CAAC,EAAE,SAAS,MAAM,CAAC,EAAE;AAAA,MAC3B,MAAM,CAAC,EAAE;AAAA,IACX;AACA,IAAAA,aAAW,OAAO,QAAQ,EAAE,IAAI,oBAAoB,CAAC;AAKrD,UAAM,aAAa;AAAA,MACjB;AAAA,MACA,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOjB,MAAM,CAAC,EAAE;AAAA,IACX;AAgBA,WAAO,YAAY,WAAW,MAAM,QAAW,EAAE,IAAI,WAAW,CAAC;AAMjE,IAAAC,SAAO,WAAW,QAAQ,IAAI;AAAA,EAChC;AACF;;;ADpHO,SAAS,WAAW,QAAgBC,OAAgC;AACzE,SACE,iBAAiB,QAAQA,OAAM;AAAA,IAC7B,eAAe;AAAA,IACf,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,KACD,iBAAiB,QAAQA,OAAM;AAAA,IAC7B,eAAe;AAAA,IACf,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,KACD,iBAAiB,QAAQA,OAAM;AAAA,IAC7B,eAAe;AAAA,IACf,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,KACD,iBAAiB,QAAQA,OAAM;AAAA,IAC7B,eAAe;AAAA,IACf,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,KACD,iBAAiB,QAAQA,OAAM;AAAA,IAC7B,eAAe;AAAA,IACf,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC;AAEL;;;AIlCA;;;ACAA;AAAA,SAAS,UAAAC,UAAkB,QAAAC,OAAM,cAAAC,oBAAkB;AAY5C,SAAS,YACd,QACA,EAAE,KAAK,OAAO,UAAU,IAA8B,CAAC,GACvD;AACA,MAAI,MAAM;AAAM;AAChB,QAAM,cAAc;AAAA,IAClB,GAAGF,SAAO,MAAM,QAAQ;AAAA,MACtB,OAAO,CAAC,MAAMC,MAAK,OAAO,CAAC;AAAA,MAC3B;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,SAA+B,CAAC;AACtC,aAAW,CAACE,KAAI,KAAK,aAAa;AAChC,eAAWC,QAAO,OAAO,KAAKD,KAAI,GAAG;AACnC,UAAIC,SAAQ;AAAQ;AACpB,aAAOA,IAAG,IAAI;AAAA,IAChB;AAAA,EACF;AACA,EAAAF,aAAW,SAAS,QAAQ,QAAQ;AAAA,IAClC,OAAO,CAAC,MAAMD,MAAK,OAAO,CAAC;AAAA,IAC3B,OAAO;AAAA,IACP;AAAA,EACF,CAAC;AACH;;;ACnCA;AAAA,SAAS,UAAAI,UAAkB,QAAAC,OAAM,cAAAC,oBAAkB;AAY5C,SAAS,WACd,QACA,SACA,UACA,EAAE,KAAK,OAAO,UAAU,IAA8B,CAAC,GACvD;AACA,MAAI,MAAM;AAAM;AAChB,QAAM,CAAC,KAAK,IAAIF,SAAO,MAAM,QAAQ;AAAA,IACnC,OAAO,CAAC,MAAMC,MAAK,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO;AAAA,IAC3C;AAAA,EACF,CAAC;AACD,EAAAC,aAAW;AAAA,IACT;AAAA,IACA,EAAE,CAAC,OAAO,GAAG,CAAC,SAAS,KAAK;AAAA,IAC5B;AAAA,MACE,OAAO,CAAC,MAAMD,MAAK,OAAO,CAAC;AAAA,MAC3B,OAAO;AAAA,MACP;AAAA,IACF;AAAA,EACF;AACA,MAAI,OAAO,aAAa,UAAU;AAChC,IAAAC,aAAW,WAAW,QAAQ,UAAU;AAAA,MACtC,OAAO,CAAC,MAAMD,MAAK,OAAO,CAAC;AAAA,MAC3B,OAAO;AAAA,MACP;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AFhCO,SAAS,mBAAmB,QAAgB;AACjD,SAAO;AAAA,IACL,aAAa,SAAS,aAAa,MAAM;AAAA,IACzC,YAAY,SAAS,YAAY,MAAM;AAAA,IACvC,YAAY,MAAM,WAAW,QAAQ,MAAM;AAAA,IAC3C,cAAc,MAAM,WAAW,QAAQ,QAAQ;AAAA,IAC/C,iBAAiB,MAAM,WAAW,QAAQ,WAAW;AAAA,IACrD,WAAW,MAAM,WAAW,QAAQ,OAAO,KAAK;AAAA,IAChD,WAAW,MAAM,WAAW,QAAQ,OAAO,KAAK;AAAA,IAChD,cAAc,MAAM,WAAW,QAAQ,QAAQ;AAAA,EACjD;AACF;;;AGlBA;AAAA,OAAOE,cAAY;AAEZ,IAAM,aAAaA,SAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ARwD7B,gBAAAC,aAAA;AAnBH,IAAM,cAAc,aAAqC,CAAC,WAAW;AAC1E,SAAO,cAAc,mBAAmB,MAAM;AAC9C,QAAM,gBAAgB,oBAAoB;AAAA,IACxC,SAAS,OAAO,YAAY;AAAA,IAC5B,SAAS,OAAO,YAAY;AAAA,IAC5B,SAAS,OAAO,YAAY;AAAA,IAC5B,WAAW,OAAO,YAAY;AAAA,IAC9B,WAAW,OAAO,YAAY;AAAA,IAC9B,WAAW,OAAO,YAAY;AAAA,IAC9B,WAAW,OAAO,YAAY;AAAA,EAChC,CAAC;AACD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,YAAY,SAAS,YAAY,MAAM;AAAA,IACzC;AAAA,IACA,eAAe;AAAA,MACb,YAAY,CAAC,EAAE,MAAM,SAAS,MAAM;AAClC,eACE,gBAAAA;AAAA,UAAC;AAAA;AAAA,YACC,WAAWC,MAAK;AAAA,cACd,UAAU,KAAK;AAAA,cACf,YAAY,KAAK;AAAA,cACjB,eAAe,KAAK;AAAA,cACpB,SAAS,KAAK;AAAA,cACd,SAAS,KAAK;AAAA,cACd,YAAY,KAAK;AAAA,YACnB,CAAC;AAAA,YAEA;AAAA;AAAA,QACH;AAAA,MAEJ;AAAA,MACA,WAAW,CAAC,MAAM;AAChB,YAAI,cAAc,CAAC;AAAG,iBAAO;AAmB7B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF,CAAC;;;AShGD;AAAA,SAAS,UAAAC,UAAQ,SAAAC,cAAa;AAa9B,SAAS,6BAA6B,QAAgB;AACpD,MAAI,CAAC,OAAO;AAAW;AACvB,QAAM,QAAQC,SAAO,OAAO,QAAQ,OAAO,SAAS;AACpD,qBAAmB,QAAQ,MAAM,CAAC,CAAC;AACrC;AAmBO,IAAM,6BACX,aAAoD,CAAC,WAAW;AAC9D,SAAO,uBAAuB;AAC9B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ;AAAA,MACN,iBAAiB;AACf,YAAI,CAAC,OAAO;AAAW,iBAAO;AAC9B,cAAM,QAAQA,SAAO,OAAO,QAAQ,OAAO,SAAS;AACpD,cAAM,UAAUC,OAAM;AAAA,UACpBD,SAAO,MAAM,QAAQ,MAAM,CAAC,CAAC;AAAA,UAC7B,OAAO,UAAU;AAAA,QACnB;AACA,YAAI,CAAC;AAAS,iBAAO;AACrB,eAAO,WAAY;AACjB,uCAA6B,MAAM;AAAA,QACrC;AAAA,MACF;AAAA,MACA,gBAAgB;AACd,YAAI,CAAC,OAAO;AAAW,iBAAO;AAC9B,cAAM,QAAQA,SAAO,OAAO,QAAQ,OAAO,SAAS;AACpD,cAAM,QAAQC,OAAM;AAAA,UAClBD,SAAO,IAAI,QAAQ,MAAM,CAAC,CAAC;AAAA,UAC3B,OAAO,UAAU;AAAA,QACnB;AACA,YAAI,CAAC;AAAO,iBAAO;AACnB,eAAO,WAAY;AACjB,uCAA6B,MAAM;AAAA,QACrC;AAAA,MACF;AAAA,IACF;AAAA,IACA,eAAe,CAAC;AAAA,EAClB;AACF,CAAC;;;ACrEH;AAAA,SAAS,WAAAE,iBAA0B;;;ACAnC;AAAA,SAAS,UAAAC,UAAQ,QAAAC,QAAM,cAAAC,oBAAkB;;;ACAzC;AAAA,SAAoB,UAAAC,UAAQ,QAAAC,cAAmB;AAIxC,SAAS,4BACd,QACA,aACA,gBACS;AAMT,QAAM,YAAY,CAAC,GAAGC,SAAO,UAAU,QAAQ,EAAE,IAAI,YAAY,CAAC,CAAC;AAKnE,QAAM,mBAA4B,CAAC;AAEnC,MAAI,UAAqB,SAAoB;AAC7C,aAAW,UAAU,UAAU,CAAC;AAChC,gBAAc,kBAAkB,QAAQ,gBAAgB;AAAA,IACtD,IAAI;AAAA,EACN,CAAC;AAED,aAAW,OAAO,WAAW;AAC3B,UAAM,SAAS,kBAAkB,QAAQ,gBAAgB;AAAA,MACvD,IAAI;AAAA,IACN,CAAC;AASD,QACG,eAAe,UAAUC,OAAK,OAAO,aAAa,MAAM,KACxD,eAAe,UAAa,UAAU,QACvC;AACA,gBAAU;AAAA,IACZ,OAAO;AAQL,YAAMC,SAAQ,EAAE,QAAQ,UAAU,OAAO,QAAQ;AACjD,uBAAiB,KAAKA,MAAK;AAC3B,iBAAW,UAAU;AACrB,oBAAc;AAAA,IAChB;AAAA,EACF;AACA,QAAM,QAAQ,EAAE,QAAQ,UAAU,OAAO,QAAQ;AACjD,mBAAiB,KAAK,KAAK;AAC3B,mBAAiB,QAAQ;AACzB,SAAO;AACT;;;ADrCO,SAAS,iCACd,QACA,gBACA;AACA,MAAI,OAAO,aAAa;AAAM,WAAO;AACrC,QAAM,CAAC,OAAO,GAAG,IAAIC,SAAO,MAAM,QAAQ,OAAO,SAAS;AAC1D,QAAM,qBAAqB,kBAAkB,QAAQ,gBAAgB;AAAA,IACnE,IAAI;AAAA,EACN,CAAC;AACD,QAAM,mBAAmB,kBAAkB,QAAQ,gBAAgB;AAAA,IACjE,IAAI;AAAA,EACN,CAAC;AAKD,MAAI,CAAC,sBAAsB,CAAC,kBAAkB;AAC5C,WAAO;AAAA,EACT;AAMA,MACE,sBACA,oBACAC,OAAK,OAAO,oBAAoB,gBAAgB,GAChD;AACA,WAAO;AAAA,EACT;AAMA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA,OAAO;AAAA,IACP;AAAA,EACF;AAcA,EAAAD,SAAO,mBAAmB,QAAQ,MAAM;AACtC,eAAW,SAAS,gBAAgB;AAClC,MAAAE,aAAW,OAAO,QAAQ,EAAE,IAAI,MAAM,CAAC;AAAA,IACzC;AACA,IAAAA,aAAW,SAAS,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAAA,EAC/C,CAAC;AAED,SAAO;AACT;;;AEvFA;AAAA,SAAiB,cAAAC,oBAAkB;;;ACAnC;AAsCO,SAAS,aACd,QACA,EAAE,KAAK,OAAO,UAAU,IAAwC,CAAC,GAC1C;AACvB,MAAI,MAAM;AAAM,WAAO;AACvB,QAAM,YAAY,cAAgC,QAAQ,cAAc;AAAA,IACtE;AAAA,EACF,CAAC;AACD,MAAI,CAAC;AAAW,WAAO;AACvB,QAAM,WAAW,cAA+B,QAAQ,aAAa;AAAA,IACnE;AAAA,EACF,CAAC;AACD,MAAI,CAAC;AAAU,WAAO;AACtB,QAAM,aAAa,cAA4B,QAAQ,SAAS,EAAE,GAAG,CAAC;AACtE,MAAI,CAAC;AAAY,WAAO;AACxB,QAAM,CAAC,cAAc,SAAS,IAAI;AAClC,QAAM,CAAC,YAAY,OAAO,IAAI;AAC9B,QAAM,CAAC,aAAa,QAAQ,IAAI;AAChC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,cAAc,aAAa;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,UAAU,QAAQ,MAAM,EAAE,EAAE,CAAC;AAAA,IAC7B,UAAU,aAAa,SAAS;AAAA,IAChC;AAAA,IACA;AAAA,IACA,WAAW,SAAS,MAAM,EAAE,EAAE,CAAC;AAAA,IAC/B,WAAW,WAAW,SAAS;AAAA,EACjC;AACF;;;ACrEA;AAAA,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;;;ACAnC;AAEO,SAAS,WACdC,QACA,WAAkC;AAAA,EAChC;AAAA,IACE,MAAM;AAAA,IACN,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC;AAAA,EACzB;AACF,GACkB;AAClB,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,EACF;AACF;;;ADRO,SAAS,aACd,QACA,EAAE,SAAS,GAAG,KAAK,OAAO,UAAU,IAAuC,CAAC,GACnE;AACT,QAAM,IAAI,aAAa,QAAQ,EAAE,GAAG,CAAC;AACrC,MAAI,MAAM;AAAW,WAAO;AAC5B,QAAM,EAAE,cAAc,WAAW,UAAU,IAAI;AAC/C,QAAM,gBAAgB,YAAY;AAClC,EAAAC,SAAO,mBAAmB,QAAQ,MAAM;AACtC,UAAM,EAAE,QAAQ,IAAI;AACpB,UAAM,cAAc,CAAC,GAAG,OAAO;AAK/B,gBAAY,OAAO,eAAe,GAAG,QAAQ,aAAa,CAAC;AAC3D,IAAAC,aAAW,SAAS,QAAQ,EAAE,SAAS,YAAY,GAAG,EAAE,IAAI,UAAU,CAAC;AAKvE,iBAAa,SAAS,QAAQ,CAAC,YAAY,MAAM;AAC/C,MAAAA,aAAW,YAAY,QAAQ,WAAW,aAAa,GAAG;AAAA,QACxD,IAAI,CAAC,GAAG,WAAW,GAAG,aAAa;AAAA,MACrC,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACD,SAAO;AACT;;;AEnCA;AAAA,SAAiB,cAAAC,oBAAkB;AAQnC,SAAS,UAAU,aAAsC;AACvD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU,CAAC,GAAG,MAAM,WAAW,EAAE,KAAK,CAAC,EAAE,IAAI,CAACC,WAAU,WAAWA,MAAK,CAAC;AAAA,EAC3E;AACF;AAMO,SAAS,UACd,QACA,EAAE,KAAK,OAAO,WAAW,SAAS,EAAE,IAAuC,CAAC,GACnE;AACT,QAAM,IAAI,aAAa,QAAQ,EAAE,GAAG,CAAC;AACrC,MAAI,CAAC;AAAG,WAAO;AACf,QAAM,iBAAiB,UAAU,EAAE,aAAa,QAAQ,MAAM;AAC9D,EAAAC,aAAW,YAAY,QAAQ,gBAAgB;AAAA,IAC7C,IAAI,CAAC,GAAG,EAAE,WAAW,EAAE,WAAW,MAAM;AAAA,EAC1C,CAAC;AACD,SAAO;AACT;AAeO,SAAS,eACd,QACA,EAAE,GAAG,IAAuB,CAAC,GACpB;AACT,SAAO,UAAU,QAAQ,EAAE,IAAI,QAAQ,EAAE,CAAC;AAC5C;;;AClDA;AAAA,SAAS,UAAAC,UAAQ,WAAAC,WAAmB,QAAAC,QAAM,cAAAC,oBAAkB;AAO5D,SAAS,YAAY,MAAwB;AAC3C,SAAO,CAAC,GAAG,MAAM,IAAI,EAAE,KAAK,CAAC;AAC/B;AAEA,SAAS,cAAc,aAAoC;AACzD,SAAO,YAAY,WAAW,EAAE,IAAI,OAAO,EAAE,OAAO,OAAO,EAAE;AAC/D;AAEA,SAAS,YAAY,aAAqB,UAAgC;AACxE,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS,cAAc,WAAW;AAAA,IAClC,UAAU,YAAY,QAAQ,EAAE,IAAI,MAAMC,WAAU,WAAW,CAAC;AAAA,EAClE;AACF;AAEA,SAASA,WAAU,aAAsC;AACvD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU,CAAC,GAAG,MAAM,WAAW,EAAE,KAAK,CAAC,EAAE,IAAI,CAACC,WAAU,WAAWA,MAAK,CAAC;AAAA,EAC3E;AACF;AAMO,SAAS,YACd,QACA,aACA,UACA,EAAE,KAAK,OAAO,UAAU,IAA8B,CAAC,GAC9C;AACT,QAAM,QAAQ,YAAY,aAAa,QAAQ;AAC/C,SAAOC,mBAAkB,QAAQ,OAAO,EAAE,GAAG,CAAC;AAChD;AAEO,SAASA,mBACd,QACAC,UACA,EAAE,KAAK,OAAO,UAAU,IAA8B,CAAC,GACvD;AACA,MAAI,MAAM;AAAM,WAAO;AACvB,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,CAACC,UAASC,UAAQ,UAAUD,KAAI,KAAK,OAAO,SAASA,KAAI;AAAA,EAC3D;AACA,MAAI,SAAS,MAAM;AACjB,UAAM,YAAY,OAAO;AACzB,IAAAE,SAAO,mBAAmB,QAAQ,MAAM;AACtC,MAAAC,aAAW,YAAY,QAAQJ,UAAS,EAAE,GAAG,CAAC;AAC9C,UAAI,WAAW;AACb,QAAAI,aAAW,OAAO,QAAQ,SAAS;AACnC,QAAAA,aAAW,KAAK,MAAM;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH,OAAO;AACL,UAAM,WAAWC,OAAK,KAAK,MAAM,CAAC,CAAC;AACnC,IAAAF,SAAO,mBAAmB,QAAQ,MAAM;AACtC,MAAAC,aAAW,YAAY,QAAQJ,UAAS,EAAE,IAAI,SAAS,CAAC;AACxD,MAAAI,aAAW,OAAO,QAAQD,SAAO,MAAM,QAAQ,QAAQ,CAAC;AAAA,IAC1D,CAAC;AAAA,EACH;AACA,SAAO;AACT;;;ACvEA;;;ACAA;AAAA,SAAiB,QAAAG,cAAY;AAMtB,SAAS,mBAAmB,QAAgB,GAAc;AAC/D,QAAM,EAAE,WAAW,UAAU,UAAU,UAAU,IAAI;AAIrD,MAAI,WAAW,WAAW,GAAG;AAC3B,yBAAqB,QAAQ,CAAC,GAAG,WAAW,WAAW,GAAG,SAAS,CAAC;AACpE,WAAO;AAAA,EACT;AAKA,MAAI;AACF,yBAAqB,QAAQC,OAAK,KAAK,SAAS,CAAC;AACjD,WAAO;AAAA,EACT,SAAS,GAAP;AACA,WAAO;AAAA,EACT;AACF;AAEO,SAAS,mBAAmB,QAAgB,GAAc;AAC/D,QAAM,EAAE,WAAW,UAAU,UAAU,IAAI;AAI3C,MAAI,WAAW,GAAG;AAChB,yBAAqB,QAAQ,CAAC,GAAG,WAAW,WAAW,GAAG,SAAS,CAAC;AACpE,WAAO;AAAA,EACT;AAKA,MAAI;AACF,uBAAmB,QAAQA,OAAK,SAAS,SAAS,CAAC;AACnD,WAAO;AAAA,EACT,SAAS,GAAP;AACA,WAAO;AAAA,EACT;AACF;;;AC9CA;AACA,SAAS,eAAAC,qBAAmB;AAuBrB,SAAS,6BAA6C;AAC3D,QAAM,IAAI,OAAO,aAAa;AAC9B,MAAI,CAAC;AAAG,WAAO;AACf,QAAM,QAAQ,EAAE,WAAW,CAAC;AAC5B,SAAO,MAAM,sBAAsB;AACrC;AAMA,SAAS,eAAe,QAAgBC,UAAqB;AAC3D,SAAOD,cAAY,UAAU,QAAQC,QAAO,EAAE,sBAAsB;AACtE;AAEO,SAAS,iBAAiB,QAAgBA,UAA2B;AAM1E,QAAM,gBAAgB,2BAA2B;AACjD,MAAI,CAAC;AAAe,WAAO;AAC3B,QAAM,cAAc,eAAe,QAAQA,QAAO;AAClD,SACE,cAAc,QAAQ,YAAY,SAClC,cAAc,OAAO,YAAY,QACjC,cAAc,SAAS,YAAY,UACnC,cAAc,MAAM,YAAY;AAEpC;;;AF7CO,SAAS,KAAK,QAAyB;AAC5C,QAAM,IAAI,aAAa,MAAM;AAI7B,MAAI,CAAC;AAAG,WAAO;AACf,aAAW,MAAM;AACf,QAAI,CAAC,iBAAiB,QAAQ,EAAE,WAAW,GAAG;AAC5C,yBAAmB,QAAQ,CAAC;AAAA,IAC9B;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAKO,SAAS,GAAG,QAAyB;AAC1C,QAAM,IAAI,aAAa,MAAM;AAI7B,MAAI,CAAC;AAAG,WAAO;AACf,aAAW,MAAM;AACf,QAAI,CAAC,iBAAiB,QAAQ,EAAE,WAAW,GAAG;AAC5C,yBAAmB,QAAQ,CAAC;AAAA,IAC9B;AAAA,EACF,CAAC;AACD,SAAO;AACT;;;AGtCA;AAAA,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;;;ACAnC;AAAA,SAAiB,cAAAC,oBAAkB;AAE5B,SAAS,YAAY,QAAyB;AACnD,QAAM,IAAI,OAAO,YAAY,aAAa;AAC1C,MAAI,MAAM;AAAW,WAAO;AAC5B,EAAAA,aAAW,YAAY,QAAQ,EAAE,IAAI,EAAE,UAAU,CAAC;AAClD,SAAO;AACT;;;ADAO,SAAS,aACd,QACA,EAAE,KAAK,OAAO,UAAU,IAAuB,CAAC,GAChD;AACA,QAAM,IAAI,aAAa,QAAQ,EAAE,GAAG,CAAC;AACrC,MAAI,CAAC;AAAG,WAAO;AAEf,QAAM,EAAE,cAAc,WAAW,UAAU,WAAW,UAAU,IAAI;AACpE,MAAI,cAAc,GAAG;AACnB,WAAO,YAAY,MAAM;AAAA,EAC3B;AACA,EAAAC,SAAO,mBAAmB,QAAQ,MAAM;AAGtC,UAAM,UAAU,CAAC,GAAG,aAAa,OAAO;AACxC,YAAQ,OAAO,WAAW,CAAC;AAC3B,IAAAC,aAAW,SAAS,QAAQ,EAAE,QAAQ,GAAG,EAAE,IAAI,UAAU,CAAC;AAC1D,iBAAa,SAAS,QAAQ,CAAC,YAAYC,cAAa;AACtD,MAAAD,aAAW,YAAY,QAAQ;AAAA,QAC7B,IAAI,CAAC,GAAG,WAAWC,WAAU,SAAS;AAAA,MACxC,CAAC;AAAA,IACH,CAAC;AACD,UAAM,YAAYF,SAAO,MAAM,QAAQ;AAAA,MACrC,GAAG;AAAA,MACH;AAAA,MACA,KAAK,IAAI,WAAW,YAAY,CAAC;AAAA,IACnC,CAAC;AACD,IAAAC,aAAW,OAAO,QAAQ,SAAS;AAAA,EACrC,CAAC;AACH;;;AEpCA;AAAA,SAAS,UAAAE,UAAQ,cAAAC,oBAAkB;AAO5B,SAAS,UACd,QACA,EAAE,KAAK,OAAO,UAAU,IAAuB,CAAC,GAChD;AACA,QAAM,IAAI,aAAa,QAAQ,EAAE,GAAG,CAAC;AACrC,MAAI,MAAM;AAAW,WAAO;AAC5B,MAAI,EAAE,aAAa,GAAG;AACpB,gBAAY,MAAM;AAClB,WAAO;AAAA,EACT;AACA,EAAAC,SAAO,mBAAmB,QAAQ,MAAM;AACtC,IAAAC,aAAW,YAAY,QAAQ,EAAE,IAAI,EAAE,QAAQ,CAAC;AAChD,IAAAA,aAAW;AAAA,MACT;AAAA,MACAD,SAAO,MAAM,QAAQ;AAAA,QACnB,GAAG,EAAE;AAAA,QACL,KAAK,IAAI,EAAE,UAAU,EAAE,WAAW,CAAC;AAAA,QACnC,EAAE;AAAA,MACJ,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACD,SAAO;AACT;;;AC7BA;AAAA,SAAiB,cAAAE,oBAAkB;AAI5B,SAAS,oBACd,QACA,SACA;AACA,QAAM,IAAI,aAAa,MAAM;AAC7B,MAAI,MAAM;AAAW,WAAO;AAC5B,QAAM,EAAE,cAAc,WAAW,UAAU,IAAI;AAC/C,QAAM,cAAc,aAAa,QAAQ,MAAM;AAC/C,cAAY,OAAO,WAAW,GAAG,EAAE,OAAO,QAAQ,MAAM,CAAC;AACzD,EAAAC,aAAW,SAAS,QAAQ,EAAE,SAAS,YAAY,GAAG,EAAE,IAAI,UAAU,CAAC;AACvE,SAAO;AACT;;;ACfA;AAMO,SAAS,WAAW,QAAgB;AACzC,QAAM,IAAI,aAAa,MAAM;AAC7B,MAAI,CAAC;AAAG,WAAO;AAEf,QAAM,EAAE,WAAW,WAAW,UAAU,UAAU,UAAU,IAAI;AAKhE,MAAI,YAAY,YAAY,GAAG;AAC7B,yBAAqB,QAAQ,CAAC,GAAG,WAAW,UAAU,YAAY,CAAC,CAAC;AACpE,WAAO;AAAA,EACT;AAMA,MAAI,WAAW,WAAW,GAAG;AAC3B,yBAAqB,QAAQ,CAAC,GAAG,WAAW,WAAW,GAAG,CAAC,CAAC;AAC5D,WAAO;AAAA,EACT;AAMA,iBAAe,MAAM;AACrB,uBAAqB,QAAQ,CAAC,GAAG,WAAW,WAAW,GAAG,CAAC,CAAC;AAE5D,SAAO;AACT;AAEO,SAAS,YAAY,QAAgB;AAC1C,QAAM,IAAI,aAAa,MAAM;AAC7B,MAAI,CAAC;AAAG,WAAO;AAEf,QAAM,EAAE,WAAW,WAAW,UAAU,UAAU,IAAI;AAEtD,MAAI,YAAY,GAAG;AACjB,yBAAqB,QAAQ,CAAC,GAAG,WAAW,UAAU,YAAY,CAAC,CAAC;AACpE,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,GAAG;AAChB,yBAAqB,QAAQ,CAAC,GAAG,WAAW,WAAW,GAAG,YAAY,CAAC,CAAC;AACxE,WAAO;AAAA,EACT;AACF;;;AbvCO,SAAS,mBAAmB,QAAgB;AACjD,SAAO;AAAA,IACL,cAAc,SAAS,cAAc,MAAM;AAAA,IAC3C,aAAa,SAAS,aAAa,MAAM;AAAA,IACzC,cAAc,SAAS,cAAc,MAAM;AAAA,IAC3C,WAAW,SAAS,WAAW,MAAM;AAAA,IACrC,aAAa,SAAS,aAAa,MAAM;AAAA,IACzC,cAAc,SAAS,cAAc,MAAM;AAAA,IAC3C,WAAW,SAAS,WAAW,MAAM;AAAA,IACrC,YAAY,SAAS,YAAY,MAAM;AAAA,IACvC,aAAa,SAAS,aAAa,MAAM;AAAA,IACzC,YAAY,SAAS,YAAY,MAAM;AAAA,IACvC,MAAM,SAAS,MAAM,MAAM;AAAA,IAC3B,IAAI,SAAS,IAAI,MAAM;AAAA,IACvB,qBAAqB,SAAS,qBAAqB,MAAM;AAAA,EAC3D;AACF;AAEA,SAAS,WACP,QACA,EAAE,KAAK,OAAO,UAAU,IAAuB,CAAC,GAChD;AACA,QAAM,IAAI,aAAa,QAAQ,EAAE,GAAG,CAAC;AACrC,MAAI,MAAM;AAAW,WAAO;AAC5B,QAAM,EAAE,SAAS,IAAI;AACrB,EAAAC,aAAW,OAAO,QAAQ,QAAQ;AAClC,SAAO;AACT;;;Ac1CA;AAAA,SAA4B,cAAAC,oBAAkB;AAIvC,SAAS,sBACd,QACA,OACS;AACT,MAAI,gBAAgB;AACpB,QAAM,cAAc,MAAM,CAAC,EAAE;AAC7B,cAAY,QAAQ,CAAC,YAAY,MAAM;AACrC,UAAM,eAAe,WAAW;AAChC,iBAAa,QAAQ,CAAC,aAAa,MAAM;AACvC,UAAI,YAAY,MAAM,KAAK,YAAY,MAAM,GAAG;AAC9C,QAAAA,aAAW,SAAS,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC;AACjE,wBAAgB;AAAA,MAClB;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACD,SAAO;AACT;;;ACpBA;AAAA,SAAS,UAAAC,UAAmB,cAAAC,oBAAkB;AAIvC,SAAS,mBACd,QACA,OACS;AACT,QAAM,CAACC,OAAMC,KAAI,IAAI;AACrB,MAAID,MAAK,SAAS,WAAW,KAAKA,MAAK,SAAS,CAAC,EAAE,SAAS,iBAAiB;AAC3E,WAAO;AAAA,EACT;AACA,EAAAF,SAAO,mBAAmB,QAAQ,MAAM;AAgBtC,IAAAC,aAAW;AAAA,MACT;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,UAAU,CAAC,EAAE,MAAM,IAAI,CAAC;AAAA,MAC1B;AAAA,MACA,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,EAAE;AAAA,IACzB;AAOA,aAAS,IAAIC,MAAK,SAAS,QAAQ,KAAK,GAAG,KAAK;AAC9C,MAAAD,aAAW,WAAW,QAAQ,EAAE,IAAI,CAAC,GAAGE,OAAM,CAAC,EAAE,CAAC;AAAA,IACpD;AAaA,IAAAF,aAAW,OAAO,QAAQ;AAAA,MACxB,IAAI,EAAE,MAAM,CAAC,GAAGE,OAAM,GAAG,CAAC,GAAG,QAAQ,EAAE;AAAA,MACvC,MAAM;AAAA,IACR,CAAC;AAAA,EACH,CAAC;AACD,SAAO;AACT;;;AC/DA;;;ACAA;AAAA,SAAS,aAAAC,kBAAiB;AAC1B,SAAS,eAAAC,eAAa,eAAAC,cAAa,kBAAAC,wBAAsB;;;ACDzD;AAAA,OAAOC,cAAY;;;ACAnB;AAAA,OAAOC,cAAY;AAMnB,IAAM,YAAYA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BvB,IAAM,cAAcA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYpC,IAAM,WAAWA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcxC,IAAM,YAAYA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBvB,IAAM,kBAAkBA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCxC,IAAM,eAAeA,SAAO,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgC5C,IAAM,cAAcA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWzB,IAAM,iBAAiBA,SAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAOzC,IAAM,oBAAoBA,SAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADtJ5C,IAAM,SAASC,SAAO,OAAO;AAAA;AAAA;AAAA,IAGhC,CAAC,EAAE,QAAQ,MACX,QACG;AAAA,EACC,CAAC,QAAQC,WACP,kBAAkBA,SAAQ,oBAAoB,OAAO;AACzD,EACC,KAAK,IAAI;AAAA;AAMT,IAAM,YAAYD,SAAO,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAY7B,IAAM,aAAaA,SAAO,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyB9B,IAAM,gBAAgBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AE5DzC;AAAA,SAAS,iBAAAE,sBAAqB;AAEvB,IAAM,eAAeA,eAAuC;AAAA,EACjE,YAAY;AACd,CAAC;;;AH4BO,gBAAAC,aAAA;AAtBD,SAAS,MAAM;AAAA,EACpB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAgD;AAC9C,QAAM,SAASC,iBAAe;AAC9B,QAAM,aAAaC,aAAY;AAS/B,EAAAC,WAAU,MAAM;AACd,UAAMC,QAAOC,cAAY,SAAS,QAAQL,QAAO;AACjD,0BAAsB,QAAQ,CAACA,UAASI,KAAI,CAAC;AAAA,EAC/C,GAAG,CAAC,CAAC;AACL,SACE,gBAAAL,MAAC,aAAa,UAAb,EAAsB,OAAO,EAAE,WAAW,GACzC,0BAAAA,MAAC,UAAQ,GAAG,YAAY,SAASC,SAAQ,SACvC,0BAAAD,MAAC,WAAO,UAAS,GACnB,GACF;AAEJ;;;AIpCA;AAAA,SAAS,cAAAO,mBAAkB;AAC3B,SAAS,eAAAC,oBAAmB;;;ACD5B;AAAA,SAAgB,eAAAC,eAAa,UAAAC,SAAQ,YAAAC,iBAAgB;AACrD,SAAS,kBAAAC,wBAAsB;;;ACD/B;AAaI,gBAAAC,aAAA;AATG,IAAM,WAAW,CAAC,UACvB,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,SAAQ;AAAA,IACR,MAAK;AAAA,IACL,OAAM;AAAA,IACN,QAAO;AAAA,IACN,GAAG;AAAA,IAEJ,0BAAAA;AAAA,MAAC;AAAA;AAAA,QACC,UAAS;AAAA,QACT,GAAE;AAAA,QACF,UAAS;AAAA;AAAA,IACX;AAAA;AACF;AAGK,IAAM,YAAY,CAAC,UACxB,gBAAAA;AAAA,EAAC;AAAA;AAAA,IACC,OAAM;AAAA,IACN,SAAQ;AAAA,IACR,MAAK;AAAA,IACL,OAAM;AAAA,IACN,QAAO;AAAA,IACN,GAAG;AAAA,IAEJ,0BAAAA;AAAA,MAAC;AAAA;AAAA,QACC,UAAS;AAAA,QACT,GAAE;AAAA,QACF,UAAS;AAAA;AAAA,IACX;AAAA;AACF;AAGK,IAAM,WAAW,MACtB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,2BAA0B,GACpC;AAGK,IAAM,YAAY,MACvB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,2BAA0B,GACpC;AAGK,IAAM,cAAc,MACzB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,0BAAyB,GACnC;AAGK,IAAM,aAAa,MACxB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,4BAA2B,GACrC;;;ADKkB,SAeZ,YAAAC,WAfY,OAAAC,OAeZ,QAAAC,cAfY;AA1Cb,SAAS,WAAW,EAAE,YAAY,GAAsC;AAC7E,QAAM,SAASC,iBAAe;AAC9B,QAAM,OAAO,SAAS,aAAa;AACnC,QAAM,YAAYC,QAAuB,IAAI;AAC7C,QAAM,CAAC,OAAO,QAAQ,IAAIC,UAAS,KAAK;AAExC,QAAM,eAAeC,cAAY,MAAM;AACrC,aAAS,IAAI;AAAA,EACf,GAAG,CAAC,CAAC;AAEL,QAAM,eAAeA,cAAY,MAAM;AACrC,aAAS,KAAK;AAAA,EAChB,GAAG,CAAC,CAAC;AAEL,QAAM,UAAUA,cAAY,MAAM;AAChC,QAAI,KAAK;AAAO,WAAK,MAAM;AAC3B,UAAM,OAAO,UAAU;AACvB,QAAI,SAAS;AAAM;AACnB,UAAM,QAAwB;AAAA,MAC5B;AAAA,QACE,MAAM;AAAA,QACN,OAAO;AAAA,QACP,QAAQ,MAAM;AACZ,iBAAO,YAAY,oBAAoB,EAAE,OAAO,OAAO,CAAC;AAAA,QAC1D;AAAA,MACF;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,OAAO;AAAA,QACP,QAAQ,MAAM;AACZ,iBAAO,YAAY,oBAAoB,EAAE,OAAO,SAAS,CAAC;AAAA,QAC5D;AAAA,MACF;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,OAAO;AAAA,QACP,QAAQ,MAAM;AACZ,iBAAO,YAAY,oBAAoB,EAAE,OAAO,QAAQ,CAAC;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AAEA,SAAK,KAAK,MAAM,gBAAAL,MAAC,QAAK,MAAY,OAAc,OAAO,KAAK,OAAO,CAAE;AAAA,EACvE,GAAG,CAAC,CAAC;AAEL,SACE,gBAAAC;AAAA,IAAC;AAAA;AAAA,MACC,KAAK;AAAA,MACL,iBAAiB;AAAA,MACjB;AAAA,MACA;AAAA,MACA;AAAA,MAEA;AAAA,wBAAAD,MAAC,mBAAgB,WAAU,UACzB,0BAAAA,MAAC,YAAS,GACZ;AAAA,QACC,QACC,gBAAAC,OAAAF,WAAA,EACE;AAAA,0BAAAC;AAAA,YAAC;AAAA;AAAA,cACC,OAAO;AAAA,gBACL,KAAK;AAAA,gBACL,MAAM;AAAA,gBACN,YAAY;AAAA,cACd;AAAA,cACA,aAAa,MACX,OAAO,YAAY,aAAa,EAAE,IAAI,YAAY,CAAC;AAAA,cAGrD,0BAAAA,MAAC,aAAU;AAAA;AAAA,UACb;AAAA,UAEA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,OAAO,EAAE,MAAM,UAAU,KAAK,EAAE;AAAA,cAChC,aAAa,MACX,OAAO,YAAY,aAAa,EAAE,IAAI,YAAY,CAAC;AAAA,cAGrD,0BAAAA,MAAC,YAAS;AAAA;AAAA,UACZ;AAAA,UACA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,OAAO,EAAE,OAAO,UAAU,KAAK,EAAE;AAAA,cACjC,aAAa,MACX,OAAO,YAAY,aAAa,EAAE,IAAI,aAAa,QAAQ,EAAE,CAAC;AAAA,cAGhE,0BAAAA,MAAC,YAAS;AAAA;AAAA,UACZ;AAAA,WACF,IACE;AAAA;AAAA;AAAA,EACN;AAEJ;;;AEjHA;AAAA,SAAgB,YAAAM,iBAAgB;AAChC,SAAS,kBAAAC,wBAAsB;AAsBvB,SAGA,YAAAC,WAHA,OAAAC,OAGA,QAAAC,cAHA;AAXD,SAAS,QAAQ,EAAE,YAAY,GAAsC;AAC1E,QAAM,SAASC,iBAAe;AAC9B,QAAM,CAAC,OAAO,QAAQ,IAAIC,UAAS,KAAK;AAExC,SACE,gBAAAF;AAAA,IAAC;AAAA;AAAA,MACC,iBAAiB;AAAA,MACjB,cAAc,MAAM,SAAS,IAAI;AAAA,MACjC,cAAc,MAAM,SAAS,KAAK;AAAA,MAElC;AAAA,wBAAAD,MAAC,gBAAa,WAAU,UACtB,0BAAAA,MAAC,YAAS,GACZ;AAAA,QACC,QACC,gBAAAC,OAAAF,WAAA,EACE;AAAA,0BAAAC;AAAA,YAAC;AAAA;AAAA,cACC,OAAO;AAAA,gBACL,KAAK;AAAA,gBACL,MAAM;AAAA,gBACN,WAAW;AAAA,cACb;AAAA,cACA,aAAa,MACX,OAAO,YAAY,UAAU,EAAE,IAAI,YAAY,CAAC;AAAA,cAGlD,0BAAAA,MAAC,aAAU;AAAA;AAAA,UACb;AAAA,UACA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,OAAO,EAAE,KAAK,UAAU,MAAM,QAAQ;AAAA,cACtC,aAAa,MACX,OAAO,YAAY,UAAU,EAAE,IAAI,YAAY,CAAC;AAAA,cAGlD,0BAAAA,MAAC,YAAS;AAAA;AAAA,UACZ;AAAA,UACA,gBAAAA;AAAA,YAAC;AAAA;AAAA,cACC,OAAO,EAAE,QAAQ,UAAU,MAAM,QAAQ;AAAA,cACzC,aAAa,MACX,OAAO,YAAY,UAAU,EAAE,IAAI,aAAa,QAAQ,EAAE,CAAC;AAAA,cAG7D,0BAAAA,MAAC,YAAS;AAAA;AAAA,UACZ;AAAA,WACF,IACE;AAAA;AAAA;AAAA,EACN;AAEJ;;;AC3DA;;;ACAA;AAAA,OAAOI,cAAY;AAEZ,IAAM,aAAaA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAsC/B,IAAM,iBAAiBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADnCpC,gBAAAC,aAAA;AAHC,SAAS,YAAY;AAC1B,SACE,gBAAAA,MAAC,cAAW,iBAAiB,OAC3B,0BAAAA,MAAC,kBAAe,WAAU,qBAAoB,GAChD;AAEJ;;;AJyBI,SAOmB,OAAAC,OAPnB,QAAAC,cAAA;AArBG,SAAS,UAAU;AAAA,EACxB,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAAoD;AAClD,QAAM,eAAeC,YAAW,YAAY;AAC5C,QAAM,WAAWC,aAAY;AAI7B,QAAM,gBACJ,aAAa,cAAcF,SAAQ,MAAM,KAAKA,SAAQ,MAAM;AAI9D,QAAM,cAAc,aAAa,cAAcA,SAAQ,MAAM;AAI7D,QAAM,iBAAiB,aAAa,cAAcA,SAAQ,MAAM;AAChE,SACE,gBAAAD;AAAA,IAAC;AAAA;AAAA,MACC,WAAW,WAAW,eAAe;AAAA,MACpC,GAAG;AAAA,MACJ,UAAQC,SAAQ;AAAA,MAChB,UAAQA,SAAQ;AAAA,MAEf;AAAA;AAAA,QACA,gBAAgB,gBAAAF,MAAC,aAAU,IAAK;AAAA,QAChC,cAAc,gBAAAA,MAAC,WAAQ,aAAaE,UAAS,IAAK;AAAA,QAClD,iBAAiB,gBAAAF,MAAC,cAAW,aAAaE,UAAS,IAAK;AAAA;AAAA;AAAA,EAC3D;AAEJ;;;AM7CA;AASS,gBAAAG,aAAA;AAJF,SAAS,aAAa;AAAA,EAC3B;AAAA,EACA;AACF,GAAuD;AACrD,SAAO,gBAAAA,MAAC,iBAAe,GAAG,YAAa,UAAS;AAClD;;;ACVA;AASS,gBAAAC,aAAA;AAJF,SAAS,SAAS;AAAA,EACvB;AAAA,EACA;AACF,GAAmD;AACjD,SAAO,gBAAAA,MAAC,aAAW,GAAG,YAAa,UAAS;AAC9C;;;AZaQ,gBAAAC,aAAA;AAVD,SAASC,eAAc;AAAA,EAC5B,SAAAC;AAAA,EACA;AAAA,EACA;AACF,GAEG;AACD,UAAQA,SAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aACE,gBAAAF,MAAC,SAAM,SAASE,UAAS,YACtB,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,YAAS,SAASE,UAAS,YACzB,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,aAAU,SAASE,UAAS,YAC1B,UACH;AAAA,IAEJ,KAAK;AACH,aACE,gBAAAF,MAAC,gBAAa,SAASE,UAAS,YAC7B,UACH;AAAA,EAEN;AACF;;;Aa9CA;;;AhCwCO,IAAM,cAAc;AAAA,EACzB,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,gBAAgB;AACvB,WAAO,cAAc,mBAAmB,MAAM;AAC9C,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,gBAAgB,MAAM;AAKpB,iBAAO,iBAAiB,QAAQ,YAAY;AAAA,QAC9C;AAAA,QACA,eAAe,MAAM;AAKnB,iBAAO,eAAe,QAAQ,YAAY;AAAA,QAC5C;AAAA,QACA,gBAAgB,MACd,iCAAiC,QAAQ,CAAC,YAAY,CAAC;AAAA,QACzD,aAAa,MAAM;AAIjB,gBAAM,QAAQ,cAAc,QAAQ,YAAY;AAChD,iBAAO,CAAC,CAAC;AAAA,QACX;AAAA,QACA,SAASC,UAAS;AAChB,cAAIA,SAAQ,SAAS;AAAS,mBAAO;AAAA,QACvC;AAAA,QACA,eAAe,CAAC,UAAmB;AACjC,gBAAM,CAACC,KAAI,IAAI;AACf,cAAI,CAACC,UAAQ,UAAUD,KAAI;AAAG,mBAAO;AACrC,kBAAQA,MAAK,MAAM;AAAA,YACjB,KAAK;AACH,qBAAO;AAAA,gBACL;AAAA,gBACA;AAAA,cACF;AAAA,YACF,KAAK,cAAc;AACjB,qBAAO;AAAA,gBACL;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,eAAe;AAAA,QACb,eAAAE;AAAA,QACA,WAAW,oBAAoB;AAAA;AAAA;AAAA;AAAA,UAI7B,KAAK,OAAO,YAAY;AAAA,UACxB,aAAa,OAAO,YAAY;AAAA,UAChC,MAAM,OAAO,YAAY;AAAA,UACzB,IAAI,OAAO,YAAY;AAAA;AAAA;AAAA;AAAA,UAIvB,SAAS,OAAO,YAAY;AAAA;AAAA;AAAA;AAAA,UAI5B,WAAW,MAAM,OAAO,YAAY,YAAY,GAAG,CAAC;AAAA,UACpD,mBAAmB,MAAM,OAAO,YAAY,UAAU,EAAE,QAAQ,EAAE,CAAC;AAAA,UACnE,aAAa,MAAM,OAAO,YAAY,UAAU,EAAE,QAAQ,EAAE,CAAC;AAAA,UAC7D,WAAW,MAAM,OAAO,YAAY,aAAa,EAAE,QAAQ,EAAE,CAAC;AAAA,UAC9D,WAAW,MAAM,OAAO,YAAY,aAAa,EAAE,QAAQ,EAAE,CAAC;AAAA;AAAA;AAAA;AAAA,UAI9D,mBAAmB,OAAO,YAAY;AAAA,UACtC,iBAAiB,OAAO,YAAY;AAAA,UACpC,uBAAuB,OAAO,YAAY;AAAA,QAC5C,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AiC5HA;AAAA,SAAS,cAAc;;;ACAvB;AAAA,SAAS,OAAAC,YAAW;AAEpB,IAAM,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6Cb,IAAM,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaZ,IAAM,eAAeC;AAAA;AAAA;AAAA,MAGtB;AAAA,MACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD1CE,qBAAAC,WACE,OAAAC,OADF,QAAAC,cAAA;AAPD,IAAM,cAAc,aAAqC,CAAC,WAAW;AAC1E,SAAO,QAAQ;AACf,SAAO;AAAA,IACL,MAAM;AAAA,IACN,QAAQ,CAAC;AAAA,IACT,gBAAgB,CAAC,EAAE,YAAY,UAAAC,UAAS,MAAM;AAC5C,aACE,gBAAAD,OAAAF,WAAA,EACE;AAAA,wBAAAC,MAAC,UAAO,QAAQ,cAAc;AAAA,QAC9B,gBAAAA,MAACE,WAAA,EAAU,GAAG,YAAY;AAAA,SAC5B;AAAA,IAEJ;AAAA,IACA,eAAe,CAAC;AAAA,EAClB;AACF,CAAC;;;AE9BD;;;ACAA;AAAA,SAAS,QAAAC,cAAY;AACrB,SAAS,eAAAC,eAAa,UAAAC,gBAAc;AACpC,SAAS,UAAAC,UAAQ,cAAAC,oBAAkB;AACnC,SAAS,eAAAC,eAAa,YAAY,kBAAAC,wBAAsB;;;ACHxD;;;ACAA;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAS,eAAAC,eAAa,UAAAC,SAAQ,YAAAC,iBAAgB;AAC9C,SAAS,eAAAC,eAAa,kBAAAC,wBAAsB;;;ACF5C;AAAA,OAAOC,cAAY;AAIZ,IAAM,eAAeC,SAAO,MAAM;AAAA;AAAA;AAGlC,IAAM,mBAAmBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAMrC,IAAM,uBAAuBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADqC5C,qBAAAC,WACE,OAAAC,OADF,QAAAC,cAAA;AArCJ,SAASC,aAAY,MAAwB;AAC3C,SAAO,CAAC,GAAG,MAAM,IAAI,EAAE,KAAK,CAAC;AAC/B;AAEO,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AACF,GAGG;AACD,QAAM,CAAC,OAAO,QAAQ,IAAIC,UAAS,EAAE,GAAG,GAAG,GAAG,EAAE,CAAC;AACjD,QAAM,SAASC,iBAAe;AAC9B,QAAM,MAAMC,QAAuB,IAAI;AACvC,QAAM,QAAQ,sBAAsB,EAAE,KAAK,KAAK,KAAK,GAAG,CAAC,EAAE,MAAAC,MAAK,MAAM;AACpE,WAAO,EAAE,MAAMA,MAAK,OAAO,GAAG,KAAKA,MAAK,MAAMA,MAAK,OAAO;AAAA,EAC5D,CAAC;AACD,QAAM,OAAOJ,aAAY,CAAC,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC;AAC5C,QAAM,OAAOA,aAAY,CAAC,EAAE,IAAI,CAAC,MAAM,IAAI,CAAC;AAE5C,QAAM,YAAYK;AAAA,IAChB,CAAC,GAAW,MAAc;AACxB,eAAS,EAAE,GAAG,EAAE,CAAC;AAAA,IACnB;AAAA,IACA,CAAC,QAAQ;AAAA,EACX;AAEA,QAAMC,eAAcD;AAAA,IAClB,CAAC,GAAW,MAAc;AACxB,aAAO,YAAY,YAAY,GAAG,CAAC;AACnC,MAAAE,cAAY,MAAM,MAAM;AACxB,YAAM;AAAA,IACR;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,SACE,gBAAAR,OAAAF,WAAA,EACE;AAAA,oBAAAC,MAAC,aAAU,OAAc;AAAA,IACzB,gBAAAA,MAAC,gBAAa,KAAU,OACtB,0BAAAA,MAAC,oBAAiB,cAAc,MAAM,UAAU,GAAG,CAAC,GACjD,eAAK,IAAI,CAAC,MAAM;AACf,aAAO,KAAK,IAAI,CAAC,MAAM;AACrB,cAAM,WAAW,KAAK,MAAM,KAAK,KAAK,MAAM;AAC5C,eACE,gBAAAA;AAAA,UAAC;AAAA;AAAA,YACC,WAAWU,MAAK,EAAE,cAAc,SAAS,CAAC;AAAA,YAE1C,cAAc,MAAM,UAAU,GAAG,CAAC;AAAA,YAClC,SAAS,MAAMF,aAAY,GAAG,CAAC;AAAA;AAAA,UAF1B,GAAG,KAAK;AAAA,QAGf;AAAA,MAEJ,CAAC;AAAA,IACH,CAAC,GACH,GACF;AAAA,KACF;AAEJ;;;AEvEA;AAAA,OAAOG,eAAc;AACrB,SAAS,aAAAC,YAAW,UAAAC,UAAQ,YAAAC,iBAAgB;AAC5C,SAAS,kBAAAC,wBAAsB;;;ACF/B;;;ACAA;;;ACAA;AAII,gBAAAC,OA+CF,QAAAC,cA/CE;AAFG,IAAM,IAAI,MACf,gBAAAD,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,uDAAsD,GAChE;AAGK,IAAM,OAAO,MAClB,gBAAAA,MAAC,cAAW,WAAU,eAAc,OAAM,SAAQ,SAAQ,aACxD,0BAAAA,MAAC,UAAK,GAAE,iBAAgB,GAC1B;AAGK,IAAM,WAAW,MACtB,gBAAAA,MAAC,cAAW,OAAM,SAAQ,SAAQ,aAChC,0BAAAA,MAAC,UAAK,GAAE,kBAAiB,GAC3B;AAGK,IAAM,KAAK,MAChB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,oEAAmE,GAC7E;AAGK,IAAM,KAAK,MAChB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,mHAAkH,GAC5H;AAGK,IAAM,KAAK,MAChB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,8FAA6F,GACvG;AAGK,IAAM,KAAK,MAChB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,sEAAqE,GAC/E;AAGK,IAAM,KAAK,MAChB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,oFAAmF,GAC7F;AAGK,IAAM,KAAK,MAChB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAE,uCAAsC;AAAA,EAC9C,gBAAAA,MAAC,UAAK,GAAE,4EAA2E;AAAA,GACrF;AAGK,IAAME,aAAY,MACvB,gBAAAF,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,+BAA8B,GACxC;AAGK,IAAM,OAAO,MAClB,gBAAAA,MAAC,cAEC,0BAAAA,MAAC,UAAK,GAAE,8DAA6D,GACvE;AAGK,IAAM,SAAS,MACpB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,6BAA4B,GACtC;AAGK,IAAM,QAAQ,MACnB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,8DAA6D,GACvE;AAGK,IAAM,OAAO,MAClB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAE,wDAAuD;AAAA,EAC/D,gBAAAA,MAAC,UAAK,GAAE,yDAAwD;AAAA,GAClE;AAOK,IAAM,aAAa,MACxB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,gHAA+G,GACzH;AAGK,IAAM,QAAQ,MACnB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,qKAAoK,GAC9K;AAGK,IAAM,WAAW,MACtB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,qMAAoM,GAC9M;AAOK,IAAM,aAAa,MACxB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,qDAAoD,GAC9D;AAOK,IAAMG,SAAQ,MACnB,gBAAAF,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAG,GAAG,GAAG,GAAG,OAAO,IAAI,QAAQ,IAAI,IAAI,GAAG;AAAA,EAChD,gBAAAA,MAAC,UAAK,GAAE,oBAAmB;AAAA,GAC7B;AAOK,IAAM,OAAO,MAClB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,wCAAuC,GACjD;AAOK,IAAM,QAAQ,MACnB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAE,aAAY;AAAA,EACpB,gBAAAA,MAAC,UAAK,GAAG,GAAG,GAAG,GAAG,OAAO,IAAI,QAAQ,IAAI,IAAI,GAAG;AAAA,EAChD,gBAAAA,MAAC,UAAK,GAAE,+BAA8B;AAAA,EACtC,gBAAAA,MAAC,UAAK,GAAE,gCAA+B;AAAA,GACzC;AAGK,IAAM,aAAa,MACxB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,QAAO,QAAO,GAAE,iBAAgB;AAAA,EACtC,gBAAAA,MAAC,UAAK,GAAE,2BAA0B;AAAA,EAClC,gBAAAA,MAAC,UAAK,GAAE,iFAAgF;AAAA,GAC1F;AAGK,IAAM,aAAa,MACxB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,QAAO,QAAO,GAAE,iBAAgB;AAAA,EACtC,gBAAAA,MAAC,UAAK,GAAE,2BAA0B;AAAA,EAClC,gBAAAA,MAAC,UAAK,GAAE,0EAAyE;AAAA,EACjF,gBAAAA,MAAC,UAAK,GAAE,2BAA0B;AAAA,GACpC;AAGK,IAAM,UAAU,MACrB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,QAAO,QAAO,GAAE,iBAAgB;AAAA,EACtC,gBAAAA,MAAC,UAAK,GAAE,0EAAyE;AAAA,EACjF,gBAAAA,MAAC,UAAK,GAAE,8CAA6C;AAAA,EACrD,gBAAAA,MAAC,UAAK,GAAE,sEAAqE;AAAA,GAC/E;AAOK,IAAM,OAAO,MAClB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,oBAAmB,GAC7B;AAEK,IAAM,cAAc,MACzB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,2DAA0D,GACpE;AAGK,IAAM,YAAY,MACvB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,4DAA2D,GACrE;AAGK,IAAM,gBAAgB,MAC3B,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,gGAA+F,GACzG;AAGK,IAAM,eAAe,MAC1B,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAE,gEAA+D;AAAA,EACvE,gBAAAA,MAAC,UAAK,GAAE,uGAAsG;AAAA,GAChH;AAGK,IAAM,YAAY,MACvB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,UAAK,GAAE,iBAAgB;AAAA,EACxB,gBAAAA,MAAC,UAAK,GAAE,4DAA2D;AAAA,GACrE;AAGK,IAAM,cAAc,MACzB,gBAAAA,MAAC,cACC,0BAAAA,MAAC,UAAK,GAAE,kFAAiF,GAC3F;AAGK,IAAM,QAAQ,MACnB,gBAAAC,OAAC,cACC;AAAA,kBAAAD,MAAC,YAAO,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG;AAAA,EAC9B,gBAAAA,MAAC,UAAK,GAAE,gDAA+C;AAAA,GACzD;;;ADpOF,IAAM,aAA6B;AAAA,EACjC;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,QAAQ,eAAe,GAAG,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAWI;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW;AAClB,aAAO,qBAAqB,iBAAiB;AAAA,IAC/C;AAAA,EACF;AACF;AAEO,IAAM,oBAAkC;AAAA,EAC7C,MAAW;AAAA,EACX,OAAO;AAAA,EACP,MAAM;AAAA,EACN,UAAU;AACZ;;;AEzDA;;;ACAA;AAAA,OAAO,UAAU;AACjB,OAAO,YAAY;AACnB,OAAOC,cAAY;AACnB,SAAS,eAAAC,eAAa,UAAAC,eAAc;AACpC,SAAS,cAAAC,oBAAkB;AAC3B,SAAS,eAAAC,eAAa,kBAAAC,wBAAsB;AAuCxC,qBAAAC,WACE,OAAAC,OADF,QAAAC,cAAA;AAlCG,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AACF,GAGG;AACD,QAAM,SAASC,iBAAe;AAC9B,QAAM,MAAMC,QAAuB,IAAI;AACvC,QAAM,QAAQ;AAAA,IACZ,EAAE,KAAK,KAAK,KAAK;AAAA,IACjB,CAAC,EAAE,KAAK,MAAAC,MAAK,GAAG,aAAa;AAC3B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,UACE,MAAMA,MAAK;AAAA,UACX,KAAKA,MAAK,MAAMA,MAAK;AAAA,QACvB;AAAA,QACA,EAAE,QAAQ,GAAG;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAAgBC;AAAA,IACpB,CAAC,MAA0B;AACzB,MAAAC,aAAW,WAAW,QAAQ,EAAE,MAAM;AACtC,MAAAC,cAAY,MAAM,MAAM;AACxB,YAAM;AAAA,IACR;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,SACE,gBAAAN,OAAAF,WAAA,EACE;AAAA,oBAAAC,MAAC,aAAU,OAAc;AAAA,IACzB,gBAAAA,MAAC,gBAAa,KAAU,OACtB,0BAAAA,MAAC,UAAO,MAAY,eAA8B,WAAW,MAAM,GACrE;AAAA,KACF;AAEJ;AAEO,IAAM,eAAeQ,SAAO,MAAM;;;ACrDzC;AAAA,SAAS,UAAAC,gBAAc;AACvB,SAAS,kBAAAC,wBAAsB;;;ACD/B;AAAA,OAAOC,cAAY;AAEZ,IAAM,gBAAgBA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0BlC,IAAM,cAAcA,SAAO,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC5BvC;AAAA,OAAOC,cAAY;AAIZ,IAAM,cAAcC,SAAO,MAAM;AAAA;AAAA;AAAA;;;AFgDpC,qBAAAC,WACE,OAAAC,OASI,QAAAC,cAVN;AAzCG,SAAS,WAAW;AAAA,EACzB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAMG;AACD,QAAM,SAASC,iBAAe;AAC9B,QAAM,MAAMC,SAAuB,IAAI;AACvC,QAAM,QAAQ;AAAA,IACZ,EAAE,KAAK,KAAK,KAAK;AAAA,IACjB,CAAC,EAAE,KAAK,MAAAC,MAAK,GAAG,aAAa;AAC3B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,UACE,MAAMA,MAAK,OAAO;AAAA,UAClB,KAAKA,MAAK,MAAMA,MAAK;AAAA,QACvB;AAAA,QACA,EAAE,QAAQ,GAAG;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAEA,iBAAe,SAAS,GAAwC;AAC9D,QAAI,EAAE,OAAO,SAAS,QAAQ,EAAE,OAAO,MAAM,WAAW;AAAG;AAC3D,cAAU,CAAC;AACX,UAAM,EAAE,MAAM,IAAI,EAAE;AACpB,eAAW,QAAQ,OAAO;AACxB,aAAO,OAAO,OAAO,IAAI;AAAA,IAC3B;AACA,UAAM;AAAA,EACR;AAEA,SACE,gBAAAH,OAAAF,WAAA,EACE;AAAA,oBAAAC,MAAC,aAAU,OAAc;AAAA,IACzB,gBAAAC,OAAC,eAAY,KAAU,OACrB;AAAA,sBAAAA,OAAC,WACC;AAAA,wBAAAD;AAAA,UAAC;AAAA;AAAA,YACC,MAAK;AAAA,YACL,UAAQ;AAAA,YACR,OAAO,EAAE,SAAS,OAAO;AAAA,YACzB;AAAA;AAAA,QACF;AAAA,QACA,gBAAAC,OAAC,iBACE;AAAA;AAAA,UAED,gBAAAD,MAAC,UAAK,OAAO,EAAE,YAAY,QAAQ,GAAI,yBAAc;AAAA,WACvD;AAAA,SACF;AAAA,MACA,gBAAAA,MAAC,eAAa,sBAAW;AAAA,OAC3B;AAAA,KACF;AAEJ;AAEO,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA;AACF,GAGG;AACD,SACE,gBAAAA;AAAA,IAAC;AAAA;AAAA,MACC;AAAA,MACA;AAAA,MACA,MAAM,gBAAAA,MAAM,YAAL,EAAgB;AAAA,MACvB,eAAc;AAAA,MACd,YAAW;AAAA;AAAA,EACb;AAEJ;AAEO,SAAS,YAAY;AAAA,EAC1B;AAAA,EACA;AACF,GAGG;AACD,SACE,gBAAAA;AAAA,IAAC;AAAA;AAAA,MACC;AAAA,MACA;AAAA,MACA,MAAM,gBAAAA,MAAM,SAAL,EAAa;AAAA,MACpB,eAAc;AAAA,MACd,YAAW;AAAA;AAAA,EACb;AAEJ;;;AFrGO,IAAM,cAA8B;AAAA,EACzC;AAAA,IACE,MAAWK;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,WAAW;AAAA,EACb;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,WAAW;AAAA,IACX,MAAM,CAAC,WAAW,OAAO,QAAQ,qBAAqB;AAAA,EACxD;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,WAAW;AAAA,IACX,MAAM,CAAC,WAAW,OAAO,QAAQ,qBAAqB;AAAA,EACxD;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,WAAW;AAAA,EACb;AACF;AAEO,IAAM,sBAAsC;AAE5C,IAAM,qBAAqC;AAAA,EAChD;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AACF;;;AK7CA;;;ACAA;AAOA,SAAS,gBAAgB,UAA2B;AAClD,SAAO,CAAC,WACN,OAAO,UAAU,qBAAqB,QAAQ,KAC9C,OAAO,UAAU,gBAAgB,EAAE,SAAS,CAAC;AACjD;AAEO,IAAM,iBAAiC;AAAA,EAC5C;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,MAAM;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,MAAM;AAAA,EAChC;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,KAAK;AAAA,EAC/B;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,KAAK;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,YAAY;AAAA,EACtC;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ,gBAAgB,OAAO;AAAA,EACjC;AACF;;;AC9CA;AAIO,IAAM,YAA4B;AAAA,EACvC;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,KAAK,qBAAqB,KAAK;AAAA,EAC5D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,KAAK,mBAAmB,KAAK;AAAA,EAC1D;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,KAAK,gBAAgB,KAAK;AAAA,EACvD;AACF;;;ACvBA;AAIO,IAAM,aAA6B;AAAA,EACxC;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,iBAAiB,OAAO;AAAA,EACrD;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,iBAAiB,QAAQ;AAAA,EACtD;AACF;;;AHVO,IAAM,gBAAgC;AAAA,EAC3C;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AACF;;;AI1BA;;;ACAA;AAAA,SAAS,YAAAC,iBAAgB;AACzB;AAAA,EAGE,eAAAC;AAAA,EACA,UAAAC;AAAA,EACA,YAAAC;AAAA,OACK;AACP,SAAS,eAAAC,eAAa,kBAAAC,wBAAsB;AA8DxC,qBAAAC,YACE,OAAAC,OAUI,QAAAC,cAXN;AAjDJ,IAAM,UAAUC,UAAS,OAAO;AAEzB,SAASC,cAAa;AAAA,EAC3B;AAAA,EACA;AACF,GAGG;AACD,QAAM,SAASC,iBAAe;AAC9B,QAAM,MAAMC,SAAuB,IAAI;AACvC,QAAM,QAAQ;AAAA,IACZ,EAAE,KAAK,KAAK,KAAK;AAAA,IACjB,CAAC,EAAE,KAAK,MAAAC,MAAK,GAAG,aAAa;AAC3B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,UACE,MAAMA,MAAK,OAAO;AAAA,UAClB,KAAKA,MAAK,MAAMA,MAAK;AAAA,QACvB;AAAA,QACA,EAAE,QAAQ,GAAG;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAEA,QAAM,CAAC,KAAK,MAAM,IAAIC,UAAS,EAAE;AAEjC,QAAMC,cAAa,MAAM;AACvB,WAAO,OAAO,WAAW,KAAK,KAAK,EAAE,QAAQ,KAAK,CAAC;AACnD,IAAAC,cAAY,MAAM,MAAM;AACxB,UAAM;AAAA,EACR;AAEA,QAAM,gBAAgBC;AAAA,IACpB,CAAC,MAAqC;AACpC,aAAO,EAAE,cAAc,KAAK;AAAA,IAC9B;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,QAAM,YAAY,CAAC,MAAuC;AACxD,QAAI,CAAC,QAAQ,CAAC;AAAG;AACjB,MAAE,eAAe;AACjB,MAAE,gBAAgB;AAClB,IAAAF,YAAW;AAAA,EACb;AAEA,SACE,gBAAAP,OAAAF,YAAA,EACE;AAAA,oBAAAC,MAAC,aAAU,OAAc;AAAA,IACzB,gBAAAC,OAAC,iBAAc,KAAU,OACvB;AAAA,sBAAAA,OAAC,0BACC;AAAA,wBAAAD;AAAA,UAAC;AAAA;AAAA,YACC,MAAK;AAAA,YACL,OAAO;AAAA,YACP,WAAS;AAAA,YACT,UAAU;AAAA,YACV;AAAA;AAAA,QACF;AAAA,QACA,gBAAAC,OAAC,iBAAc,SAASO,aACtB;AAAA,0BAAAR,MAAM,MAAL,EAAU;AAAA,UACX,gBAAAA,MAAM,UAAL,EAAc;AAAA,WACjB;AAAA,SACF;AAAA,MACA,gBAAAA,MAAC,eAAY,+BAAiB;AAAA,OAChC;AAAA,KACF;AAEJ;;;ADrFO,IAAM,WAAyB;AAAA,EACpC,MAAW;AAAA,EACX,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,WAAWW;AACb;;;AEXA;AAIA,IAAM,mBAAmC;AAAA,EACvC;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,YAAY,WAAW;AAAA,EACpD;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,YAAY,aAAa;AAAA,EACtD;AACF;AAEA,IAAM,qBAAqC;AAAA,EACzC;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,YAAY,UAAU;AAAA,EACnD;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,YAAY,UAAU;AAAA,EACnD;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,YAAY,aAAa;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ,CAAC,WAAW,OAAO,WAAW,iBAAiB;AAAA,EACzD;AAAA,EACA;AAAA,EACA;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA;AAAA;AAAA;AAAA,IAIR,QAAQ,CAAC,WAAW,OAAO,YAAY,YAAY;AAAA,EACrD;AACF;AAEO,IAAM,oBAAoC;AAAA,EAC/C,GAAG;AAAA,EACH;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,EACZ;AACF;AAEO,IAAM,mBAAmC;AAAA,EAC9C;AAAA,IACE,MAAW;AAAA,IACX,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU,CAAC,GAAG,kBAAkB,WAAW,GAAG,kBAAkB;AAAA,EAClE;AACF;;;AdzDO,IAAM,aAA6B;AAAA,EACxC;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA,GAAG;AACL;AAEO,IAAM,cAA8B;AAAA,EACzC;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA,GAAG;AACL;AAEO,IAAM,aAA6B;AAAA,EACxC;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA;AAAA,EACA,GAAG;AAAA,EACH;AAAA,EACA,GAAG;AACL;AAEO,IAAM,eAA+B,CAAC,mBAAmB,SAAS;AAIlE,IAAM,WAA6B,CAAC,YAAY,aAAa,UAAU;;;AevD9E;AAAA,SAAS,QAAAC,aAAY;AACrB,SAAqB,eAAAC,eAAa,UAAAC,gBAAc;AAChD,SAAS,eAAAC,eAAa,kBAAAC,wBAAsB;AA+BpC,gBAAAC,OAqCJ,QAAAC,cArCI;AAtBD,SAAS,cAAc;AAAA,EAC5B;AAAA,EACA;AACF,GAGG;AACD,QAAM,SAASC,iBAAe;AAC9B,QAAM,MAAMC,SAAuB,IAAI;AACvC,QAAM,UAAU,WAAW;AAAA,IACzB,OAAO,KAAK;AAAA,IACZ,QAAQ,MAAO,KAAK,SAAS,aAAa,KAAK,MAAM,IAAI;AAAA,EAC3D,CAAC;AACD,QAAM,YAAY,SAAS,MAAM;AAEjC,QAAM,WAAWC,cAAY,MAAM;AACjC,UAAM,OAAO,IAAI;AACjB,UAAM,QAAQ,KAAK;AACnB,UAAM,YAAY,KAAK;AACvB,QAAI,CAAC;AAAM;AACX,QAAI,OAAO;AACT,gBAAU,KAAK,MACb,gBAAAJ,MAAC,QAAK,MAAY,OAAc,OAAO,UAAU,OAAO,CACzD;AAAA,IACH,WAAW,WAAW;AACpB,gBAAU,KAAK,MAAM,gBAAAA,MAAC,aAAU,MAAY,OAAO,UAAU,OAAO,CAAE;AAAA,IACxE;AAAA,EACF,GAAG,CAAC,IAAI,CAAC;AAET,QAAM,UAAUI,cAAY,MAAM;AAChC,QAAI,KAAK,QAAQ;AACf,WAAK,OAAO,MAAM;AAClB,MAAAC,cAAY,MAAM,MAAM;AACxB;AAAA,IACF;AACA,QAAI,UAAU,OAAO;AACnB,gBAAU,MAAM;AAAA,IAClB,OAAO;AACL,eAAS;AAAA,IACX;AAAA,EACF,GAAG,CAAC,UAAU,OAAO,IAAI,CAAC;AAK1B,QAAM,eAAeD;AAAA,IACnB,CAAC,MAA+B;AAC9B,cAAQ,aAAa,CAAC;AAMtB,UAAI,UAAU;AAAO,iBAAS;AAAA,IAChC;AAAA,IACA,CAAC,UAAU,KAAK;AAAA,EAClB;AAEA,SACE,gBAAAH;AAAA,IAAC;AAAA;AAAA,MACC,kBAAe;AAAA,MACf;AAAA,MACA;AAAA,MACA,cAAc,QAAQ;AAAA,MACtB;AAAA,MACA,WAAWK,MAAK,EAAE,YAAY,QAAQ,UAAU,KAAK,KAAK,CAAC;AAAA,MAE3D;AAAA,wBAAAN,MAAC,KAAK,MAAL,EAAU;AAAA,QACV,KAAK,OAAO,gBAAAA,MAAM,MAAL,EAAU,IAAK;AAAA;AAAA;AAAA,EAC/B;AAEJ;;;AhB5DQ,gBAAAO,aAAA;AALR,SAAS,YAAY,EAAE,KAAK,GAA2B;AACrD,QAAM,SAASC,iBAAe;AAC9B,MAAI,SAAS,WAAW;AACtB,WACE,gBAAAD,MAAC,4BAAyB,kBAAe,WACvC,0BAAAA,MAAC,mBAAgB,GACnB;AAAA,EAEJ;AACA,QAAM,OAAO,KAAK,SAAS,SAAY,OAAO,KAAK,KAAK,MAAM;AAC9D,MAAI,CAAC;AAAM,WAAO;AAClB,SAAO,gBAAAA,MAAC,iBAAc,MAAY;AACpC;AAMA,SAAS,UAAU,SAAyB;AAC1C,QAAM,SAAS,QAAQ;AAAA,IACrB;AAAA,EACF;AACA,QAAM,UAAU,QAAQ;AAAA,IACtB;AAAA,EACF;AACA,MAAI,CAAC,UAAU,CAAC;AAAS,UAAM,IAAI,MAAM,6BAA6B;AACtE,SAAO;AAAA,IACL,SAAS,QAAQ;AAAA,IACjB,QAAQ,OAAO;AAAA,IACf,SAAS,QAAQ;AAAA,EACnB;AACF;AAMA,SAAS,oBACP,OACA,aACA,cACQ;AACR,MAAI,QAAQ;AACZ,aAAW,QAAQ,OAAO;AACxB,aAAS,SAAS,YAAY,eAAe;AAAA,EAC/C;AACA,SAAO;AACT;AAEO,SAAS,UAAU;AACxB,QAAM,MAAME,SAAuB,IAAI;AACvC,QAAM,CAAC,OAAO,QAAQ,IAAIC,UAAyB,YAAY;AAC/D,EAAAC,WAAU,MAAM;AACd,UAAM,UAAUC;AAAA,MACd,MAAM;AACJ,cAAM,UAAU,IAAI;AACpB,YAAI,CAAC;AAAS,gBAAM,IAAI,MAAM,mBAAmB;AACjD,cAAM,SAAS,UAAU,OAAO;AAKhC,iBAAS,IAAI,GAAG,IAAI,SAAS,SAAS,GAAG,KAAK;AAC5C,gBAAM,eAAe;AAAA,YACnB,SAAS,CAAC;AAAA,YACV,OAAO;AAAA,YACP,OAAO;AAAA,UACT;AACA,cAAI,eAAe,OAAO,SAAS;AACjC,qBAAS,SAAS,CAAC,CAAC;AACpB;AAAA,UACF;AAAA,QACF;AACA,iBAAS,SAAS,SAAS,SAAS,CAAC,CAAC;AAAA,MACxC;AAAA,MACA;AAAA,MACA,EAAE,UAAU,KAAK;AAAA,IACnB;AACA,YAAQ;AACR,WAAO,iBAAiB,UAAU,OAAO;AACzC,WAAO,MAAM;AACX,aAAO,oBAAoB,UAAU,OAAO;AAAA,IAC9C;AAAA,EACF,GAAG,CAAC,CAAC;AACL,SACE,gBAAAL,MAAC,qBAAkB,KACjB,0BAAAA,MAAC,YACE,gBAAM,IAAI,CAAC,MAAMM,WAChB,gBAAAN;AAAA,IAAC;AAAA;AAAA,MAEC;AAAA;AAAA,IADK,OAAO,SAAS,WAAWM,SAAQ,KAAK;AAAA,EAE/C,CACD,GACH,GACF;AAEJ;;;AJnDM,SAUE,OAAAC,OAVF,QAAAC,cAAA;AAnDC,SAAS,eAAe,EAAE,YAAY,UAAAC,UAAS,GAAwB;AAC5E,QAAM,oBAAoBC,SAAuB,IAAI;AAErD,QAAM,SAASC,iBAAe;AAC9B,QAAM,UAAU,WAAW;AAO3B,QAAM,wBAAwBC;AAAA,IAC5B,CAAC,MAAwC;AAOvC,UAAI,EAAE,WAAW,EAAE;AAAe;AAIlC,MAAAC,aAAW,OAAO,QAAQC,SAAO,IAAI,QAAQ,CAAC,CAAC,CAAC;AAChD,MAAAC,cAAY,MAAM,MAAM;AAAA,IAC1B;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAsBA,SACE,gBAAAR,MAAC,UACC,0BAAAC;AAAA,IAAC;AAAA;AAAA,MACC,KAAK;AAAA,MACL,WAAWQ,OAAK,EAAE,aAAa,QAAQ,CAAC;AAAA,MACxC,OAAO;AAAA,QACL,QAAQ,OAAO,QAAQ;AAAA,QACvB,WAAW,OAAO,QAAQ;AAAA,QAC1B,WAAW,OAAO,QAAQ;AAAA,MAC5B;AAAA,MACA,SAAS;AAAA,MAET;AAAA,wBAAAT,MAAC,WAAQ;AAAA,QACT,gBAAAA;AAAA,UAACE;AAAA,UAAA;AAAA,YACC,IAAI;AAAA,YACH,GAAG;AAAA,YACJ,OAAO,EAAE,WAAW,OAAO;AAAA;AAAA,QAC7B;AAAA;AAAA;AAAA,EACF,GACF;AAEJ;;;ADrDO,IAAM,gBAAgB;AAAA,EAC3B,CAAC,QAAQ,YAAY;AACnB,WAAO,UAAU;AAAA,MACf,QAAQ,QAAQ,SAAS;AAAA,MACzB,WAAW,QAAQ,SAAS;AAAA,MAC5B,WAAW,QAAQ,SAAS;AAAA,MAC5B,mBAAmB,QAAQ,SAAS,qBAAqB;AAAA,IAC3D;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,CAAC;AAAA,MACT;AAAA,MACA,eAAe,CAAC;AAAA,IAClB;AAAA,EACF;AACF;;;AsB3CA;AAAA,SAAS,UAAAQ,UAAiB,QAAAC,QAAM,QAAAC,QAAM,cAAAC,oBAAkB;AASjD,IAAM,sBAAsB;AAAA,EACjC,CAAC,WAAW;AACV,WAAO,qBAAqB;AAC5B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ;AAAA,QACN,eAAe,CAAC,UAAU;AACxB,cAAI,CAACC,SAAO,SAAS,MAAM,CAAC,CAAC;AAAG,mBAAO;AACvC,gBAAM,WAAW,CAAC,OAAO,SAAS,SAAS,CAAC;AAK5C,gBAAM,cAAcC,OAAK;AAAA,YACvB;AAAA,YACA,OAAO,SAAS,SAAS;AAAA,UAC3B;AAUA,cACED,SAAO,UAAU,QAAQ,WAAW,KACpCA,SAAO,OAAO,QAAQ,WAAW,GACjC;AACA,YAAAE,aAAW;AAAA,cACT;AAAA,cACA,EAAE,MAAM,aAAa,UAAU,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE;AAAA,cAC9C;AAAA,gBACE,IAAIC,OAAK,KAAK,QAAQ;AAAA,cACxB;AAAA,YACF;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;ACpDA;AAAA,SAAiB,oBAAoB;;;ACArC;;;ACAA;AAAA;AAAA,EAEE,UAAAC;AAAA,EACA,WAAAC;AAAA,EAEA,cAAAC;AAAA,OACK;AAQP,SAAS,cAAc,SAAiC;AACtD,QAAM,YAAY,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC;AACxD,SAAO,UAAU,WAAW,UAAU,WAAW,SAAS,CAAC;AAC7D;AAKA,SAAS,iBAAiB,SAAoC;AAC5D,QAAM,SAAS,cAAc,OAAO;AACpC,MAAI,OAAO,SAAS;AAClB,UAAM,IAAI,MAAM,oCAAoC,OAAO,OAAO;AACpE,SAAO;AACT;AAYO,SAAS,wBAId,QACA,MACA,MACA;AACA,QAAMC,QAAO,OAAO,KAAK,IAAI;AAC7B,QAAMC,OAAMD,MAAK,CAAC;AAClB,QAAM,YAAY,KAAKC,IAAG;AAW1B,QAAM,EAAE,MAAM,IAAI,OAAO;AACzB,aAAW,QAAQ,OAAO;AACxB,eAAW,MAAM,KAAK,YAAY;AAChC,WACG,GAAG,SAAS,iBAAiB,GAAG,SAAS,kBACzC,GAAG,KAAWA,IAAG,MAAM,WACxB;AACA,WAAG,OAAO,EAAE,GAAG,GAAG,MAAM,GAAG,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc;AAAA,IAClB,GAAGJ,SAAO,MAAM,QAAQ;AAAA,MACtB,MAAM;AAAA,MACN,IAAI,CAAC;AAAA,MACL,OAAO,CAAC,MACNC,UAAQ,UAAU,CAAC;AAAA;AAAA;AAAA;AAAA,MAKlB,EAAQG,IAAG,MAAM;AAAA,IACtB,CAAC;AAAA,EACH;AAOA,aAAW,aAAa,aAAa;AACnC,IAAAF,aAAW,SAAS,QAAQ,MAAM,EAAE,IAAI,UAAU,CAAC,EAAE,CAAC;AACtD,UAAM,gBAAgB,iBAAiB,OAAO,OAAO;AACrD,kBAAc,aAAa;AAAA,EAC7B;AACF;;;AChGA;AAAA,SAAS,kBAAkB;AAC3B,SAAS,cAAc;AAQhB,SAAS,OAAO,QAAgB,MAAY;AACjD,QAAM,EAAE,OAAO,IAAI,OAAO;AAC1B,MAAI,WAAW;AAKb,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAOF,QAAM,UAAU,IAAI,OAAO;AAC3B,QAAM,YAAY,IAAI,gBAAgB,IAAI;AAC1C,aAAW;AAAA,IACT;AAAA,IACA;AAAA,IACA,eAAe,CAAC,EAAE,WAAW,MAAM;AACjC,gBAAU,QAAQ,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,KAAK;AAAA,QACL,WAAW;AAAA,QACX,YAAY,WAAW;AAAA,MACzB,CAAC;AAID,UAAI,WAAW,SAAS,SAAS;AAC/B,YACE,OAAO,OAAO,kBAAkB;AAAA,UAC9B;AAAA,UACA;AAAA,UACA,OAAO,WAAW;AAAA,UAClB,QAAQ,WAAW;AAAA,QACrB,CAAC;AAED,iBAAO;AAAA,MACX;AAKA,UAAI,OAAO,OAAO,aAAa,EAAE,SAAS,KAAK,CAAC;AAAG,eAAO;AAC1D,aAAO;AAAA,IACT;AAAA,IACA,YAAY,CAAC,EAAE,WAAW,WAAW,MAAM;AACzC,gBAAU,QAAQ,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IACA,SAAS,CAAC,MAAM;AACd,gBAAU,QAAQ,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,KAAK;AAAA,QACL,SAAS,EAAE;AAAA,MACb,CAAC;AAAA,IACH;AAAA,IACA,WAAW,CAAC,MAAM;AAChB,gBAAU,QAAQ,SAAS;AAAA,QACzB,QAAQ;AAAA,QACR,KAAK,EAAE,WAAW;AAAA,MACpB,CAAC;AACD,UAAI,EAAE,WAAW,SAAS,SAAS;AACjC,YACE,OAAO,OAAO,yBAAyB;AAAA,UACrC;AAAA,UACA;AAAA,UACA,OAAO,EAAE,WAAW;AAAA,UACpB,QAAQ,EAAE,WAAW;AAAA,UACrB,KAAK,EAAE,WAAW;AAAA,QACpB,CAAC;AAED,iBAAO;AAAA,MACX;AACA,aAAO,OAAO,oBAAoB;AAAA,QAChC;AAAA,QACA;AAAA,QACA,KAAK,EAAE,WAAW;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACD,SAAO;AACT;;;AF1FO,SAAS,oBAAoB,QAAgB;AAClD,SAAO;AAAA,IACL,QAAQ,SAAS,QAAQ,MAAM;AAAA,IAC/B,yBAAyB,CACvB,MACA,SACG,wBAAwB,QAAQ,MAAM,IAAI;AAAA,EACjD;AACF;;;ADkBO,IAAM;AAAA;AAAA,EACX,aAAsC,CAAC,QAAQ,YAAY;AACzD,UAAM,YAAY,QAAQ,QAAQ;AAClC,QAAI,CAAC,WAAW;AACd,cAAQ,KAAK,8CAA8C;AAAA,IAC7D;AACA,UAAM,SAAS,YAAY,aAAa,EAAE,UAAU,CAAC,IAAI;AACzD,WAAO,SAAS;AAAA,MACd;AAAA,MACA,mBAAmB,MAAM;AACvB,gBAAQ,IAAI,0BAA0B;AACtC,eAAO;AAAA,MACT;AAAA,MACA,cAAc,MAAM;AAClB,gBAAQ,IAAI,qBAAqB;AACjC,eAAO;AAAA,MACT;AAAA,MACA,0BAA0B,MAAM;AAC9B,gBAAQ,IAAI,iCAAiC;AAC7C,eAAO;AAAA,MACT;AAAA,MACA,qBAAqB,MAAM;AACzB,gBAAQ,IAAI,4BAA4B;AACxC,eAAO;AAAA,MACT;AAAA,MACA,gBAAgB,kBAAkB;AAAA,MAClC,GAAG,oBAAoB,MAAM;AAAA,IAC/B;AAEA,UAAM,gBAAgB,YAClB;AAAA,MACE,QAAQ,GAAyB;AAC/B,cAAM,QAAQ,EAAE,YAAY,eAAe;AAC3C,YAAI,CAAC,SAAS,MAAM,WAAW;AAAG,iBAAO;AACzC,mBAAW,QAAQ,OAAO;AACxB,iBAAO,OAAO,OAAO,IAAI;AAAA,QAC3B;AACA,eAAO;AAAA,MACT;AAAA,MACA,OAAO,GAAoB;AACzB,cAAM,QAAQ,EAAE,YAAY,cAAc;AAC1C,YAAI,CAAC,SAAS,MAAM,WAAW;AAAG,iBAAO;AACzC,mBAAW,QAAQ,OAAO;AACxB,iBAAO,OAAO,OAAO,IAAI;AAAA,QAC3B;AACA,eAAO;AAAA,MACT;AAAA,IACF,IACA,CAAC;AACL,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,CAAC;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AAAA;;;AIxFH;AAAA,SAAS,UAAAG,UAAQ,cAAAC,oBAAkB;AACnC,SAAS,eAAAC,qBAAmB;AAgBrB,IAAM,mBAAmB;AAAA,EAC9B,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,aAAa,CAAC;AACrB,WAAO,OAAO,eAAe,CAAC,EAAE,SAAS,KAAK,MAAM;AAClD,YAAM,EAAE,UAAU,IAAI;AACtB,MAAAC,aAAW,WAAW,QAAQ,YAAK;AACnC,MAAAA,aAAW,YAAY,QAAQ;AAAA,QAC7B,MAAM;AAAA,QACN,MAAM;AAAA,QACN,UAAU,CAAC,EAAE,MAAM,KAAK,KAAK,CAAC;AAAA,MAChC,CAAC;AAQD,UAAI,CAAC,WAAW;AACd,cAAM,UAAUC,SAAO,IAAI,QAAQ,CAAC,CAAC;AACrC,QAAAD,aAAW,OAAO,QAAQ,OAAO;AACjC,QAAAE,cAAY,MAAM,MAAM;AAAA,MAC1B;AAIA,MAAAF,aAAW,KAAK,QAAQ,EAAE,UAAU,GAAG,MAAM,SAAS,CAAC;AACvD,aAAO;AAAA,IACT;AAEA,WAAO,OAAO,sBAAsB,CAAC,MAAM;AACzC,aAAO,OAAO;AAAA,QACZ,EAAE,MAAM,EAAE,QAAQ;AAAA,QAClB,EAAE,MAAM,EAAE,IAAI;AAAA,MAChB;AACA,aAAO;AAAA,IACT;AAEA,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,IACR,CAAC;AAAA,EACH;AACF;;;AC3DA;;;ACAA;AAAA,SAAiB,cAAAG,oBAAkB;AAMnC,SAAS,cAAc,QAAgB,UAAkB;AACvD,QAAM,WAAWC,OAAM,QAAQ;AAC/B,EAAAC,aAAW,YAAY,QAAQ,QAAQ;AACzC;AAEO,SAAS,2BAA2B,QAAgB;AACzD,SAAO;AAAA,IACL,eAAe,SAAS,eAAe,MAAM;AAAA,EAC/C;AACF;;;ADAO,IAAM,sBAAsB;AAAA,EACjC,CAAC,WAAW;AACV,WAAO,gBAAgB,2BAA2B,MAAM;AACxD,WAAO;AAAA,MACL,MAAM;AAAA,MACN,QAAQ,CAAC;AAAA,MACT,eAAe;AAAA,QACb,QAAQ,GAAG;AACT,gBAAM,EAAE,MAAM,IAAI,EAAE;AACpB,cAAI,MAAM,WAAW,KAAK,MAAM,CAAC,MAAM,cAAc;AACnD,mBAAO;AAAA,UACT;AACA,gBAAM,WAAW,EAAE,cAAc,QAAQ,YAAY;AACrD,iBAAO,cAAc,cAAc,QAAQ;AAC3C,oBAAU,CAAC;AACX,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AEnCA;AA4BS,gBAAAC,aAAA;AATT,SAAS,kBAAkB,OAA+B;AACxD,QAAM,iBAAuD;AAAA,IAC3D,GAAG,MAAM;AAAA,IACT,OAAO;AAAA,MACL,GAAG,MAAM,WAAW;AAAA,MACpB,OAAO;AAAA,MACP,UAAU;AAAA,IACZ;AAAA,EACF;AACA,SAAO,gBAAAA,MAAC,UAAM,GAAG,gBAAiB,gBAAM,UAAS;AACnD;AAEO,IAAM,oBAAoB;AAAA,EAC/B,CAAC,QAAQ,SAAS,EAAE,aAAa,MAAM;AACrC,WAAO,cAAc,CAAC;AACtB,WAAO,aAAa;AAAA,MAClB,MAAM;AAAA,MACN,eAAe;AAAA,QACb;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACF;;;AxNZO,IAAM,UAAU;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;;;A3D/CA,IAAM,OAAO,WAAwB,OAAO;AAE5C,IAAM,EAAE,UAAU,cAAAC,cAAa,IAAI;;;AoRNnC;AAAA,SAAS,YAAAC,kBAAgB;AACzB,SAAS,cAAc,UAAAC,UAAQ,cAAAC,oBAAkB;AACjD,SAAS,mBAAmB;AAC5B,SAAsB,iBAAiB;AAOhC,SAAS,UAAU;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAK0C;AACxC,QAAM,CAAC,MAAM,IAAIC,WAAS,MAAM;AAC9B,UAAMC,UAAS,aAAa;AAC5B,UAAM,aAAa,SAAS,UAAU,YAAYA,OAAM,CAAC,GAAG;AAAA,MAC1D,QAAQ,EAAE,UAAU;AAAA,MACpB,OAAO,CAAC;AAAA,MACR,SAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA;AAAA,QAIA,mBAAmB,CAAC,CAAC;AAAA,MACvB;AAAA,IACF,CAAC;AACD,eAAW,eAAe,sBAAsB,WAAW;AAC3D,IAAAA,QAAO,WAAW;AAAA;AAAA;AAAA,IAGlB;AACA,IAAAA,QAAO,cAAc,MAAM;AACzB,aAAOC,WAAUD,QAAO,QAAqB;AAAA,IAC/C;AACA,IAAAA,QAAO,cAAc,CAAC,aAAqB;AACzC,YAAM,gBAAgBE,OAAM,QAAQ;AACpC,MAAAF,QAAO,WAAW;AAClB,MAAAA,QAAO,YAAY;AACnB,MAAAG,aAAW,OAAOH,SAAQI,SAAO,MAAMJ,SAAQ,CAAC,CAAC,CAAC,CAAC;AAAA,IACrD;AACA,WAAO;AAAA,EACT,CAAC;AAED,SAAO;AACT;;;A/c1CS,gBAAAK,aAAA;AADT,SAAS,WAAW,EAAE,UAAU,WAAW,GAAoB;AAC7D,SAAO,gBAAAA,MAAC,UAAM,GAAG,YAAa,UAAS;AACzC;AAaO,SAASC,UAAS;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAe;AAAA,EACf;AAAA,EACA;AAAA,EACA;AACF,GAAkB;AAChB,QAAM,sBAAsBC,SAAO,KAAK;AAMxC,QAAM,kBAAkBA,SAAqB;AAO7C,QAAM,eAAeA,SAAqB;AAoB1C,QAAM,yBAAyBC;AAAA,IAC7BC;AAAA,MACE,MAAM;AACJ,cAAM,WAAWC,WAAU,OAAO,QAAqB;AACvD,eAAO,SAAS,YAAY;AAAA,UAC1B;AAAA,UACA,UAAU,OAAO;AAAA,QACnB;AACA,iBAAS,QAAQ;AAAA,MACnB;AAAA,MACA;AAAA,MACA,EAAE,SAAS,OAAO,UAAU,KAAK;AAAA,IACnC;AAAA,IACA,CAAC,QAAQ,UAAU,YAAY;AAAA,EACjC;AAUA,QAAM,gBAAgBF,cAAY,MAAM;AACtC,QAAI,aAAa,YAAY,OAAO,UAAU;AAC5C;AAAA,IACF;AACA,iBAAa,UAAU,OAAO;AAC9B,2BAAuB;AAAA,EACzB,GAAG,CAAC,sBAAsB,CAAC;AAe3B,MAAI,OAAO,SAAS,aAAa,QAAQ,gBAAgB,WAAW,MAAM;AACxE,wBAAoB,UAAU;AAC9B,UAAM,WAAWG,OAAM,KAAK;AAC5B,iBAAa,UAAU,gBAAgB,UAAU;AACjD,WAAO,SAAS,YAAY;AAAA,MAC1B,UAAU;AAAA,MACV;AAAA,IACF;AAAA,EACF,OAAO;AAUL,QAAI,UAAU,OAAO,SAAS,UAAU,UAAU;AAChD,0BAAoB,UAAU;AAC9B,YAAM,gBAAgBA,OAAM,KAAK;AACjC,aAAO,WAAW;AAClB,aAAO,YAAY;AACnB,MAAAC,aAAW,OAAO,QAAQC,SAAO,MAAM,QAAQ,CAAC,CAAC,CAAC,CAAC;AAAA,IACrD;AAAA,EACF;AAEA,QAAM,2BAA2BL,cAAY,MAAM;AAMjD,QAAI,UAAU,UAAU,YAAY,EAAE,SAAS,SAAS,GAAG;AACzD,MAAAM,cAAY,MAAM,MAAM;AAAA,IAC1B;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAMX,QAAM,SAASN,cAAY,MAAM;AAC/B,2BAAuB,MAAM;AAAA,EAC/B,GAAG,CAAC,sBAAsB,CAAC;AA+B3B,SACE,gBAAAH;AAAA,IAACU;AAAA,IAAA;AAAA,MACC;AAAA,MAEA,OAAO,gBAAgB;AAAA,MACvB,UAAU;AAAA,MAEV,0BAAAV;AAAA,QAACW;AAAA,QAAA;AAAA,UACC;AAAA,UACA,aAAa;AAAA,UACb;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA;AAAA,MACF;AAAA;AAAA,EACF;AAEJ;;;AD7HI,gBAAAC,aAAA;AA7CJ,SAAS,iBAAiB;AAAA,EACxB,mBAAmB,EAAE,UAAU,aAAa,GAAG,QAAQ;AAAA,EACvD;AACF,GAGG;AACD,QAAM,CAAC,UAAU,WAAW,IAAIC,WAAS,QAAQ,mBAAmB,EAAE;AACtE,QAAM,cAAcC,SAAO,QAAQ;AACnC,QAAM,SAAS,UAAU,OAAO;AAEhC,cAAY,UAAU;AAEtB;AAAA,IACE;AAAA,IACA,MAAM;AACJ,aAAO;AAAA,QACL,cAAc;AACZ,iBAAO,YAAY;AAAA,QACrB;AAAA,QACA,YAAYC,WAAkB;AAC5B,sBAAY,UAAUA;AACtB,sBAAYA,SAAQ;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAAA,IACA,CAAC,aAAa,WAAW;AAAA,EAC3B;AAEA,QAAM,mBAAmBC;AAAA,IACvB,CAACD,cAAqB;AAOpB,kBAAY,UAAUA;AACtB,kBAAYA,SAAQ;AACpB,iBAAWA,SAAQ;AAAA,IACrB;AAAA,IACA,CAAC,MAAM;AAAA,EACT;AAEA,SACE,gBAAAH;AAAA,IAACK;AAAA,IAAA;AAAA,MACC;AAAA,MACA,OAAO;AAAA,MACP,UAAU;AAAA,MACV;AAAA;AAAA,EACF;AAEJ;AAKO,SAAS,eACd,kBACA,SACU;AACV,QAAM,uBAAuB,UAA6B;AAE1D,QAAM,OAAO,WAAW,gBAAgB;AAExC,OAAK;AAAA,IACH,gBAAAL;AAAA,MAAC;AAAA;AAAA,QACC;AAAA,QACA,mBAAmB;AAAA;AAAA,IACrB;AAAA,EACF;AAEA,SAAO;AAAA,IACL,UAAU;AACR,UAAI;AACF,aAAK,QAAQ;AAAA,MACf,SAAS,GAAP;AAAA,MAEF;AAAA,IACF;AAAA,IACA,cAAc;AACZ,aAAO,qBAAqB,SAAS,YAAY,KAAK;AAAA,IAKxD;AAAA,IACA,YAAY,UAAkB;AAC5B,2BAAqB,SAAS,YAAY,QAAQ;AAAA,IACpD;AAAA,EACF;AACF;","names":["isBuffer","isArray","isPlainObject","key","setProperty","getProperty","extend","useCallback","useRef","useState","throttle","useCallback","useRef","Editor","Transforms","ReactEditor","Slate","list","all","index","extension","code","list","code","ok","data","code","buffer","trail","index","code","constructs","index","index","text","ok","attentionMarkers","previous","code","point","ok","code","ok","code","ok","code","ok","code","ok","code","characterReference","ok","code","ok","code","effects","nok","start","ok","code","furtherStart","index","code","ok","between","data","index","previous","start","ok","previous","code","ok","code","ok","code","ok","code","ok","code","ok","code","titleBefore","ok","code","content","text","ok","code","data","index","ok","buffer","code","ok","index","code","index","text","ok","defined","code","ok","code","ok","code","ok","code","ok","code","ok","code","index","content","text","definition","ok","code","tokenizeIndent","ok","index","defined","code","string","data","index","text","insideSpan","ok","previous","code","index","index","ok","code","index","map","ok","code","index","string","index","all","node","key","is","node","index","visit","replace","node","index","find","position","key","node","domain","path","previous","trail","code","base","code","head","node","index","map","one","value","list","index","index","position","node","exit","index","index","node","exit","node","index","position","row","sizes","columnIndex","code","exit","node","index","node","exit","map","index","node","index","data","list","index","content","previous","code","data","document","code","point","index","ok","code","text","constructs","code","data","list","index","parser","point","exit","code","constructs","map","all","list","ok","from","index","document","flow","string","text","document","flow","string","text","constructs","parser","create","content","document","text","buffer","code","point","own","blockQuote","buffer","codeText","definition","listItem","list","thematicBreak","data","exit","index","point","key","create","node","text","string","extension","parser","import_is_buffer","index","position","index","path","index","code","path","index","index","prop","path","dirname","assertPath","basename","extname","bufferLike","own","data","parse","index","extend","key","value","options","plugins","node","file","isBuffer","element","content","content","SlateText","SlateText","text","s","SlateText","SlateText","content","content","listItem","list","listItem","content","content","node","own","node","definition","definition","index","node","parse","element","element","SlateText","index","Element","node","index","node","index","node","node","index","text","index","node","index","node","node","Element","SlateText","text","text","SlateText","SlateText","index","element","element","indent","element","serialize","plugins","plugins","plugins","key","plugins","renderElement","plugins","plugins","jsx","plugins","plugins","node","plugins","plugins","withSink","Element","Editor","Element","node","Editor","jsx","Element","node","Element","Editor","Editor","Editor","Editor","Editor","Editor","SlateElement","Range","Range","node","SlateElement","Editor","text","isHotkey","isHotkey","Editor","Transforms","path","Editor","path","Editor","Transforms","path","Editor","Element","Path","Transforms","element","node","Element","Editor","Transforms","Path","Editor","Transforms","Editor","Transforms","Editor","Transforms","convert","node","text","isUrl","Transforms","Transforms","Editor","Range","Text","Transforms","text","node","Transforms","Transforms","Element","Transforms","useEffect","useRef","useSlateStatic","upload","upload","jsx","layers","styled","styled","useCallback","useSlateStatic","styled","jsx","index","key","useRef","useSlateStatic","useEffect","useState","counter","useEffect","element","element","styled","styled","styled","styled","styled","styled","styled","styled","styled","styled","styled","ReactEditor","jsx","jsxs","ReactEditor","Fragment","jsx","jsxs","useSlateStatic","useRef","dest","index","useCallback","styled","jsx","jsxs","styled","jsx","styled","jsx","useCallback","styled","useCallback","useRef","useState","useSlateStatic","styled","jsx","jsxs","styled","element","destAnchor","destStartEdge","useSlateStatic","useState","useRef","useCallback","href","title","jsx","jsx","jsxs","$AnchorDialog","styled","parseUrl","element","useSlateStatic","destAnchor","destStartEdge","removeLink","useCallback","useRef","jsx","useRef","jsx","jsxs","element","useRef","upload","useEffect","jsx","element","Editor","Transforms","Element","Path","Path","Element","Editor","Transforms","Element","Transforms","styled","jsx","node","Element","Transforms","path","element","Editor","Element","Transforms","Element","Node","node","path","text","offset","Element","Transforms","Element","Transforms","Element","Node","Transforms","normalizeNode","path","useCallback","useRef","useSelected","jsx","styled","jsx","jsxs","element","useRef","useSelected","useCallback","useSelected","jsx","useSelected","jsx","element","jsx","Editor","Transforms","element","normalizeNode","Element","Element","Element","Transforms","node","Element","Transforms","Element","Transforms","node","Element","Transforms","normalizeNode","node","path","Element","clsx","useSelected","styled","Node","element","jsx","element","useSelected","clsx","jsx","normalizeNode","element","Editor","Element","Editor","node","Element","element","Editor","Path","Range","Transforms","Range","Editor","Path","Transforms","element","styled","jsx","element","useSelected","styled","jsx","jsxs","useSelected","jsx","element","Editor","Transforms","ReactEditor","normalizeNode","useSlateStatic","styled","clsx","useState","useSelected","styled","clsx","useCallback","Transforms","ReactEditor","useSlateStatic","useEffect","useEffect","styled","ReactEditor","element","Fragment","jsx","jsxs","element","ReactEditor","useSlateStatic","useCallback","e","path","size","Transforms","clsx","styled","jsxs","styled","styled","clsx","useCallback","Transforms","ReactEditor","useSlateStatic","jsx","element","useSlateStatic","useCallback","path","ReactEditor","Transforms","clsx","jsx","element","useCallback","useSlateStatic","jsx","jsxs","jsxs","jsx","Editor","Transforms","ReactEditor","element","path","ReactEditor","Editor","Transforms","jsx","element","useSlateStatic","useCallback","useCallback","useSlateStatic","Editor","Text","Transforms","ReactEditor","element","path","ReactEditor","Editor","Transforms","node","index","Text","jsx","element","useSlateStatic","useCallback","jsx","jsxs","element","jsx","jsxs","element","jsx","jsxs","element","upload","useSelected","useState","clsx","jsx","jsxs","element","useSlateStatic","useSlateStatic","styled","jsx","jsxs","element","useSlateStatic","jsx","renderElement","element","Transforms","Editor","ReactEditor","element","normalizeNode","renderElement","styled","jsx","jsxs","Editor","Path","element","indent","node","Editor","Transforms","insertBreak","element","path","Editor","Transforms","Editor","Editor","node","Transforms","Transforms","indent","insertBreak","Element","Transforms","node","path","Element","Transforms","normalizeNode","node","clsx","useEffect","ReactEditor","useSlateStatic","styled","styled","jsx","element","useSlateStatic","useEffect","path","ReactEditor","clsx","useCallback","useSlateStatic","jsx","jsxs","jsx","jsxs","element","useSlateStatic","useCallback","jsx","jsxs","element","jsx","renderElement","element","list","normalizeNode","listItem","Path","Editor","renderElement","clsx","Editor","Range","Transforms","Editor","point","Editor","Element","point","node","Element","Editor","text","Range","Transforms","Editor","text","Editor","Text","Transforms","node","key","Editor","Text","Transforms","styled","jsx","clsx","Editor","Point","Editor","Point","Element","Editor","Path","Transforms","Editor","Path","Editor","Path","range","Editor","Path","Transforms","Transforms","Editor","Transforms","index","Editor","Transforms","Transforms","index","Transforms","Editor","Element","Path","Transforms","createRow","index","insertRootElement","element","node","Element","Editor","Transforms","Path","Path","Path","ReactEditor","element","Editor","Transforms","Transforms","Editor","Transforms","rowIndex","Editor","Transforms","Editor","Transforms","Transforms","Transforms","Transforms","Transforms","Editor","Transforms","node","path","useEffect","ReactEditor","useSelected","useSlateStatic","styled","styled","styled","index","createContext","jsx","element","useSlateStatic","useSelected","useEffect","path","ReactEditor","useContext","useSelected","useCallback","useRef","useState","useSlateStatic","jsx","Fragment","jsx","jsxs","useSlateStatic","useRef","useState","useCallback","useState","useSlateStatic","Fragment","jsx","jsxs","useSlateStatic","useState","styled","jsx","jsx","jsxs","element","useContext","useSelected","jsx","jsx","jsx","renderElement","element","element","node","Element","renderElement","css","css","Fragment","jsx","jsxs","Editable","clsx","useCallback","useRef","Editor","Transforms","ReactEditor","useSlateStatic","clsx","useCallback","useRef","useState","ReactEditor","useSlateStatic","styled","styled","Fragment","jsx","jsxs","createRange","useState","useSlateStatic","useRef","dest","useCallback","createTable","ReactEditor","clsx","throttle","useEffect","useRef","useState","useSlateStatic","jsx","jsxs","Paragraph","Table","Paragraph","styled","useCallback","useRef","Transforms","ReactEditor","useSlateStatic","Fragment","jsx","jsxs","useSlateStatic","useRef","dest","useCallback","Transforms","ReactEditor","styled","useRef","useSlateStatic","styled","styled","styled","Fragment","jsx","jsxs","useSlateStatic","useRef","dest","Table","isHotkey","useCallback","useRef","useState","ReactEditor","useSlateStatic","Fragment","jsx","jsxs","isHotkey","AnchorDialog","useSlateStatic","useRef","dest","useState","insertLink","ReactEditor","useCallback","AnchorDialog","clsx","useCallback","useRef","ReactEditor","useSlateStatic","jsx","jsxs","useSlateStatic","useRef","useCallback","ReactEditor","clsx","jsx","useSlateStatic","useRef","useState","useEffect","throttle","index","jsx","jsxs","Editable","useRef","useSlateStatic","useCallback","Transforms","Editor","ReactEditor","clsx","Editor","Node","Path","Transforms","Editor","Node","Transforms","Path","Editor","Element","Transforms","keys","key","Editor","Transforms","ReactEditor","Transforms","Editor","ReactEditor","Transforms","parse","Transforms","jsx","SinkEditable","useState","Editor","Transforms","useState","editor","serialize","parse","Transforms","Editor","jsx","Editable","useRef","useCallback","throttle","serialize","parse","Transforms","Editor","ReactEditor","Slate","SinkEditable","jsx","useState","useRef","markdown","useCallback","Editable"]}